<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Flow Workshop â€” Visual API Pipelines</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600&family=Fraunces:wght@400;700;900&family=Outfit:wght@300;400;500;600&display=swap" rel="stylesheet">
<style id="drawflow-base">.drawflow,.drawflow .parent-node{position:relative}.parent-drawflow{display:flex;overflow:hidden;touch-action:none;outline:0}.drawflow{width:100%;height:100%;user-select:none;perspective:0}.drawflow .drawflow-node{display:flex;align-items:center;position:absolute;background:#0ff;width:160px;min-height:40px;border-radius:4px;border:2px solid #000;color:#000;z-index:2;padding:15px}.drawflow .drawflow-node.selected{background:red}.drawflow .drawflow-node:hover{cursor:move}.drawflow .drawflow-node .inputs,.drawflow .drawflow-node .outputs{width:0}.drawflow .drawflow-node .drawflow_content_node{width:100%;display:block}.drawflow .drawflow-node .input,.drawflow .drawflow-node .output{position:relative;width:20px;height:20px;background:#fff;border-radius:50%;border:2px solid #000;cursor:crosshair;z-index:1;margin-bottom:5px}.drawflow .drawflow-node .input{left:-27px;top:2px;background:#ff0}.drawflow .drawflow-node .output{right:-3px;top:2px}.drawflow svg{z-index:0;position:absolute;overflow:visible!important}.drawflow .connection{position:absolute;pointer-events:none;aspect-ratio:1/1}.drawflow .connection .main-path{fill:none;stroke-width:5px;stroke:#4682b4;pointer-events:all}.drawflow .connection .main-path:hover{stroke:#1266ab;cursor:pointer}.drawflow .connection .main-path.selected{stroke:#43b993}.drawflow .connection .point{cursor:move;stroke:#000;stroke-width:2;fill:#fff;pointer-events:all}.drawflow .connection .point.selected,.drawflow .connection .point:hover{fill:#1266ab}.drawflow .main-path{fill:none;stroke-width:5px;stroke:#4682b4}.drawflow-delete{position:absolute;display:block;width:30px;height:30px;background:#000;color:#fff;z-index:4;border:2px solid #fff;line-height:30px;font-weight:700;text-align:center;border-radius:50%;font-family:monospace;cursor:pointer}.drawflow>.drawflow-delete{margin-left:-15px;margin-top:15px}.parent-node .drawflow-delete{right:-15px;top:-15px}</style>
<script>!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define([],t):"object"==typeof exports?exports.Drawflow=t():e.Drawflow=t()}("undefined"!=typeof self?self:this,(function(){return function(e){var t={};function n(i){if(t[i])return t[i].exports;var s=t[i]={i:i,l:!1,exports:{}};return e[i].call(s.exports,s,s.exports,n),s.l=!0,s.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var s in e)n.d(i,s,function(t){return e[t]}.bind(null,s));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=0)}([function(e,t,n){"use strict";n.r(t),n.d(t,"default",(function(){return i}));class i{constructor(e,t=null,n=null){this.events={},this.container=e,this.precanvas=null,this.nodeId=1,this.ele_selected=null,this.node_selected=null,this.drag=!1,this.reroute=!1,this.reroute_fix_curvature=!1,this.curvature=.5,this.reroute_curvature_start_end=.5,this.reroute_curvature=.5,this.reroute_width=6,this.drag_point=!1,this.editor_selected=!1,this.connection=!1,this.connection_ele=null,this.connection_selected=null,this.canvas_x=0,this.canvas_y=0,this.pos_x=0,this.pos_x_start=0,this.pos_y=0,this.pos_y_start=0,this.mouse_x=0,this.mouse_y=0,this.line_path=5,this.first_click=null,this.force_first_input=!1,this.draggable_inputs=!0,this.useuuid=!1,this.parent=n,this.noderegister={},this.render=t,this.drawflow={drawflow:{Home:{data:{}}}},this.module="Home",this.editor_mode="edit",this.zoom=1,this.zoom_max=1.6,this.zoom_min=.5,this.zoom_value=.1,this.zoom_last_value=1,this.evCache=new Array,this.prevDiff=-1}start(){this.container.classList.add("parent-drawflow"),this.container.tabIndex=0,this.precanvas=document.createElement("div"),this.precanvas.classList.add("drawflow"),this.container.appendChild(this.precanvas),this.container.addEventListener("mouseup",this.dragEnd.bind(this)),this.container.addEventListener("mousemove",this.position.bind(this)),this.container.addEventListener("mousedown",this.click.bind(this)),this.container.addEventListener("touchend",this.dragEnd.bind(this)),this.container.addEventListener("touchmove",this.position.bind(this)),this.container.addEventListener("touchstart",this.click.bind(this)),this.container.addEventListener("contextmenu",this.contextmenu.bind(this)),this.container.addEventListener("keydown",this.key.bind(this)),this.container.addEventListener("wheel",this.zoom_enter.bind(this)),this.container.addEventListener("input",this.updateNodeValue.bind(this)),this.container.addEventListener("dblclick",this.dblclick.bind(this)),this.container.onpointerdown=this.pointerdown_handler.bind(this),this.container.onpointermove=this.pointermove_handler.bind(this),this.container.onpointerup=this.pointerup_handler.bind(this),this.container.onpointercancel=this.pointerup_handler.bind(this),this.container.onpointerout=this.pointerup_handler.bind(this),this.container.onpointerleave=this.pointerup_handler.bind(this),this.load()}pointerdown_handler(e){this.evCache.push(e)}pointermove_handler(e){for(var t=0;t<this.evCache.length;t++)if(e.pointerId==this.evCache[t].pointerId){this.evCache[t]=e;break}if(2==this.evCache.length){var n=Math.abs(this.evCache[0].clientX-this.evCache[1].clientX);this.prevDiff>100&&(n>this.prevDiff&&this.zoom_in(),n<this.prevDiff&&this.zoom_out()),this.prevDiff=n}}pointerup_handler(e){this.remove_event(e),this.evCache.length<2&&(this.prevDiff=-1)}remove_event(e){for(var t=0;t<this.evCache.length;t++)if(this.evCache[t].pointerId==e.pointerId){this.evCache.splice(t,1);break}}load(){for(var e in this.drawflow.drawflow[this.module].data)this.addNodeImport(this.drawflow.drawflow[this.module].data[e],this.precanvas);if(this.reroute)for(var e in this.drawflow.drawflow[this.module].data)this.addRerouteImport(this.drawflow.drawflow[this.module].data[e]);for(var e in this.drawflow.drawflow[this.module].data)this.updateConnectionNodes("node-"+e);const t=this.drawflow.drawflow;let n=1;Object.keys(t).map((function(e,i){Object.keys(t[e].data).map((function(e,t){parseInt(e)>=n&&(n=parseInt(e)+1)}))})),this.nodeId=n}removeReouteConnectionSelected(){this.dispatch("connectionUnselected",!0),this.reroute_fix_curvature&&this.connection_selected.parentElement.querySelectorAll(".main-path").forEach((e,t)=>{e.classList.remove("selected")})}click(e){if(this.dispatch("click",e),"fixed"===this.editor_mode){if("parent-drawflow"!==e.target.classList[0]&&"drawflow"!==e.target.classList[0])return!1;this.ele_selected=e.target.closest(".parent-drawflow"),e.preventDefault()}else"view"===this.editor_mode?(null!=e.target.closest(".drawflow")||e.target.matches(".parent-drawflow"))&&(this.ele_selected=e.target.closest(".parent-drawflow"),e.preventDefault()):(this.first_click=e.target,this.ele_selected=e.target,0===e.button&&this.contextmenuDel(),null!=e.target.closest(".drawflow_content_node")&&(this.ele_selected=e.target.closest(".drawflow_content_node").parentElement));switch(this.ele_selected.classList[0]){case"drawflow-node":null!=this.node_selected&&(this.node_selected.classList.remove("selected"),this.node_selected!=this.ele_selected&&this.dispatch("nodeUnselected",!0)),null!=this.connection_selected&&(this.connection_selected.classList.remove("selected"),this.removeReouteConnectionSelected(),this.connection_selected=null),this.node_selected!=this.ele_selected&&this.dispatch("nodeSelected",this.ele_selected.id.slice(5)),this.node_selected=this.ele_selected,this.node_selected.classList.add("selected"),this.draggable_inputs?"SELECT"!==e.target.tagName&&(this.drag=!0):"INPUT"!==e.target.tagName&&"TEXTAREA"!==e.target.tagName&&"SELECT"!==e.target.tagName&&!0!==e.target.hasAttribute("contenteditable")&&(this.drag=!0);break;case"output":this.connection=!0,null!=this.node_selected&&(this.node_selected.classList.remove("selected"),this.node_selected=null,this.dispatch("nodeUnselected",!0)),null!=this.connection_selected&&(this.connection_selected.classList.remove("selected"),this.removeReouteConnectionSelected(),this.connection_selected=null),this.drawConnection(e.target);break;case"parent-drawflow":case"drawflow":null!=this.node_selected&&(this.node_selected.classList.remove("selected"),this.node_selected=null,this.dispatch("nodeUnselected",!0)),null!=this.connection_selected&&(this.connection_selected.classList.remove("selected"),this.removeReouteConnectionSelected(),this.connection_selected=null),this.editor_selected=!0;break;case"main-path":null!=this.node_selected&&(this.node_selected.classList.remove("selected"),this.node_selected=null,this.dispatch("nodeUnselected",!0)),null!=this.connection_selected&&(this.connection_selected.classList.remove("selected"),this.removeReouteConnectionSelected(),this.connection_selected=null),this.connection_selected=this.ele_selected,this.connection_selected.classList.add("selected");const t=this.connection_selected.parentElement.classList;t.length>1&&(this.dispatch("connectionSelected",{output_id:t[2].slice(14),input_id:t[1].slice(13),output_class:t[3],input_class:t[4]}),this.reroute_fix_curvature&&this.connection_selected.parentElement.querySelectorAll(".main-path").forEach((e,t)=>{e.classList.add("selected")}));break;case"point":this.drag_point=!0,this.ele_selected.classList.add("selected");break;case"drawflow-delete":this.node_selected&&this.removeNodeId(this.node_selected.id),this.connection_selected&&this.removeConnection(),null!=this.node_selected&&(this.node_selected.classList.remove("selected"),this.node_selected=null,this.dispatch("nodeUnselected",!0)),null!=this.connection_selected&&(this.connection_selected.classList.remove("selected"),this.removeReouteConnectionSelected(),this.connection_selected=null)}"touchstart"===e.type?(this.pos_x=e.touches[0].clientX,this.pos_x_start=e.touches[0].clientX,this.pos_y=e.touches[0].clientY,this.pos_y_start=e.touches[0].clientY,this.mouse_x=e.touches[0].clientX,this.mouse_y=e.touches[0].clientY):(this.pos_x=e.clientX,this.pos_x_start=e.clientX,this.pos_y=e.clientY,this.pos_y_start=e.clientY),["input","output","main-path"].includes(this.ele_selected.classList[0])&&e.preventDefault(),this.dispatch("clickEnd",e)}position(e){if("touchmove"===e.type)var t=e.touches[0].clientX,n=e.touches[0].clientY;else t=e.clientX,n=e.clientY;if(this.connection&&this.updateConnection(t,n),this.editor_selected&&(i=this.canvas_x+-(this.pos_x-t),s=this.canvas_y+-(this.pos_y-n),this.dispatch("translate",{x:i,y:s}),this.precanvas.style.transform="translate("+i+"px, "+s+"px) scale("+this.zoom+")"),this.drag){e.preventDefault();var i=(this.pos_x-t)*this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom),s=(this.pos_y-n)*this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom);this.pos_x=t,this.pos_y=n,this.ele_selected.style.top=this.ele_selected.offsetTop-s+"px",this.ele_selected.style.left=this.ele_selected.offsetLeft-i+"px",this.drawflow.drawflow[this.module].data[this.ele_selected.id.slice(5)].pos_x=this.ele_selected.offsetLeft-i,this.drawflow.drawflow[this.module].data[this.ele_selected.id.slice(5)].pos_y=this.ele_selected.offsetTop-s,this.updateConnectionNodes(this.ele_selected.id)}if(this.drag_point){i=(this.pos_x-t)*this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom),s=(this.pos_y-n)*this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom);this.pos_x=t,this.pos_y=n;var o=this.pos_x*(this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom))-this.precanvas.getBoundingClientRect().x*(this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom)),l=this.pos_y*(this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom))-this.precanvas.getBoundingClientRect().y*(this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom));this.ele_selected.setAttributeNS(null,"cx",o),this.ele_selected.setAttributeNS(null,"cy",l);const e=this.ele_selected.parentElement.classList[2].slice(9),c=this.ele_selected.parentElement.classList[1].slice(13),d=this.ele_selected.parentElement.classList[3],a=this.ele_selected.parentElement.classList[4];let r=Array.from(this.ele_selected.parentElement.children).indexOf(this.ele_selected)-1;if(this.reroute_fix_curvature){r-=this.ele_selected.parentElement.querySelectorAll(".main-path").length-1,r<0&&(r=0)}const h=e.slice(5),u=this.drawflow.drawflow[this.module].data[h].outputs[d].connections.findIndex((function(e,t){return e.node===c&&e.output===a}));this.drawflow.drawflow[this.module].data[h].outputs[d].connections[u].points[r]={pos_x:o,pos_y:l};const p=this.ele_selected.parentElement.classList[2].slice(9);this.updateConnectionNodes(p)}"touchmove"===e.type&&(this.mouse_x=t,this.mouse_y=n),this.dispatch("mouseMove",{x:t,y:n})}dragEnd(e){if("touchend"===e.type)var t=this.mouse_x,n=this.mouse_y,i=document.elementFromPoint(t,n);else t=e.clientX,n=e.clientY,i=e.target;if(this.drag&&(this.pos_x_start==t&&this.pos_y_start==n||this.dispatch("nodeMoved",this.ele_selected.id.slice(5))),this.drag_point&&(this.ele_selected.classList.remove("selected"),this.pos_x_start==t&&this.pos_y_start==n||this.dispatch("rerouteMoved",this.ele_selected.parentElement.classList[2].slice(14))),this.editor_selected&&(this.canvas_x=this.canvas_x+-(this.pos_x-t),this.canvas_y=this.canvas_y+-(this.pos_y-n),this.editor_selected=!1),!0===this.connection)if("input"===i.classList[0]||this.force_first_input&&(null!=i.closest(".drawflow_content_node")||"drawflow-node"===i.classList[0])){if(!this.force_first_input||null==i.closest(".drawflow_content_node")&&"drawflow-node"!==i.classList[0])s=i.parentElement.parentElement.id,o=i.classList[1];else{if(null!=i.closest(".drawflow_content_node"))var s=i.closest(".drawflow_content_node").parentElement.id;else var s=i.id;if(0===Object.keys(this.getNodeFromId(s.slice(5)).inputs).length)var o=!1;else var o="input_1"}var l=this.ele_selected.parentElement.parentElement.id,c=this.ele_selected.classList[1];if(l!==s&&!1!==o){if(0===this.container.querySelectorAll(".connection.node_in_"+s+".node_out_"+l+"."+c+"."+o).length){this.connection_ele.classList.add("node_in_"+s),this.connection_ele.classList.add("node_out_"+l),this.connection_ele.classList.add(c),this.connection_ele.classList.add(o);var d=s.slice(5),a=l.slice(5);this.drawflow.drawflow[this.module].data[a].outputs[c].connections.push({node:d,output:o}),this.drawflow.drawflow[this.module].data[d].inputs[o].connections.push({node:a,input:c}),this.updateConnectionNodes("node-"+a),this.updateConnectionNodes("node-"+d),this.dispatch("connectionCreated",{output_id:a,input_id:d,output_class:c,input_class:o})}else this.dispatch("connectionCancel",!0),this.connection_ele.remove();this.connection_ele=null}else this.dispatch("connectionCancel",!0),this.connection_ele.remove(),this.connection_ele=null}else this.dispatch("connectionCancel",!0),this.connection_ele.remove(),this.connection_ele=null;this.drag=!1,this.drag_point=!1,this.connection=!1,this.ele_selected=null,this.editor_selected=!1,this.dispatch("mouseUp",e)}contextmenu(e){if(this.dispatch("contextmenu",e),e.preventDefault(),"fixed"===this.editor_mode||"view"===this.editor_mode)return!1;if(this.precanvas.getElementsByClassName("drawflow-delete").length&&this.precanvas.getElementsByClassName("drawflow-delete")[0].remove(),this.node_selected||this.connection_selected){var t=document.createElement("div");t.classList.add("drawflow-delete"),t.innerHTML="x",this.node_selected&&this.node_selected.appendChild(t),this.connection_selected&&this.connection_selected.parentElement.classList.length>1&&(t.style.top=e.clientY*(this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom))-this.precanvas.getBoundingClientRect().y*(this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom))+"px",t.style.left=e.clientX*(this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom))-this.precanvas.getBoundingClientRect().x*(this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom))+"px",this.precanvas.appendChild(t))}}contextmenuDel(){this.precanvas.getElementsByClassName("drawflow-delete").length&&this.precanvas.getElementsByClassName("drawflow-delete")[0].remove()}key(e){if(this.dispatch("keydown",e),"fixed"===this.editor_mode||"view"===this.editor_mode)return!1;("Delete"===e.key||"Backspace"===e.key&&e.metaKey)&&(null!=this.node_selected&&"INPUT"!==this.first_click.tagName&&"TEXTAREA"!==this.first_click.tagName&&!0!==this.first_click.hasAttribute("contenteditable")&&this.removeNodeId(this.node_selected.id),null!=this.connection_selected&&this.removeConnection())}zoom_enter(e,t){e.ctrlKey&&(e.preventDefault(),e.deltaY>0?this.zoom_out():this.zoom_in())}zoom_refresh(){this.dispatch("zoom",this.zoom),this.canvas_x=this.canvas_x/this.zoom_last_value*this.zoom,this.canvas_y=this.canvas_y/this.zoom_last_value*this.zoom,this.zoom_last_value=this.zoom,this.precanvas.style.transform="translate("+this.canvas_x+"px, "+this.canvas_y+"px) scale("+this.zoom+")"}zoom_in(){this.zoom<this.zoom_max&&(this.zoom+=this.zoom_value,this.zoom_refresh())}zoom_out(){this.zoom>this.zoom_min&&(this.zoom-=this.zoom_value,this.zoom_refresh())}zoom_reset(){1!=this.zoom&&(this.zoom=1,this.zoom_refresh())}createCurvature(e,t,n,i,s,o){var l=e,c=t,d=n,a=i,r=s;switch(o){case"open":if(e>=n)var h=l+Math.abs(d-l)*r,u=d-Math.abs(d-l)*(-1*r);else h=l+Math.abs(d-l)*r,u=d-Math.abs(d-l)*r;return" M "+l+" "+c+" C "+h+" "+c+" "+u+" "+a+" "+d+"  "+a;case"close":if(e>=n)h=l+Math.abs(d-l)*(-1*r),u=d-Math.abs(d-l)*r;else h=l+Math.abs(d-l)*r,u=d-Math.abs(d-l)*r;return" M "+l+" "+c+" C "+h+" "+c+" "+u+" "+a+" "+d+"  "+a;case"other":if(e>=n)h=l+Math.abs(d-l)*(-1*r),u=d-Math.abs(d-l)*(-1*r);else h=l+Math.abs(d-l)*r,u=d-Math.abs(d-l)*r;return" M "+l+" "+c+" C "+h+" "+c+" "+u+" "+a+" "+d+"  "+a;default:return" M "+l+" "+c+" C "+(h=l+Math.abs(d-l)*r)+" "+c+" "+(u=d-Math.abs(d-l)*r)+" "+a+" "+d+"  "+a}}drawConnection(e){var t=document.createElementNS("http://www.w3.org/2000/svg","svg");this.connection_ele=t;var n=document.createElementNS("http://www.w3.org/2000/svg","path");n.classList.add("main-path"),n.setAttributeNS(null,"d",""),t.classList.add("connection"),t.appendChild(n),this.precanvas.appendChild(t);var i=e.parentElement.parentElement.id.slice(5),s=e.classList[1];this.dispatch("connectionStart",{output_id:i,output_class:s})}updateConnection(e,t){const n=this.precanvas,i=this.zoom;let s=n.clientWidth/(n.clientWidth*i);s=s||0;let o=n.clientHeight/(n.clientHeight*i);o=o||0;var l=this.connection_ele.children[0],c=this.ele_selected.offsetWidth/2+(this.ele_selected.getBoundingClientRect().x-n.getBoundingClientRect().x)*s,d=this.ele_selected.offsetHeight/2+(this.ele_selected.getBoundingClientRect().y-n.getBoundingClientRect().y)*o,a=e*(this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom))-this.precanvas.getBoundingClientRect().x*(this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom)),r=t*(this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom))-this.precanvas.getBoundingClientRect().y*(this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom)),h=this.curvature,u=this.createCurvature(c,d,a,r,h,"openclose");l.setAttributeNS(null,"d",u)}addConnection(e,t,n,i){var s=this.getModuleFromNodeId(e);if(s===this.getModuleFromNodeId(t)){var o=this.getNodeFromId(e),l=!1;for(var c in o.outputs[n].connections){var d=o.outputs[n].connections[c];d.node==t&&d.output==i&&(l=!0)}if(!1===l){if(this.drawflow.drawflow[s].data[e].outputs[n].connections.push({node:t.toString(),output:i}),this.drawflow.drawflow[s].data[t].inputs[i].connections.push({node:e.toString(),input:n}),this.module===s){var a=document.createElementNS("http://www.w3.org/2000/svg","svg"),r=document.createElementNS("http://www.w3.org/2000/svg","path");r.classList.add("main-path"),r.setAttributeNS(null,"d",""),a.classList.add("connection"),a.classList.add("node_in_node-"+t),a.classList.add("node_out_node-"+e),a.classList.add(n),a.classList.add(i),a.appendChild(r),this.precanvas.appendChild(a),this.updateConnectionNodes("node-"+e),this.updateConnectionNodes("node-"+t)}this.dispatch("connectionCreated",{output_id:e,input_id:t,output_class:n,input_class:i})}}}updateConnectionNodes(e){const t="node_in_"+e,n="node_out_"+e;this.line_path;const i=this.container,s=this.precanvas,o=this.curvature,l=this.createCurvature,c=this.reroute_curvature,d=this.reroute_curvature_start_end,a=this.reroute_fix_curvature,r=this.reroute_width,h=this.zoom;let u=s.clientWidth/(s.clientWidth*h);u=u||0;let p=s.clientHeight/(s.clientHeight*h);p=p||0;const f=i.querySelectorAll("."+n);Object.keys(f).map((function(t,n){if(null===f[t].querySelector(".point")){var m=i.querySelector("#"+e),g=f[t].classList[1].replace("node_in_",""),_=i.querySelector("#"+g).querySelectorAll("."+f[t].classList[4])[0],w=_.offsetWidth/2+(_.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,v=_.offsetHeight/2+(_.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,y=m.querySelectorAll("."+f[t].classList[3])[0],C=y.offsetWidth/2+(y.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,x=y.offsetHeight/2+(y.getBoundingClientRect().y-s.getBoundingClientRect().y)*p;const n=l(C,x,w,v,o,"openclose");f[t].children[0].setAttributeNS(null,"d",n)}else{const n=f[t].querySelectorAll(".point");let o="";const m=[];n.forEach((t,a)=>{if(0===a&&n.length-1==0){var f=i.querySelector("#"+e),g=((x=t).getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,_=(x.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,w=(L=f.querySelectorAll("."+t.parentElement.classList[3])[0]).offsetWidth/2+(L.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,v=L.offsetHeight/2+(L.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,y=l(w,v,g,_,d,"open");o+=y,m.push(y);f=t;var C=t.parentElement.classList[1].replace("node_in_",""),x=(E=i.querySelector("#"+C)).querySelectorAll("."+t.parentElement.classList[4])[0];g=(R=E.querySelectorAll("."+t.parentElement.classList[4])[0]).offsetWidth/2+(R.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,_=R.offsetHeight/2+(R.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,w=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,v=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,y=l(w,v,g,_,d,"close");o+=y,m.push(y)}else if(0===a){var L;f=i.querySelector("#"+e),g=((x=t).getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,_=(x.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,w=(L=f.querySelectorAll("."+t.parentElement.classList[3])[0]).offsetWidth/2+(L.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,v=L.offsetHeight/2+(L.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,y=l(w,v,g,_,d,"open");o+=y,m.push(y);f=t,g=((x=n[a+1]).getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,_=(x.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,w=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,v=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,y=l(w,v,g,_,c,"other");o+=y,m.push(y)}else if(a===n.length-1){var E,R;f=t,C=t.parentElement.classList[1].replace("node_in_",""),x=(E=i.querySelector("#"+C)).querySelectorAll("."+t.parentElement.classList[4])[0],g=(R=E.querySelectorAll("."+t.parentElement.classList[4])[0]).offsetWidth/2+(R.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,_=R.offsetHeight/2+(R.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,w=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*(s.clientWidth/(s.clientWidth*h))+r,v=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*(s.clientHeight/(s.clientHeight*h))+r,y=l(w,v,g,_,d,"close");o+=y,m.push(y)}else{f=t,g=((x=n[a+1]).getBoundingClientRect().x-s.getBoundingClientRect().x)*(s.clientWidth/(s.clientWidth*h))+r,_=(x.getBoundingClientRect().y-s.getBoundingClientRect().y)*(s.clientHeight/(s.clientHeight*h))+r,w=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*(s.clientWidth/(s.clientWidth*h))+r,v=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*(s.clientHeight/(s.clientHeight*h))+r,y=l(w,v,g,_,c,"other");o+=y,m.push(y)}}),a?m.forEach((e,n)=>{f[t].children[n].setAttributeNS(null,"d",e)}):f[t].children[0].setAttributeNS(null,"d",o)}}));const m=i.querySelectorAll("."+t);Object.keys(m).map((function(t,n){if(null===m[t].querySelector(".point")){var h=i.querySelector("#"+e),f=m[t].classList[2].replace("node_out_",""),g=i.querySelector("#"+f).querySelectorAll("."+m[t].classList[3])[0],_=g.offsetWidth/2+(g.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,w=g.offsetHeight/2+(g.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,v=(h=h.querySelectorAll("."+m[t].classList[4])[0]).offsetWidth/2+(h.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,y=h.offsetHeight/2+(h.getBoundingClientRect().y-s.getBoundingClientRect().y)*p;const n=l(_,w,v,y,o,"openclose");m[t].children[0].setAttributeNS(null,"d",n)}else{const n=m[t].querySelectorAll(".point");let o="";const h=[];n.forEach((t,a)=>{if(0===a&&n.length-1==0){var f=i.querySelector("#"+e),m=((C=t).getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,g=(C.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,_=(E=f.querySelectorAll("."+t.parentElement.classList[4])[0]).offsetWidth/2+(E.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,w=E.offsetHeight/2+(E.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,v=l(m,g,_,w,d,"close");o+=v,h.push(v);f=t;var y=t.parentElement.classList[2].replace("node_out_",""),C=(L=i.querySelector("#"+y)).querySelectorAll("."+t.parentElement.classList[3])[0];m=(x=L.querySelectorAll("."+t.parentElement.classList[3])[0]).offsetWidth/2+(x.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,g=x.offsetHeight/2+(x.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,_=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,w=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,v=l(m,g,_,w,d,"open");o+=v,h.push(v)}else if(0===a){var x;f=t,y=t.parentElement.classList[2].replace("node_out_",""),C=(L=i.querySelector("#"+y)).querySelectorAll("."+t.parentElement.classList[3])[0],m=(x=L.querySelectorAll("."+t.parentElement.classList[3])[0]).offsetWidth/2+(x.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,g=x.offsetHeight/2+(x.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,_=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,w=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,v=l(m,g,_,w,d,"open");o+=v,h.push(v);f=t,_=((C=n[a+1]).getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,w=(C.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,m=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,g=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,v=l(m,g,_,w,c,"other");o+=v,h.push(v)}else if(a===n.length-1){var L,E;f=t,y=t.parentElement.classList[1].replace("node_in_",""),C=(L=i.querySelector("#"+y)).querySelectorAll("."+t.parentElement.classList[4])[0],_=(E=L.querySelectorAll("."+t.parentElement.classList[4])[0]).offsetWidth/2+(E.getBoundingClientRect().x-s.getBoundingClientRect().x)*u,w=E.offsetHeight/2+(E.getBoundingClientRect().y-s.getBoundingClientRect().y)*p,m=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,g=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,v=l(m,g,_,w,d,"close");o+=v,h.push(v)}else{f=t,_=((C=n[a+1]).getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,w=(C.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,m=(f.getBoundingClientRect().x-s.getBoundingClientRect().x)*u+r,g=(f.getBoundingClientRect().y-s.getBoundingClientRect().y)*p+r,v=l(m,g,_,w,c,"other");o+=v,h.push(v)}}),a?h.forEach((e,n)=>{m[t].children[n].setAttributeNS(null,"d",e)}):m[t].children[0].setAttributeNS(null,"d",o)}}))}dblclick(e){null!=this.connection_selected&&this.reroute&&this.createReroutePoint(this.connection_selected),"point"===e.target.classList[0]&&this.removeReroutePoint(e.target)}createReroutePoint(e){this.connection_selected.classList.remove("selected");const t=this.connection_selected.parentElement.classList[2].slice(9),n=this.connection_selected.parentElement.classList[1].slice(13),i=this.connection_selected.parentElement.classList[3],s=this.connection_selected.parentElement.classList[4];this.connection_selected=null;const o=document.createElementNS("http://www.w3.org/2000/svg","circle");o.classList.add("point");var l=this.pos_x*(this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom))-this.precanvas.getBoundingClientRect().x*(this.precanvas.clientWidth/(this.precanvas.clientWidth*this.zoom)),c=this.pos_y*(this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom))-this.precanvas.getBoundingClientRect().y*(this.precanvas.clientHeight/(this.precanvas.clientHeight*this.zoom));o.setAttributeNS(null,"cx",l),o.setAttributeNS(null,"cy",c),o.setAttributeNS(null,"r",this.reroute_width);let d=0;if(this.reroute_fix_curvature){const t=e.parentElement.querySelectorAll(".main-path").length;var a=document.createElementNS("http://www.w3.org/2000/svg","path");if(a.classList.add("main-path"),a.setAttributeNS(null,"d",""),e.parentElement.insertBefore(a,e.parentElement.children[t]),1===t)e.parentElement.appendChild(o);else{const n=Array.from(e.parentElement.children).indexOf(e);d=n,e.parentElement.insertBefore(o,e.parentElement.children[n+t+1])}}else e.parentElement.appendChild(o);const r=t.slice(5),h=this.drawflow.drawflow[this.module].data[r].outputs[i].connections.findIndex((function(e,t){return e.node===n&&e.output===s}));void 0===this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points&&(this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points=[]),this.reroute_fix_curvature?(d>0||this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points!==[]?this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points.splice(d,0,{pos_x:l,pos_y:c}):this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points.push({pos_x:l,pos_y:c}),e.parentElement.querySelectorAll(".main-path").forEach((e,t)=>{e.classList.remove("selected")})):this.drawflow.drawflow[this.module].data[r].outputs[i].connections[h].points.push({pos_x:l,pos_y:c}),this.dispatch("addReroute",r),this.updateConnectionNodes(t)}removeReroutePoint(e){const t=e.parentElement.classList[2].slice(9),n=e.parentElement.classList[1].slice(13),i=e.parentElement.classList[3],s=e.parentElement.classList[4];let o=Array.from(e.parentElement.children).indexOf(e);const l=t.slice(5),c=this.drawflow.drawflow[this.module].data[l].outputs[i].connections.findIndex((function(e,t){return e.node===n&&e.output===s}));if(this.reroute_fix_curvature){const t=e.parentElement.querySelectorAll(".main-path").length;e.parentElement.children[t-1].remove(),o-=t,o<0&&(o=0)}else o--;this.drawflow.drawflow[this.module].data[l].outputs[i].connections[c].points.splice(o,1),e.remove(),this.dispatch("removeReroute",l),this.updateConnectionNodes(t)}registerNode(e,t,n=null,i=null){this.noderegister[e]={html:t,props:n,options:i}}getNodeFromId(e){var t=this.getModuleFromNodeId(e);return JSON.parse(JSON.stringify(this.drawflow.drawflow[t].data[e]))}getNodesFromName(e){var t=[];const n=this.drawflow.drawflow;return Object.keys(n).map((function(i,s){for(var o in n[i].data)n[i].data[o].name==e&&t.push(n[i].data[o].id)})),t}addNode(e,t,n,i,s,o,l,c,d=!1){if(this.useuuid)var a=this.getUuid();else a=this.nodeId;const r=document.createElement("div");r.classList.add("parent-node");const h=document.createElement("div");h.innerHTML="",h.setAttribute("id","node-"+a),h.classList.add("drawflow-node"),""!=o&&h.classList.add(...o.split(" "));const u=document.createElement("div");u.classList.add("inputs");const p=document.createElement("div");p.classList.add("outputs");const f={};for(var m=0;m<t;m++){const e=document.createElement("div");e.classList.add("input"),e.classList.add("input_"+(m+1)),f["input_"+(m+1)]={connections:[]},u.appendChild(e)}const g={};for(m=0;m<n;m++){const e=document.createElement("div");e.classList.add("output"),e.classList.add("output_"+(m+1)),g["output_"+(m+1)]={connections:[]},p.appendChild(e)}const _=document.createElement("div");if(_.classList.add("drawflow_content_node"),!1===d)_.innerHTML=c;else if(!0===d)_.appendChild(this.noderegister[c].html.cloneNode(!0));else if(3===parseInt(this.render.version)){let e=this.render.h(this.noderegister[c].html,this.noderegister[c].props,this.noderegister[c].options);e.appContext=this.parent,this.render.render(e,_)}else{let e=new this.render({parent:this.parent,render:e=>e(this.noderegister[c].html,{props:this.noderegister[c].props}),...this.noderegister[c].options}).$mount();_.appendChild(e.$el)}Object.entries(l).forEach((function(e,t){if("object"==typeof e[1])!function e(t,n,i){if(null===t)t=l[n];else t=t[n];null!==t&&Object.entries(t).forEach((function(n,s){if("object"==typeof n[1])e(t,n[0],i+"-"+n[0]);else for(var o=_.querySelectorAll("[df-"+i+"-"+n[0]+"]"),l=0;l<o.length;l++)o[l].value=n[1],o[l].isContentEditable&&(o[l].innerText=n[1])}))}(null,e[0],e[0]);else for(var n=_.querySelectorAll("[df-"+e[0]+"]"),i=0;i<n.length;i++)n[i].value=e[1],n[i].isContentEditable&&(n[i].innerText=e[1])})),h.appendChild(u),h.appendChild(_),h.appendChild(p),h.style.top=s+"px",h.style.left=i+"px",r.appendChild(h),this.precanvas.appendChild(r);var w={id:a,name:e,data:l,class:o,html:c,typenode:d,inputs:f,outputs:g,pos_x:i,pos_y:s};return this.drawflow.drawflow[this.module].data[a]=w,this.dispatch("nodeCreated",a),this.useuuid||this.nodeId++,a}addNodeImport(e,t){const n=document.createElement("div");n.classList.add("parent-node");const i=document.createElement("div");i.innerHTML="",i.setAttribute("id","node-"+e.id),i.classList.add("drawflow-node"),""!=e.class&&i.classList.add(...e.class.split(" "));const s=document.createElement("div");s.classList.add("inputs");const o=document.createElement("div");o.classList.add("outputs"),Object.keys(e.inputs).map((function(n,i){const o=document.createElement("div");o.classList.add("input"),o.classList.add(n),s.appendChild(o),Object.keys(e.inputs[n].connections).map((function(i,s){var o=document.createElementNS("http://www.w3.org/2000/svg","svg"),l=document.createElementNS("http://www.w3.org/2000/svg","path");l.classList.add("main-path"),l.setAttributeNS(null,"d",""),o.classList.add("connection"),o.classList.add("node_in_node-"+e.id),o.classList.add("node_out_node-"+e.inputs[n].connections[i].node),o.classList.add(e.inputs[n].connections[i].input),o.classList.add(n),o.appendChild(l),t.appendChild(o)}))}));for(var l=0;l<Object.keys(e.outputs).length;l++){const e=document.createElement("div");e.classList.add("output"),e.classList.add("output_"+(l+1)),o.appendChild(e)}const c=document.createElement("div");if(c.classList.add("drawflow_content_node"),!1===e.typenode)c.innerHTML=e.html;else if(!0===e.typenode)c.appendChild(this.noderegister[e.html].html.cloneNode(!0));else if(3===parseInt(this.render.version)){let t=this.render.h(this.noderegister[e.html].html,this.noderegister[e.html].props,this.noderegister[e.html].options);t.appContext=this.parent,this.render.render(t,c)}else{let t=new this.render({parent:this.parent,render:t=>t(this.noderegister[e.html].html,{props:this.noderegister[e.html].props}),...this.noderegister[e.html].options}).$mount();c.appendChild(t.$el)}Object.entries(e.data).forEach((function(t,n){if("object"==typeof t[1])!function t(n,i,s){if(null===n)n=e.data[i];else n=n[i];null!==n&&Object.entries(n).forEach((function(e,i){if("object"==typeof e[1])t(n,e[0],s+"-"+e[0]);else for(var o=c.querySelectorAll("[df-"+s+"-"+e[0]+"]"),l=0;l<o.length;l++)o[l].value=e[1],o[l].isContentEditable&&(o[l].innerText=e[1])}))}(null,t[0],t[0]);else for(var i=c.querySelectorAll("[df-"+t[0]+"]"),s=0;s<i.length;s++)i[s].value=t[1],i[s].isContentEditable&&(i[s].innerText=t[1])})),i.appendChild(s),i.appendChild(c),i.appendChild(o),i.style.top=e.pos_y+"px",i.style.left=e.pos_x+"px",n.appendChild(i),this.precanvas.appendChild(n)}addRerouteImport(e){const t=this.reroute_width,n=this.reroute_fix_curvature,i=this.container;Object.keys(e.outputs).map((function(s,o){Object.keys(e.outputs[s].connections).map((function(o,l){const c=e.outputs[s].connections[o].points;void 0!==c&&c.forEach((l,d)=>{const a=e.outputs[s].connections[o].node,r=e.outputs[s].connections[o].output,h=i.querySelector(".connection.node_in_node-"+a+".node_out_node-"+e.id+"."+s+"."+r);if(n&&0===d)for(var u=0;u<c.length;u++){var p=document.createElementNS("http://www.w3.org/2000/svg","path");p.classList.add("main-path"),p.setAttributeNS(null,"d",""),h.appendChild(p)}const f=document.createElementNS("http://www.w3.org/2000/svg","circle");f.classList.add("point");var m=l.pos_x,g=l.pos_y;f.setAttributeNS(null,"cx",m),f.setAttributeNS(null,"cy",g),f.setAttributeNS(null,"r",t),h.appendChild(f)})}))}))}updateNodeValue(e){for(var t=e.target.attributes,n=0;n<t.length;n++)if(t[n].nodeName.startsWith("df-")){for(var i=t[n].nodeName.slice(3).split("-"),s=this.drawflow.drawflow[this.module].data[e.target.closest(".drawflow_content_node").parentElement.id.slice(5)].data,o=0;o<i.length-1;o+=1)null==s[i[o]]&&(s[i[o]]={}),s=s[i[o]];s[i[i.length-1]]=e.target.value,e.target.isContentEditable&&(s[i[i.length-1]]=e.target.innerText),this.dispatch("nodeDataChanged",e.target.closest(".drawflow_content_node").parentElement.id.slice(5))}}updateNodeDataFromId(e,t){var n=this.getModuleFromNodeId(e);if(this.drawflow.drawflow[n].data[e].data=t,this.module===n){const n=this.container.querySelector("#node-"+e);Object.entries(t).forEach((function(e,i){if("object"==typeof e[1])!function e(i,s,o){if(null===i)i=t[s];else i=i[s];null!==i&&Object.entries(i).forEach((function(t,s){if("object"==typeof t[1])e(i,t[0],o+"-"+t[0]);else for(var l=n.querySelectorAll("[df-"+o+"-"+t[0]+"]"),c=0;c<l.length;c++)l[c].value=t[1],l[c].isContentEditable&&(l[c].innerText=t[1])}))}(null,e[0],e[0]);else for(var s=n.querySelectorAll("[df-"+e[0]+"]"),o=0;o<s.length;o++)s[o].value=e[1],s[o].isContentEditable&&(s[o].innerText=e[1])}))}}addNodeInput(e){var t=this.getModuleFromNodeId(e);const n=this.getNodeFromId(e),i=Object.keys(n.inputs).length;if(this.module===t){const t=document.createElement("div");t.classList.add("input"),t.classList.add("input_"+(i+1));this.container.querySelector("#node-"+e+" .inputs").appendChild(t),this.updateConnectionNodes("node-"+e)}this.drawflow.drawflow[t].data[e].inputs["input_"+(i+1)]={connections:[]}}addNodeOutput(e){var t=this.getModuleFromNodeId(e);const n=this.getNodeFromId(e),i=Object.keys(n.outputs).length;if(this.module===t){const t=document.createElement("div");t.classList.add("output"),t.classList.add("output_"+(i+1));this.container.querySelector("#node-"+e+" .outputs").appendChild(t),this.updateConnectionNodes("node-"+e)}this.drawflow.drawflow[t].data[e].outputs["output_"+(i+1)]={connections:[]}}removeNodeInput(e,t){var n=this.getModuleFromNodeId(e);const i=this.getNodeFromId(e);this.module===n&&this.container.querySelector("#node-"+e+" .inputs .input."+t).remove();const s=[];Object.keys(i.inputs[t].connections).map((function(n,o){const l=i.inputs[t].connections[o].node,c=i.inputs[t].connections[o].input;s.push({id_output:l,id:e,output_class:c,input_class:t})})),s.forEach((e,t)=>{this.removeSingleConnection(e.id_output,e.id,e.output_class,e.input_class)}),delete this.drawflow.drawflow[n].data[e].inputs[t];const o=[],l=this.drawflow.drawflow[n].data[e].inputs;Object.keys(l).map((function(e,t){o.push(l[e])})),this.drawflow.drawflow[n].data[e].inputs={};const c=t.slice(6);let d=[];if(o.forEach((t,i)=>{t.connections.forEach((e,t)=>{d.push(e)}),this.drawflow.drawflow[n].data[e].inputs["input_"+(i+1)]=t}),d=new Set(d.map(e=>JSON.stringify(e))),d=Array.from(d).map(e=>JSON.parse(e)),this.module===n){this.container.querySelectorAll("#node-"+e+" .inputs .input").forEach((e,t)=>{const n=e.classList[1].slice(6);parseInt(c)<parseInt(n)&&(e.classList.remove("input_"+n),e.classList.add("input_"+(n-1)))})}d.forEach((t,i)=>{this.drawflow.drawflow[n].data[t.node].outputs[t.input].connections.forEach((i,s)=>{if(i.node==e){const o=i.output.slice(6);if(parseInt(c)<parseInt(o)){if(this.module===n){const n=this.container.querySelector(".connection.node_in_node-"+e+".node_out_node-"+t.node+"."+t.input+".input_"+o);n.classList.remove("input_"+o),n.classList.add("input_"+(o-1))}i.points?this.drawflow.drawflow[n].data[t.node].outputs[t.input].connections[s]={node:i.node,output:"input_"+(o-1),points:i.points}:this.drawflow.drawflow[n].data[t.node].outputs[t.input].connections[s]={node:i.node,output:"input_"+(o-1)}}}})}),this.updateConnectionNodes("node-"+e)}removeNodeOutput(e,t){var n=this.getModuleFromNodeId(e);const i=this.getNodeFromId(e);this.module===n&&this.container.querySelector("#node-"+e+" .outputs .output."+t).remove();const s=[];Object.keys(i.outputs[t].connections).map((function(n,o){const l=i.outputs[t].connections[o].node,c=i.outputs[t].connections[o].output;s.push({id:e,id_input:l,output_class:t,input_class:c})})),s.forEach((e,t)=>{this.removeSingleConnection(e.id,e.id_input,e.output_class,e.input_class)}),delete this.drawflow.drawflow[n].data[e].outputs[t];const o=[],l=this.drawflow.drawflow[n].data[e].outputs;Object.keys(l).map((function(e,t){o.push(l[e])})),this.drawflow.drawflow[n].data[e].outputs={};const c=t.slice(7);let d=[];if(o.forEach((t,i)=>{t.connections.forEach((e,t)=>{d.push({node:e.node,output:e.output})}),this.drawflow.drawflow[n].data[e].outputs["output_"+(i+1)]=t}),d=new Set(d.map(e=>JSON.stringify(e))),d=Array.from(d).map(e=>JSON.parse(e)),this.module===n){this.container.querySelectorAll("#node-"+e+" .outputs .output").forEach((e,t)=>{const n=e.classList[1].slice(7);parseInt(c)<parseInt(n)&&(e.classList.remove("output_"+n),e.classList.add("output_"+(n-1)))})}d.forEach((t,i)=>{this.drawflow.drawflow[n].data[t.node].inputs[t.output].connections.forEach((i,s)=>{if(i.node==e){const o=i.input.slice(7);if(parseInt(c)<parseInt(o)){if(this.module===n){const n=this.container.querySelector(".connection.node_in_node-"+t.node+".node_out_node-"+e+".output_"+o+"."+t.output);n.classList.remove("output_"+o),n.classList.remove(t.output),n.classList.add("output_"+(o-1)),n.classList.add(t.output)}i.points?this.drawflow.drawflow[n].data[t.node].inputs[t.output].connections[s]={node:i.node,input:"output_"+(o-1),points:i.points}:this.drawflow.drawflow[n].data[t.node].inputs[t.output].connections[s]={node:i.node,input:"output_"+(o-1)}}}})}),this.updateConnectionNodes("node-"+e)}removeNodeId(e){this.removeConnectionNodeId(e);var t=this.getModuleFromNodeId(e.slice(5));this.module===t&&this.container.querySelector("#"+e).remove(),delete this.drawflow.drawflow[t].data[e.slice(5)],this.dispatch("nodeRemoved",e.slice(5))}removeConnection(){if(null!=this.connection_selected){var e=this.connection_selected.parentElement.classList;this.connection_selected.parentElement.remove();var t=this.drawflow.drawflow[this.module].data[e[2].slice(14)].outputs[e[3]].connections.findIndex((function(t,n){return t.node===e[1].slice(13)&&t.output===e[4]}));this.drawflow.drawflow[this.module].data[e[2].slice(14)].outputs[e[3]].connections.splice(t,1);var n=this.drawflow.drawflow[this.module].data[e[1].slice(13)].inputs[e[4]].connections.findIndex((function(t,n){return t.node===e[2].slice(14)&&t.input===e[3]}));this.drawflow.drawflow[this.module].data[e[1].slice(13)].inputs[e[4]].connections.splice(n,1),this.dispatch("connectionRemoved",{output_id:e[2].slice(14),input_id:e[1].slice(13),output_class:e[3],input_class:e[4]}),this.connection_selected=null}}removeSingleConnection(e,t,n,i){var s=this.getModuleFromNodeId(e);if(s===this.getModuleFromNodeId(t)){if(this.drawflow.drawflow[s].data[e].outputs[n].connections.findIndex((function(e,n){return e.node==t&&e.output===i}))>-1){this.module===s&&this.container.querySelector(".connection.node_in_node-"+t+".node_out_node-"+e+"."+n+"."+i).remove();var o=this.drawflow.drawflow[s].data[e].outputs[n].connections.findIndex((function(e,n){return e.node==t&&e.output===i}));this.drawflow.drawflow[s].data[e].outputs[n].connections.splice(o,1);var l=this.drawflow.drawflow[s].data[t].inputs[i].connections.findIndex((function(t,i){return t.node==e&&t.input===n}));return this.drawflow.drawflow[s].data[t].inputs[i].connections.splice(l,1),this.dispatch("connectionRemoved",{output_id:e,input_id:t,output_class:n,input_class:i}),!0}return!1}return!1}removeConnectionNodeId(e){const t="node_in_"+e,n="node_out_"+e,i=this.container.querySelectorAll("."+n);for(var s=i.length-1;s>=0;s--){var o=i[s].classList,l=this.drawflow.drawflow[this.module].data[o[1].slice(13)].inputs[o[4]].connections.findIndex((function(e,t){return e.node===o[2].slice(14)&&e.input===o[3]}));this.drawflow.drawflow[this.module].data[o[1].slice(13)].inputs[o[4]].connections.splice(l,1);var c=this.drawflow.drawflow[this.module].data[o[2].slice(14)].outputs[o[3]].connections.findIndex((function(e,t){return e.node===o[1].slice(13)&&e.output===o[4]}));this.drawflow.drawflow[this.module].data[o[2].slice(14)].outputs[o[3]].connections.splice(c,1),i[s].remove(),this.dispatch("connectionRemoved",{output_id:o[2].slice(14),input_id:o[1].slice(13),output_class:o[3],input_class:o[4]})}const d=this.container.querySelectorAll("."+t);for(s=d.length-1;s>=0;s--){o=d[s].classList,c=this.drawflow.drawflow[this.module].data[o[2].slice(14)].outputs[o[3]].connections.findIndex((function(e,t){return e.node===o[1].slice(13)&&e.output===o[4]}));this.drawflow.drawflow[this.module].data[o[2].slice(14)].outputs[o[3]].connections.splice(c,1);l=this.drawflow.drawflow[this.module].data[o[1].slice(13)].inputs[o[4]].connections.findIndex((function(e,t){return e.node===o[2].slice(14)&&e.input===o[3]}));this.drawflow.drawflow[this.module].data[o[1].slice(13)].inputs[o[4]].connections.splice(l,1),d[s].remove(),this.dispatch("connectionRemoved",{output_id:o[2].slice(14),input_id:o[1].slice(13),output_class:o[3],input_class:o[4]})}}getModuleFromNodeId(e){var t;const n=this.drawflow.drawflow;return Object.keys(n).map((function(i,s){Object.keys(n[i].data).map((function(n,s){n==e&&(t=i)}))})),t}addModule(e){this.drawflow.drawflow[e]={data:{}},this.dispatch("moduleCreated",e)}changeModule(e){this.dispatch("moduleChanged",e),this.module=e,this.precanvas.innerHTML="",this.canvas_x=0,this.canvas_y=0,this.pos_x=0,this.pos_y=0,this.mouse_x=0,this.mouse_y=0,this.zoom=1,this.zoom_last_value=1,this.precanvas.style.transform="",this.import(this.drawflow,!1)}removeModule(e){this.module===e&&this.changeModule("Home"),delete this.drawflow.drawflow[e],this.dispatch("moduleRemoved",e)}clearModuleSelected(){this.precanvas.innerHTML="",this.drawflow.drawflow[this.module]={data:{}}}clear(){this.precanvas.innerHTML="",this.drawflow={drawflow:{Home:{data:{}}}}}export(){const e=JSON.parse(JSON.stringify(this.drawflow));return this.dispatch("export",e),e}import(e,t=!0){this.clear(),this.drawflow=JSON.parse(JSON.stringify(e)),this.load(),t&&this.dispatch("import","import")}on(e,t){return"function"!=typeof t?(console.error("The listener callback must be a function, the given type is "+typeof t),!1):"string"!=typeof e?(console.error("The event name must be a string, the given type is "+typeof e),!1):(void 0===this.events[e]&&(this.events[e]={listeners:[]}),void this.events[e].listeners.push(t))}removeListener(e,t){if(!this.events[e])return!1;const n=this.events[e].listeners,i=n.indexOf(t);i>-1&&n.splice(i,1)}dispatch(e,t){if(void 0===this.events[e])return!1;this.events[e].listeners.forEach(e=>{e(t)})}getUuid(){for(var e=[],t=0;t<36;t++)e[t]="0123456789abcdef".substr(Math.floor(16*Math.random()),1);return e[14]="4",e[19]="0123456789abcdef".substr(3&e[19]|8,1),e[8]=e[13]=e[18]=e[23]="-",e.join("")}}}]).default}));</script>
<style>
:root {
  --bg: #111110;
  --surface: #1a1a18;
  --surface2: #222220;
  --border: #333330;
  --border-hi: #4a4a44;
  --text: #e8e4d9;
  --text-dim: #999688;
  --text-faint: #666460;
  --cyan: #3ec9d1;
  --cyan-dim: rgba(62,201,209,0.12);
  --amber: #e5a430;
  --amber-dim: rgba(229,164,48,0.12);
  --green: #5ccc5c;
  --green-dim: rgba(92,204,92,0.10);
  --red: #e55050;
  --red-dim: rgba(229,80,80,0.10);
  --blue: #5a9fd4;
  --blue-dim: rgba(90,159,212,0.10);
  --purple: #b07acc;
  --purple-dim: rgba(176,122,204,0.12);
  --pink: #d4699e;
  --pink-dim: rgba(212,105,158,0.12);
  --mono: 'IBM Plex Mono', monospace;
  --display: 'Fraunces', serif;
  --body: 'Outfit', sans-serif;
  --radius: 8px;
}
* { margin:0; padding:0; box-sizing:border-box; }
body { background:var(--bg); color:var(--text); font-family:var(--body); overflow:hidden; height:100vh; }

/* Layout */
.app { display:flex; height:100vh; }

/* Sidebar */
.sidebar {
  width:220px; flex-shrink:0; background:var(--surface);
  border-right:1px solid var(--border); display:flex; flex-direction:column;
  overflow:hidden;
}
.sidebar-scroll {
  flex:1; overflow-y:auto;
  scrollbar-width:thin; scrollbar-color:var(--border) transparent;
}
.sidebar-header { padding:1rem; border-bottom:1px solid var(--border); text-align:center; }
.sidebar-header h1 { font-family:var(--display); font-size:1.25rem; font-weight:900; letter-spacing:-0.02em; }
.sidebar-header h1 .accent { color:var(--cyan); }
.sidebar-header p { font-size:0.72rem; color:var(--text-faint); margin-top:0.2rem; }

.sidebar-section { padding:0.6rem 0.8rem 0.3rem; }

.drag-item {
  display:flex; align-items:center; gap:0.5rem;
  padding:0.45rem 0.7rem; margin-bottom:0.25rem;
  background:var(--bg); border:1px solid var(--border); border-radius:6px;
  cursor:grab; font-size:0.72rem; color:var(--text-dim);
  transition:all 0.15s; user-select:none;
}
.drag-item:hover { border-color:var(--border-hi); color:var(--text); }
.drag-item:active { cursor:grabbing; }
.drag-icon {
  width:20px; height:20px; border-radius:4px; display:flex;
  align-items:center; justify-content:center; font-size:0.65rem;
  flex-shrink:0; font-weight:600;
}
.drag-icon.trigger { background:var(--cyan-dim); color:var(--cyan); }
.drag-icon.api { background:var(--green-dim); color:var(--green); }
.drag-icon.transform { background:var(--amber-dim); color:var(--amber); }
.drag-icon.llm { background:var(--purple-dim); color:var(--purple); }
.drag-icon.output { background:var(--blue-dim); color:var(--blue); }
.drag-icon.compose { background:var(--pink-dim); color:var(--pink); }

/* Toolbar */
.toolbar {
  display:flex; align-items:center; gap:0.4rem;
  padding:0.5rem 0.6rem; border-top:1px solid var(--border);
  background:var(--surface2);
}
.toolbar .btn {
  flex:1; display:inline-flex; align-items:center; justify-content:center; gap:0.3rem;
  padding:0.4rem 0; border:none; border-radius:5px;
  font-family:var(--body); font-weight:600; font-size:0.68rem;
  cursor:pointer; transition:all 0.15s; white-space:nowrap;
}
.toolbar .btn:hover { filter:brightness(1.15); }
.toolbar .btn:active { transform:scale(0.96); }
.btn-run { background:var(--green); color:#111; }
.btn-clear { background:var(--surface); color:var(--text-dim); border:1px solid var(--border) !important; }
.btn-example { background:var(--cyan-dim); color:var(--cyan); border:1px solid rgba(62,201,209,0.25) !important; }
.btn-save { background:var(--green-dim, rgba(76,175,80,0.12)); color:var(--green); border:1px solid rgba(76,175,80,0.25) !important; }
.btn-export { background:var(--surface); color:var(--text-dim); border:1px solid var(--border) !important; }
.btn-import { background:var(--surface); color:var(--text-dim); border:1px solid var(--border) !important; }
.toolbar-row { display:flex; gap:0.4rem; width:100%; }
.toolbar-divider { width:100%; height:1px; background:var(--border); margin:0.15rem 0; }

/* Canvas area */
.canvas-area { flex:1; display:flex; flex-direction:column; position:relative; }

/* Tab bar */
.tab-bar {
  display:flex; align-items:stretch; background:var(--surface);
  border-bottom:1px solid var(--border); min-height:32px; flex-shrink:0;
  overflow-x:auto; scrollbar-width:none;
}
.tab-bar::-webkit-scrollbar { display:none; }
.tab {
  display:flex; align-items:center; padding:0 1rem; height:32px;
  font-family:var(--mono); font-size:0.68rem; color:var(--text-dim);
  border-right:1px solid var(--border); cursor:pointer;
  transition:all 0.15s; white-space:nowrap; user-select:none;
  position:relative;
}
.tab:hover { color:var(--text); background:var(--surface2); }
.tab.active {
  color:var(--cyan); background:var(--bg);
  border-bottom:2px solid var(--cyan); margin-bottom:-1px;
}
.tab-add {
  display:flex; align-items:center; justify-content:center;
  width:32px; font-size:1rem; color:var(--text-faint);
  cursor:pointer; transition:all 0.15s;
}
.tab-add:hover { color:var(--cyan); background:var(--surface2); }
.tab-ctx {
  position:absolute; background:var(--surface2); border:1px solid var(--border);
  border-radius:6px; padding:0.25rem 0; z-index:100; min-width:140px;
  box-shadow:0 4px 16px rgba(0,0,0,0.4); font-family:var(--body);
}
.tab-ctx-item {
  padding:0.4rem 0.8rem; font-size:0.72rem; color:var(--text-dim);
  cursor:pointer; transition:background 0.1s;
}
.tab-ctx-item:hover { background:var(--border); color:var(--text); }
.tab-ctx-item.danger { color:var(--red); }
.tab-ctx-item.danger:hover { background:var(--red-dim); }

/* Drawflow canvas */
#drawflow {
  flex:1; background:var(--bg);
  background-image: radial-gradient(circle, var(--border) 0.8px, transparent 0.8px);
  background-size:24px 24px;
}

/* Drawflow node overrides */
.drawflow .drawflow-node {
  background:var(--surface) !important;
  border:1.5px solid var(--border) !important;
  border-radius:8px !important;
  color:var(--text) !important;
  min-width:180px;
  width:auto !important;
  font-family:var(--body);
  box-shadow:0 2px 12px rgba(0,0,0,0.3) !important;
  position:absolute;
  /* Override Drawflow's align-items:center so content stretches vertically */
  align-items:stretch !important;
  transition:border-color 0.15s, box-shadow 0.15s;
}
.drawflow .drawflow-node.selected {
  border-color:var(--cyan) !important;
  border-width:2px !important;
  box-shadow:0 0 0 3px rgba(62,201,209,0.3), 0 0 24px rgba(62,201,209,0.2), 0 2px 12px rgba(0,0,0,0.3) !important;
}
.drawflow .drawflow-node.selected .node-header {
  background:rgba(62,201,209,0.15);
  border-bottom-color:rgba(62,201,209,0.3);
}
.drawflow .drawflow-node.selected .node-header .node-title {
  color:var(--cyan);
}
/* Selected connection */
.drawflow .connection .main-path.selected {
  stroke:var(--cyan) !important; stroke-width:3px !important;
  filter:drop-shadow(0 0 4px rgba(62,201,209,0.4));
}
/* Content column fills the node vertically */
.drawflow .drawflow-node .drawflow_content_node {
  padding:0 !important;
  display:flex !important; flex-direction:column !important;
  min-height:0 !important; /* allow shrinking */
}

/* Node internals â€” vertical box layout */
.node-box {
  display:flex; flex-direction:column;
  flex:1; min-height:0; /* stretch to fill content_node */
}
.node-header {
  display:flex; align-items:center; gap:0.4rem;
  padding:0.5rem 0.65rem; border-bottom:1px solid var(--border);
  font-size:0.72rem; font-weight:600; cursor:grab;
  flex-shrink:0; /* fixed height â€” never compresses */
  transition:background 0.15s;
}
.node-header .node-icon {
  width:18px; height:18px; border-radius:3px; display:flex;
  align-items:center; justify-content:center; font-size:0.6rem; flex-shrink:0;
}
.node-header .node-title { font-family:var(--mono); font-size:0.7rem; }
/* Body is the "spring" â€” absorbs all extra vertical space */
.node-body {
  padding:0.5rem 0.65rem;
  flex:1; display:flex; flex-direction:column; min-height:0;
}
.node-body label {
  display:block; font-family:var(--mono); font-size:0.6rem;
  color:var(--text-faint); text-transform:uppercase; letter-spacing:0.04em;
  margin-bottom:0.2rem; margin-top:0.35rem;
  flex-shrink:0; /* fixed â€” never compresses */
}
.node-body label:first-child { margin-top:0; }
.node-body input, .node-body select, .node-body textarea {
  width:100%; background:var(--bg); border:1px solid var(--border);
  color:var(--text); padding:0.3rem 0.45rem; border-radius:4px;
  font-family:var(--mono); font-size:0.68rem; outline:none;
  box-sizing:border-box;
}
.node-body input, .node-body select { flex-shrink:0; } /* inputs: fixed height */
.node-body input:focus, .node-body select:focus, .node-body textarea:focus {
  border-color:var(--cyan);
}
/* Textareas are the inner spring â€” absorb remaining vertical space */
.node-body textarea {
  resize:none; width:100%; box-sizing:border-box; min-height:2.5rem;
  font-family:var(--body); font-size:0.72rem; line-height:1.4;
  scrollbar-width:thin; scrollbar-color:var(--border) transparent;
  flex:1 1 auto; /* SPRING: grow to fill, shrink if needed */
}
.node-body textarea::-webkit-scrollbar { width:5px; }
.node-body textarea::-webkit-scrollbar-track { background:transparent; }
.node-body textarea::-webkit-scrollbar-thumb { background:var(--border); border-radius:3px; }
.node-body textarea.code-area {
  font-family:var(--mono) !important; font-size:0.65rem; line-height:1.5;
  min-height:4rem; background:#0d0d0c; tab-size:2;
}
.node-body .node-info { font-size:0.65rem; color:var(--text-faint); padding:0.15rem 0; flex-shrink:0; }
.node-run-btn {
  display:block; width:100%; padding:0.4rem; border:none; border-radius:4px;
  background:var(--green); color:#111; font-family:var(--mono); font-size:0.72rem;
  font-weight:600; cursor:pointer; transition:all 0.15s; flex-shrink:0;
}
.node-run-btn:hover { filter:brightness(1.15); }
.node-run-btn:active { transform:scale(0.97); }
.node-img-container { margin-top:0.3rem; flex-shrink:0; }
.node-img-container img {
  max-width:200px; max-height:150px; border-radius:4px; border:1px solid var(--border); display:block;
}

/* Toggle switch */
.toggle { position:relative; display:inline-block; width:36px; height:20px; vertical-align:middle; flex-shrink:0; }
.toggle input { opacity:0; width:0; height:0; position:absolute; }
.toggle-track {
  position:absolute; inset:0; background:var(--border); border-radius:10px;
  cursor:pointer; transition:0.2s;
}
.toggle-track::before {
  content:''; position:absolute; width:16px; height:16px; left:2px; top:2px;
  background:var(--text-dim); border-radius:50%; transition:0.2s;
}
.toggle input:checked + .toggle-track { background:var(--green); }
.toggle input:checked + .toggle-track::before { transform:translateX(16px); background:#fff; }

/* If node output labels */
.output-labels { display:flex; flex-direction:column; gap:0.25rem; margin-top:0.3rem; flex-shrink:0; }
.output-label { font-family:var(--mono); font-size:0.6rem; text-align:right; }
.output-label.true-label { color:var(--green); }
.output-label.false-label { color:var(--red); }

/* Connection line colors */
.drawflow .connection .main-path { stroke:var(--border-hi) !important; stroke-width:2px !important; }
.drawflow .connection .main-path:hover { stroke:var(--cyan) !important; }

/* Port styling */
.drawflow .drawflow-node .input, .drawflow .drawflow-node .output {
  width:12px !important; height:12px !important;
  border:2px solid var(--border-hi) !important;
  background:var(--bg) !important;
}
.drawflow .drawflow-node .input {
  left:-23px !important; top:2px !important;
}
.drawflow .drawflow-node .output {
  right:-7px !important; top:2px !important;
}
.drawflow .drawflow-node .input:hover, .drawflow .drawflow-node .output:hover {
  background:var(--cyan) !important; border-color:var(--cyan) !important;
}

/* Node type colors */
.drawflow .drawflow-node.node-trigger { border-color:var(--cyan) !important; }
.drawflow .drawflow-node.node-trigger .node-header { background:var(--cyan-dim); }
.drawflow .drawflow-node.node-trigger .node-icon { background:var(--cyan); color:#111; }

.drawflow .drawflow-node.node-api { border-color:var(--green) !important; }
.drawflow .drawflow-node.node-api .node-header { background:var(--green-dim); }
.drawflow .drawflow-node.node-api .node-icon { background:var(--green); color:#111; }

.drawflow .drawflow-node.node-transform { border-color:var(--amber) !important; }
.drawflow .drawflow-node.node-transform .node-header { background:var(--amber-dim); }
.drawflow .drawflow-node.node-transform .node-icon { background:var(--amber); color:#111; }

.drawflow .drawflow-node.node-llm { border-color:var(--purple) !important; }
.drawflow .drawflow-node.node-llm .node-header { background:var(--purple-dim); }
.drawflow .drawflow-node.node-llm .node-icon { background:var(--purple); color:#111; }

.drawflow .drawflow-node.node-output { border-color:var(--blue) !important; }
.drawflow .drawflow-node.node-output .node-header { background:var(--blue-dim); }
.drawflow .drawflow-node.node-output .node-icon { background:var(--blue); color:#111; }

.drawflow .drawflow-node.node-compose { border-color:var(--pink) !important; }
.drawflow .drawflow-node.node-compose .node-header { background:var(--pink-dim); }
.drawflow .drawflow-node.node-compose .node-icon { background:var(--pink); color:#111; }

/* Delete button */
.drawflow-delete {
  display:flex !important; align-items:center !important; justify-content:center !important;
  width:28px !important; height:28px !important;
  background:var(--surface) !important; color:var(--red) !important;
  border:1.5px solid var(--red) !important; border-radius:50% !important;
  font-family:var(--mono) !important; font-size:0.75rem !important;
  font-weight:700 !important; line-height:1 !important;
  padding:0 !important; cursor:pointer !important; z-index:4 !important;
}
.drawflow-delete:hover { background:var(--red) !important; color:#fff !important; }

/* Running/done/error states */
.drawflow .drawflow-node.running {
  box-shadow:0 0 0 2px var(--green), 0 0 20px rgba(92,204,92,0.2) !important;
}
.drawflow .drawflow-node.done .node-header::after {
  content:'âœ“'; position:absolute; right:0.5rem; top:0.5rem; color:var(--green); font-size:0.7rem;
}
.drawflow .drawflow-node.error {
  box-shadow:0 0 0 2px var(--red), 0 0 20px rgba(229,80,80,0.2) !important;
}
@keyframes pulse-border {
  0%,100% { box-shadow:0 0 0 2px var(--cyan), 0 0 8px rgba(62,201,209,0.15) !important; }
  50% { box-shadow:0 0 0 2px var(--cyan), 0 0 20px rgba(62,201,209,0.3) !important; }
}
.drawflow .drawflow-node.active-trigger { animation:pulse-border 2s ease-in-out infinite; }

/* Zoom indicator */
.zoom-indicator {
  position:absolute; bottom:12px; right:12px; z-index:10;
  display:flex; align-items:center; gap:0;
  background:var(--surface); border:1px solid var(--border);
  border-radius:6px; overflow:hidden;
  box-shadow:0 2px 8px rgba(0,0,0,0.3);
  opacity:0.7; transition:opacity 0.15s;
}
.zoom-indicator:hover { opacity:1; }
.zoom-btn, .zoom-level {
  border:none; background:none; color:var(--text-dim);
  font-family:var(--mono); font-size:0.7rem; cursor:pointer;
  padding:0.35rem 0.5rem; transition:color 0.1s, background 0.1s;
}
.zoom-btn:hover { color:var(--text); background:var(--bg); }
.zoom-level { border-left:1px solid var(--border); border-right:1px solid var(--border);
  min-width:3.2rem; text-align:center; }
.zoom-level:hover { color:var(--cyan); background:var(--bg); }

/* Node resize handle */
.node-resize {
  position:absolute; bottom:0; right:0; width:16px; height:16px;
  cursor:nwse-resize; z-index:5; opacity:0;
  transition:opacity 0.15s;
}
.node-resize::after {
  content:''; position:absolute; bottom:3px; right:3px;
  width:0; height:0;
  border-style:solid; border-width:0 0 8px 8px;
  border-color:transparent transparent var(--border-hi) transparent;
  transition:border-color 0.15s;
}
.drawflow-node:hover .node-resize { opacity:0.6; }
.drawflow-node:hover .node-resize:hover { opacity:1; }
.node-resize:hover::after { border-color:transparent transparent var(--cyan) transparent; }
.drawflow-node.resizing {
  outline:1px solid var(--cyan) !important;
  outline-offset:2px;
}
.drawflow-node.resizing .node-resize { opacity:1; }
.drawflow-node.resizing .node-resize::after {
  border-color:transparent transparent var(--cyan) transparent;
}

/* Result strip */
.node-result {
  padding:0.35rem 0.65rem; border-top:1px solid var(--border);
  font-family:var(--mono); font-size:0.62rem; color:var(--text-dim);
  max-height:3.2em; overflow:hidden; word-break:break-all;
  background:rgba(0,0,0,0.15); flex-shrink:0;
  cursor:pointer; transition:max-height 0.2s ease;
  white-space:pre-wrap; line-height:1.5;
  position:relative;
}
.node-result.expanded {
  max-height:400px; overflow:auto;
  scrollbar-width:thin; scrollbar-color:var(--border) transparent;
}
.node-result:not(.expanded)::after {
  content:'â‹¯ click to expand'; display:block;
  font-size:0.55rem; color:var(--text-faint); opacity:0.7;
  margin-top:0.15rem;
}
.node-result.expanded::after {
  content:'click to collapse'; display:block;
  font-size:0.55rem; color:var(--text-faint); opacity:0.7;
  margin-top:0.15rem;
}
.node-result.ok { color:var(--green); }
.node-result.err { color:var(--red); }

/* Log panel */
.log-panel {
  height:180px; flex-shrink:0; background:var(--surface);
  border-top:1px solid var(--border); display:flex; flex-direction:column;
  position:relative; min-height:60px; max-height:70vh;
}
.log-resize-handle { position:absolute; top:-4px; left:0; right:0; height:8px; cursor:ns-resize; z-index:10; }
.log-resize-handle::after {
  content:''; display:block; width:40px; height:3px;
  background:var(--border-hi); border-radius:2px; margin:3px auto 0; transition:background 0.15s;
}
.log-resize-handle:hover::after { background:var(--cyan); }
.log-header {
  display:flex; align-items:center; padding:0.4rem 0.8rem;
  border-bottom:1px solid var(--border); background:var(--surface2);
  font-family:var(--mono); font-size:0.68rem; color:var(--text-dim); gap:0.5rem;
}
.log-header .spacer { flex:1; }
.log-body {
  flex:1; overflow-y:auto; padding:0.3rem; font-size:0.75rem;
  scrollbar-width:thin; scrollbar-color:var(--border) transparent;
}
.log-entry { padding:0.3rem 0.5rem; border-bottom:1px solid var(--border); line-height:1.5; animation:fadeIn 0.2s; }
.log-entry:last-child { border-bottom:none; }
@keyframes fadeIn { from{opacity:0;} to{opacity:1;} }
.log-time { font-family:var(--mono); font-size:0.62rem; color:var(--text-faint); margin-right:0.4rem; }
.log-tag { font-family:var(--mono); font-size:0.62rem; padding:0.05rem 0.3rem; border-radius:2px; margin-right:0.3rem; }
.log-tag.run { background:var(--green-dim); color:var(--green); }
.log-tag.data { background:var(--cyan-dim); color:var(--cyan); }
.log-tag.err { background:var(--red-dim); color:var(--red); }
.log-tag.info { background:var(--amber-dim); color:var(--amber); }
.log-text { color:var(--text-dim); }
.log-empty { text-align:center; padding:1.5rem; color:var(--text-faint); font-style:italic; }
.log-toggle {
  font-family:var(--mono); font-size:0.62rem; color:var(--cyan);
  cursor:pointer; margin-left:0.4rem; padding:0.05rem 0.3rem;
  border-radius:2px; background:var(--cyan-dim);
}
.log-detail {
  display:none; margin-top:0.3rem; font-family:var(--mono); font-size:0.62rem;
  background:var(--bg); border:1px solid var(--border); border-radius:4px;
  padding:0.4rem; max-height:120px; overflow:auto; white-space:pre-wrap; word-break:break-all;
  color:var(--text-faint); line-height:1.5;
}
.log-detail.show { display:block; }
.log-tab-content { display:none !important; }
.log-tab-content.active { display:block !important; flex:1; overflow-y:auto; }

/* Log tabs */
.log-tabs { display:flex; gap:0; }
.log-tab {
  padding:0.25rem 0.7rem; cursor:pointer; font-size:0.68rem;
  color:var(--text-faint); border-bottom:2px solid transparent;
  transition:all 0.15s; user-select:none;
}
.log-tab:hover { color:var(--text-dim); }
.log-tab.active { color:var(--cyan); border-bottom-color:var(--cyan); }

/* Variable inspector */
.var-table { width:100%; border-collapse:collapse; }
.var-table th {
  text-align:left; font-family:var(--mono); font-size:0.62rem;
  color:var(--text-faint); text-transform:uppercase; letter-spacing:0.04em;
  padding:0.4rem 0.6rem; border-bottom:1px solid var(--border);
}
.var-table td {
  padding:0.35rem 0.6rem; border-bottom:1px solid var(--border);
  font-family:var(--mono); font-size:0.68rem; vertical-align:top;
}
.var-table td:first-child { color:var(--amber); white-space:nowrap; }
.var-table td:nth-child(2) { color:var(--text-faint); white-space:nowrap; }
.var-table td:last-child {
  color:var(--text-dim); word-break:break-all; max-width:300px;
  overflow:hidden; text-overflow:ellipsis;
}

/* Config panel */
.config-panel { padding:0.5rem; }
.config-hint {
  font-size:0.68rem; color:var(--text-faint); margin-bottom:0.6rem;
  line-height:1.5;
}
.config-hint code {
  font-family:var(--mono); background:var(--bg); padding:0.1rem 0.3rem;
  border-radius:3px; color:var(--amber);
}
.config-row {
  display:flex; gap:0.4rem; margin-bottom:0.35rem; align-items:center;
}
.config-row input {
  background:var(--bg); border:1px solid var(--border); color:var(--text);
  padding:0.3rem 0.5rem; border-radius:4px; font-family:var(--mono);
  font-size:0.7rem; outline:none;
}
.config-row input:focus { border-color:var(--cyan); }
.config-row .config-key { width:120px; }
.config-row .config-val { flex:1; }
.config-row .config-secret { flex:1; }
.config-del {
  width:22px; height:22px; border:1px solid var(--border); border-radius:4px;
  background:var(--surface); color:var(--text-faint); cursor:pointer;
  display:flex; align-items:center; justify-content:center; font-size:0.7rem;
  flex-shrink:0; transition:all 0.15s;
}
.config-del:hover { border-color:var(--red); color:var(--red); }
.config-add-btn {
  background:var(--surface2); border:1px solid var(--border); color:var(--text-dim);
  padding:0.3rem 0.8rem; border-radius:4px; font-family:var(--mono);
  font-size:0.68rem; cursor:pointer; transition:all 0.15s; margin-top:0.2rem;
}
.config-add-btn:hover { border-color:var(--cyan); color:var(--cyan); }
.config-eye {
  width:22px; height:22px; border:1px solid var(--border); border-radius:4px;
  background:var(--surface); color:var(--text-faint); cursor:pointer;
  display:flex; align-items:center; justify-content:center; font-size:0.65rem;
  flex-shrink:0; transition:all 0.15s;
}
.config-eye:hover { border-color:var(--cyan); color:var(--cyan); }

/* Example gallery modal */
.example-overlay {
  position:fixed; inset:0; z-index:210;
  background:rgba(0,0,0,0.7); display:flex;
  align-items:center; justify-content:center;
  opacity:0; transition:opacity 0.2s; pointer-events:none;
}
.example-overlay.show { opacity:1; pointer-events:all; }
.example-modal {
  background:var(--surface); border:1px solid var(--border);
  border-radius:12px; max-width:560px; width:92%;
  max-height:80vh; display:flex; flex-direction:column;
  box-shadow:0 16px 48px rgba(0,0,0,0.5);
}
.example-header {
  display:flex; align-items:center; justify-content:space-between;
  padding:1rem 1.2rem; border-bottom:1px solid var(--border);
}
.example-header h3 { font-family:var(--display); font-size:1rem; font-weight:700; margin:0; }
.example-close {
  width:28px; height:28px; border:1px solid var(--border); border-radius:6px;
  background:var(--surface2); color:var(--text-faint); cursor:pointer;
  display:flex; align-items:center; justify-content:center; font-size:0.8rem;
  transition:all 0.15s;
}
.example-close:hover { border-color:var(--text-dim); color:var(--text); }
.example-list { overflow-y:auto; padding:0.6rem; }
.example-card {
  display:flex; gap:0.8rem; padding:0.7rem 0.8rem; border-radius:8px;
  border:1px solid var(--border); background:var(--surface2);
  margin-bottom:0.4rem; cursor:pointer; transition:all 0.15s;
  align-items:flex-start;
}
.example-card:hover { border-color:var(--cyan); background:var(--cyan-dim); }
.example-card:active { transform:scale(0.99); }
.example-card-icon { font-size:1.5rem; flex-shrink:0; line-height:1; margin-top:0.1rem; }
.example-card-info { flex:1; min-width:0; }
.example-card-name {
  font-family:var(--body); font-weight:700; font-size:0.82rem;
  color:var(--text); margin-bottom:0.15rem;
}
.example-card-desc {
  font-size:0.72rem; color:var(--text-dim); line-height:1.5;
}
.example-card-tags {
  display:flex; gap:0.3rem; margin-top:0.3rem; flex-wrap:wrap;
}
.example-tag {
  font-family:var(--mono); font-size:0.55rem; padding:0.1rem 0.4rem;
  border-radius:3px; background:var(--bg); color:var(--text-faint);
}

/* Splash overlay */
.splash {
  position:absolute; inset:0; z-index:25;
  display:flex; align-items:center; justify-content:center;
  background:radial-gradient(ellipse at center, rgba(26,25,22,0.95) 0%, rgba(26,25,22,0.99) 100%);
  transition:opacity 0.4s;
}
.splash.hidden { opacity:0; pointer-events:none; }
.splash-card {
  text-align:center; max-width:520px; width:90%; padding:2rem 2rem;
}
.splash-icon {
  font-size:2.8rem; margin-bottom:0.8rem;
  filter:drop-shadow(0 0 12px rgba(62,201,209,0.3));
}
.splash-title {
  font-family:var(--display); font-size:1.8rem; font-weight:800;
  margin-bottom:0.3rem;
}
.splash-title .accent { color:var(--cyan); }
.splash-sub {
  font-family:var(--mono); font-size:0.72rem; color:var(--text-faint);
  letter-spacing:0.04em; margin-bottom:1.2rem;
}
.splash-desc {
  font-size:0.85rem; color:var(--text-dim); line-height:1.7;
  margin-bottom:1.5rem;
}
.splash-actions {
  display:flex; gap:0.6rem; justify-content:center; flex-wrap:wrap;
  margin-bottom:1.2rem;
}
.splash-btn {
  padding:0.6rem 1.3rem; border-radius:8px; border:none;
  font-family:var(--body); font-weight:700; font-size:0.8rem;
  cursor:pointer; transition:all 0.15s; display:flex;
  align-items:center; gap:0.5rem;
}
.splash-btn:hover { transform:translateY(-1px); filter:brightness(1.1); }
.splash-btn:active { transform:scale(0.97); }
.splash-btn-guide {
  background:var(--cyan); color:#111;
  box-shadow:0 2px 16px rgba(62,201,209,0.3);
}
.splash-btn-explore {
  background:var(--surface2); color:var(--text-dim);
  border:1px solid var(--border);
}
.splash-btn-import {
  background:var(--surface2); color:var(--text-dim);
  border:1px solid var(--border);
}
.splash-hint {
  margin-top:1rem; font-size:0.65rem; color:var(--text-faint);
  font-family:var(--mono);
}
.splash-attr {
  margin-top:0.5rem; font-size:0.58rem; color:var(--text-faint);
  font-family:var(--mono); opacity:0.7;
}

/* Saved projects list */
.splash-projects {
  text-align:left; margin-top:1.2rem;
  border-top:1px solid var(--border); padding-top:0.8rem;
}
.splash-projects-title {
  font-family:var(--mono); font-size:0.62rem; color:var(--text-faint);
  text-transform:uppercase; letter-spacing:0.06em; margin-bottom:0.5rem;
}
.splash-project {
  display:flex; align-items:center; gap:0.5rem;
  padding:0.5rem 0.6rem; border-radius:6px;
  border:1px solid var(--border); background:var(--surface2);
  margin-bottom:0.35rem; cursor:pointer; transition:all 0.15s;
}
.splash-project:hover { border-color:var(--cyan); background:var(--cyan-dim); }
.splash-project-icon { font-size:0.9rem; flex-shrink:0; }
.splash-project-info { flex:1; min-width:0; }
.splash-project-name {
  font-family:var(--body); font-weight:600; font-size:0.78rem;
  color:var(--text); white-space:nowrap; overflow:hidden; text-overflow:ellipsis;
}
.splash-project-meta {
  font-family:var(--mono); font-size:0.6rem; color:var(--text-faint);
}
.splash-project-del {
  width:22px; height:22px; border-radius:4px; border:1px solid transparent;
  background:none; color:var(--text-faint); cursor:pointer;
  display:flex; align-items:center; justify-content:center; font-size:0.7rem;
  flex-shrink:0; transition:all 0.15s;
}
.splash-project-del:hover { border-color:var(--red); color:var(--red); background:rgba(244,67,54,0.1); }

/* Workshop guide panel */
.guide-toggle {
  position:absolute; top:8px; right:12px; z-index:20;
  display:flex; align-items:center; gap:0.4rem;
  padding:0.35rem 0.7rem; border-radius:6px;
  background:var(--surface2); border:1px solid var(--border);
  color:var(--cyan); font-family:var(--mono); font-size:0.7rem;
  cursor:pointer; transition:all 0.15s; user-select:none;
}
.guide-toggle:hover { background:var(--cyan-dim); border-color:var(--cyan); }
.guide-toggle .guide-dot {
  width:7px; height:7px; border-radius:50%; background:var(--cyan);
  animation:guide-pulse 2s ease-in-out infinite;
}
@keyframes guide-pulse {
  0%,100% { opacity:0.5; } 50% { opacity:1; }
}

.guide-panel {
  position:absolute; top:0; right:0; bottom:0; width:380px; z-index:15;
  background:var(--surface); border-left:1px solid var(--border);
  display:flex; flex-direction:column;
  transform:translateX(100%); transition:transform 0.25s ease;
  box-shadow:-4px 0 24px rgba(0,0,0,0.3);
}
.guide-panel.open { transform:translateX(0); }

.guide-header {
  display:flex; align-items:center; padding:0.7rem 1rem;
  border-bottom:1px solid var(--border); background:var(--surface2);
  gap:0.5rem;
}
.guide-header h2 {
  font-family:var(--display); font-size:1rem; font-weight:700;
  flex:1;
}
.guide-header h2 .accent { color:var(--cyan); }
.guide-close {
  width:28px; height:28px; border-radius:6px; border:1px solid var(--border);
  background:var(--surface); color:var(--text-dim); display:flex;
  align-items:center; justify-content:center; cursor:pointer;
  font-size:0.8rem; transition:all 0.15s;
}
.guide-close:hover { border-color:var(--red); color:var(--red); }

.guide-progress {
  display:flex; gap:3px; padding:0.5rem 1rem;
  border-bottom:1px solid var(--border);
}
.guide-pip {
  flex:1; height:4px; border-radius:2px; background:var(--border);
  transition:background 0.3s; cursor:pointer;
}
.guide-pip.done { background:var(--green); }
.guide-pip.current { background:var(--cyan); }
.guide-pip:hover { filter:brightness(1.3); }

.guide-body {
  flex:1; overflow-y:auto; padding:1rem; line-height:1.7;
  scrollbar-width:thin; scrollbar-color:var(--border) transparent;
}
.guide-body h3 {
  font-family:var(--display); font-size:1.1rem; font-weight:700;
  margin-bottom:0.2rem; color:var(--text);
}
.guide-body .chapter-num {
  font-family:var(--mono); font-size:0.65rem; color:var(--cyan);
  text-transform:uppercase; letter-spacing:0.06em;
}
.guide-body p { font-size:0.82rem; color:var(--text-dim); margin:0.5rem 0; }
.guide-body .concept {
  background:var(--cyan-dim); border:1px solid rgba(62,201,209,0.2);
  border-radius:6px; padding:0.5rem 0.7rem; margin:0.6rem 0;
  font-size:0.78rem; color:var(--cyan);
}
.guide-body .concept strong { color:var(--text); }
.guide-body .task {
  background:var(--amber-dim); border:1px solid rgba(229,164,48,0.2);
  border-radius:6px; padding:0.5rem 0.7rem; margin:0.6rem 0;
  font-size:0.78rem; color:var(--amber);
}
.guide-body .task strong { color:var(--text); }
.guide-body .hint {
  font-size:0.72rem; color:var(--text-faint); font-style:italic;
  margin:0.4rem 0; padding-left:0.6rem;
  border-left:2px solid var(--border);
}
.guide-body code {
  font-family:var(--mono); font-size:0.75rem; background:var(--bg);
  padding:0.1rem 0.35rem; border-radius:3px; color:var(--text);
}

.guide-footer {
  display:flex; align-items:center; padding:0.6rem 1rem;
  border-top:1px solid var(--border); background:var(--surface2); gap:0.5rem;
}
.guide-footer .spacer { flex:1; }
.guide-btn {
  padding:0.4rem 1rem; border:none; border-radius:6px;
  font-family:var(--body); font-weight:600; font-size:0.75rem;
  cursor:pointer; transition:all 0.15s;
}
.guide-btn:hover { filter:brightness(1.15); }
.guide-btn:active { transform:scale(0.97); }
.guide-btn-prev { background:var(--surface); color:var(--text-dim); border:1px solid var(--border); }
.guide-btn-next { background:var(--cyan); color:#111; }
.guide-btn-check { background:var(--green); color:#111; }
.guide-chapter-label {
  font-family:var(--mono); font-size:0.65rem; color:var(--text-faint);
}

/* Modal */
.modal-overlay {
  position:fixed; inset:0; background:rgba(0,0,0,0.6); z-index:200;
  display:flex; align-items:center; justify-content:center;
  opacity:0; pointer-events:none; transition:opacity 0.15s;
}
.modal-overlay.show { opacity:1; pointer-events:auto; }
.modal {
  background:var(--surface2); border:1px solid var(--border); border-radius:10px;
  padding:1.2rem 1.5rem; min-width:320px; max-width:90vw;
  box-shadow:0 8px 32px rgba(0,0,0,0.5);
}
.modal h3 {
  font-family:var(--mono); font-size:0.85rem; color:var(--text); margin-bottom:0.8rem;
}
.modal input {
  width:100%; background:var(--bg); border:1px solid var(--border);
  color:var(--text); padding:0.5rem 0.7rem; border-radius:6px;
  font-family:var(--mono); font-size:0.8rem; outline:none;
}
.modal input:focus { border-color:var(--cyan); }
.modal-btns { display:flex; gap:0.5rem; margin-top:1rem; justify-content:flex-end; }
.modal-btns .btn { padding:0.4rem 1rem; border-radius:6px; border:none; font-family:var(--body); font-weight:600; font-size:0.75rem; cursor:pointer; }
.modal-btns .btn-ok { background:var(--cyan); color:#111; }
.modal-btns .btn-cancel { background:var(--surface); color:var(--text-dim); border:1px solid var(--border); }

/* Sidebar search */
.sidebar-search {
  padding:0.5rem 0.8rem; border-bottom:1px solid var(--border);
}
.sidebar-search input {
  width:100%; background:var(--bg); border:1px solid var(--border);
  color:var(--text); padding:0.35rem 0.5rem 0.35rem 1.6rem;
  border-radius:6px; font-family:var(--mono); font-size:0.68rem; outline:none;
  background-image:url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 24 24' fill='none' stroke='%23666460' stroke-width='2.5'%3E%3Ccircle cx='11' cy='11' r='8'/%3E%3Cline x1='21' y1='21' x2='16.65' y2='16.65'/%3E%3C/svg%3E");
  background-repeat:no-repeat; background-position:0.5rem center;
}
.sidebar-search input:focus { border-color:var(--cyan); }
.sidebar-search input::placeholder { color:var(--text-faint); }

/* Collapsible sections */
.sidebar-section-label {
  font-family:var(--mono); font-size:0.62rem; font-weight:600;
  color:var(--text-faint); text-transform:uppercase; letter-spacing:0.06em;
  margin-bottom:0.4rem; cursor:pointer; display:flex; align-items:center;
  gap:0.3rem; user-select:none; transition:color 0.15s;
}
.sidebar-section-label:hover { color:var(--text-dim); }
.sidebar-section-label::before {
  content:'â–¾'; font-size:0.55rem; transition:transform 0.15s; display:inline-block; width:0.7em;
}
.sidebar-section.collapsed .sidebar-section-label::before { transform:rotate(-90deg); }
.sidebar-section.collapsed .sidebar-items { display:none; }
.sidebar-items { /* wrapper for drag-items inside section */ }
.drag-item.filtered { display:none; }
</style>
</head>
<body>
<div class="app">

  <!-- Sidebar -->
  <div class="sidebar">
    <div class="sidebar-header">
      <h1>Flow <span class="accent">Workshop</span></h1>
      <p>Drag nodes â†’ connect â†’ run</p>
    </div>

    <div class="sidebar-search">
      <input type="text" id="nodeSearch" placeholder="Search nodes..." />
    </div>

    <div class="sidebar-scroll">

    <div class="sidebar-section" data-section="triggers">
      <div class="sidebar-section-label">Triggers</div>
      <div class="sidebar-items">
        <div class="drag-item" draggable="true" data-node="manual_trigger">
          <div class="drag-icon trigger">â–¶</div>Manual Trigger
        </div>
        <div class="drag-item" draggable="true" data-node="interval_trigger">
          <div class="drag-icon trigger">â±</div>Interval Trigger
        </div>
        <div class="drag-item" draggable="true" data-node="telegram_trigger">
          <div class="drag-icon trigger">âœˆ</div>Telegram Trigger
        </div>
      </div>
    </div>

    <div class="sidebar-section" data-section="api">
      <div class="sidebar-section-label">API Calls</div>
      <div class="sidebar-items">
        <div class="drag-item" draggable="true" data-node="dog_random">
          <div class="drag-icon api">ðŸ•</div>Dog CEO: Random
        </div>
        <div class="drag-item" draggable="true" data-node="dog_breed">
          <div class="drag-icon api">ðŸ•</div>Dog CEO: By Breed
        </div>
        <div class="drag-item" draggable="true" data-node="http_get">
          <div class="drag-icon api">â¬‡</div>HTTP GET
        </div>
        <div class="drag-item" draggable="true" data-node="open_meteo">
          <div class="drag-icon api">ðŸŒ¤</div>Weather
        </div>
        <div class="drag-item" draggable="true" data-node="wikipedia">
          <div class="drag-icon api">W</div>Wikipedia
        </div>
        <div class="drag-item" draggable="true" data-node="pokeapi">
          <div class="drag-icon api">âš¡</div>PokÃ©API
        </div>
        <div class="drag-item" draggable="true" data-node="jokeapi">
          <div class="drag-icon api">ðŸ˜„</div>JokeAPI
        </div>
        <div class="drag-item" draggable="true" data-node="rest_countries">
          <div class="drag-icon api">ðŸŒ</div>REST Countries
        </div>
      </div>
    </div>

    <div class="sidebar-section" data-section="transform">
      <div class="sidebar-section-label">Transform</div>
      <div class="sidebar-items">
        <div class="drag-item" draggable="true" data-node="extract_field">
          <div class="drag-icon transform">{}</div>Extract Field
        </div>
        <div class="drag-item" draggable="true" data-node="template">
          <div class="drag-icon transform">T</div>Template
        </div>
        <div class="drag-item" draggable="true" data-node="merge">
          <div class="drag-icon transform">âŠ•</div>Merge / Relay
        </div>
        <div class="drag-item" draggable="true" data-node="if_node">
          <div class="drag-icon transform">â‘‚</div>If
        </div>
        <div class="drag-item" draggable="true" data-node="for_each">
          <div class="drag-icon transform">â†»</div>ForEach
        </div>
        <div class="drag-item" draggable="true" data-node="code_node">
          <div class="drag-icon transform">âŒ¨</div>Code
        </div>
        <div class="drag-item" draggable="true" data-node="set_variable">
          <div class="drag-icon transform">âœŽ</div>Set Variable
        </div>
        <div class="drag-item" draggable="true" data-node="get_variable">
          <div class="drag-icon transform">â¤“</div>Get Variable
        </div>
      </div>
    </div>

    <div class="sidebar-section" data-section="llm">
      <div class="sidebar-section-label">LLM</div>
      <div class="sidebar-items">
        <div class="drag-item" draggable="true" data-node="llm_chat">
          <div class="drag-icon llm">âœ¦</div>LLM Chat
        </div>
      </div>
    </div>

    <div class="sidebar-section" data-section="output">
      <div class="sidebar-section-label">Output</div>
      <div class="sidebar-items">
        <div class="drag-item" draggable="true" data-node="display">
          <div class="drag-icon output">â—‰</div>Display Result
        </div>
        <div class="drag-item" draggable="true" data-node="display_image">
          <div class="drag-icon output">ðŸ–¼</div>Display Image
        </div>
        <div class="drag-item" draggable="true" data-node="telegram_send">
          <div class="drag-icon output">âœˆ</div>Telegram Send
        </div>
        <div class="drag-item" draggable="true" data-node="telegram_send_image">
          <div class="drag-icon output">âœˆ</div>Telegram Send Image
        </div>
      </div>
    </div>

    <div class="sidebar-section" data-section="compose">
      <div class="sidebar-section-label">Composition</div>
      <div class="sidebar-items">
        <div class="drag-item" draggable="true" data-node="input_port">
          <div class="drag-icon compose">â†’</div>Input Port
        </div>
        <div class="drag-item" draggable="true" data-node="output_port">
          <div class="drag-icon compose">â‡¥</div>Output Port
        </div>
      </div>
    </div>

    <div id="customNodesSection" class="sidebar-section" data-section="custom" style="display:none;">
      <div class="sidebar-section-label">Custom Nodes</div>
      <div class="sidebar-items" id="customNodesList"></div>
    </div>

    <div style="padding:0.5rem 0.8rem; font-size:0.62rem; color:var(--text-faint); line-height:1.5; border-top:1px solid var(--border);">
      <strong style="color:var(--text-dim);">Controls:</strong> Drag to connect ports. Click node to select. Delete/Backspace to remove selected. Right-click to delete. Scroll to zoom.
    </div>
    </div><!-- /sidebar-scroll -->

    <div class="toolbar" style="flex-wrap:wrap;">
      <div class="toolbar-row">
        <button class="btn btn-example" onclick="showExamples()">Examples</button>
        <button class="btn btn-clear" onclick="confirmClear()">Clear</button>
      </div>
      <div class="toolbar-divider"></div>
      <div class="toolbar-row">
        <button class="btn btn-save" onclick="saveProject()">ðŸ’¾ Save</button>
        <button class="btn btn-export" onclick="exportWorkspace()">â†— Export</button>
        <button class="btn btn-import" onclick="document.getElementById('loadFile').click()">â†™ Import</button>
        <input type="file" id="loadFile" accept=".flow.json,.json" style="display:none;" onchange="importWorkspace(event)" />
      </div>
    </div>
  </div>

  <!-- Canvas + tabs + log -->
  <div class="canvas-area">
    <div class="tab-bar" id="tabBar">
      <div class="tab active" data-module="Home">Main</div>
      <div class="tab-add" id="tabAdd" title="New module">+</div>
    </div>
    <div id="drawflow"></div>
    <div class="zoom-indicator" id="zoomIndicator">
      <button class="zoom-btn" onclick="editor.zoom_out()" title="Zoom out">âˆ’</button>
      <button class="zoom-level" onclick="editor.zoom_reset()" id="zoomLevel" title="Reset zoom">100%</button>
      <button class="zoom-btn" onclick="editor.zoom_in()" title="Zoom in">+</button>
    </div>

    <!-- Splash -->
    <div class="splash" id="splash">
      <div class="splash-card">
        <div class="splash-icon">â—ˆ</div>
        <div class="splash-title">Flow <span class="accent">Workshop</span></div>
        <div class="splash-sub">Workshop 301 â€” Visual API Pipelines</div>
        <div class="splash-desc">Build automation pipelines by wiring nodes together. Fetch APIs, transform data, add logic, and compose reusable abstractions â€” all visually.</div>
        <div class="splash-actions">
          <button class="splash-btn splash-btn-guide" onclick="dismissSplash('guide')">
            â–¶ Start Workshop
          </button>
          <button class="splash-btn splash-btn-explore" onclick="dismissSplash('explore')">
            â—‡ Explore Freely
          </button>
          <button class="splash-btn splash-btn-import" onclick="dismissSplash('import')">
            â†™ Import File
          </button>
        </div>
        <div id="splashProjects"></div>
        <div class="splash-hint">27 nodes Â· 16 chapters Â· Telegram bot Â· Sub-graph composition</div>
        <div class="splash-attr">Powered by <a href="https://github.com/jerosoler/Drawflow" target="_blank" style="color:var(--cyan)">Drawflow</a> by Jero Soler Â· MIT License</div>
      </div>
    </div>

    <!-- Guide toggle -->
    <div class="guide-toggle" id="guideToggle" onclick="toggleGuide()" style="display:none;">
      <div class="guide-dot"></div> Workshop Guide
    </div>

    <!-- Workshop guide panel -->
    <div class="guide-panel" id="guidePanel">
      <div class="guide-header">
        <h2>Flow <span class="accent">Guide</span></h2>
        <div class="guide-close" onclick="toggleGuide()">âœ•</div>
      </div>
      <div class="guide-progress" id="guideProgress"></div>
      <div class="guide-body" id="guideBody"></div>
      <div class="guide-footer">
        <button class="guide-btn guide-btn-prev" id="guidePrev" onclick="guideNav(-1)">â† Back</button>
        <span class="guide-chapter-label" id="guideChapterLabel"></span>
        <span class="spacer"></span>
        <button class="guide-btn guide-btn-check" id="guideCheck" onclick="guideCheckTask()">âœ“ Check</button>
        <button class="guide-btn guide-btn-next" id="guideNext" onclick="guideNav(1)">Next â†’</button>
      </div>
    </div>
    <div class="log-panel" id="logPanel">
      <div class="log-resize-handle" id="logResizeHandle"></div>
      <div class="log-header">
        <div class="log-tabs">
          <span class="log-tab active" data-tab="log" onclick="switchLogTab('log')">Execution Log</span>
          <span class="log-tab" data-tab="vars" onclick="switchLogTab('vars')">Variables</span>
          <span class="log-tab" data-tab="config" onclick="switchLogTab('config')">Config</span>
        </div>
        <span class="spacer"></span>
        <span id="runStatus" style="color:var(--text-faint);">idle</span>
      </div>
      <div class="log-body log-tab-content active" id="logBody" data-tab="log">
        <div class="log-empty">Build a flow and hit Run to see execution here.</div>
      </div>
      <div class="log-body log-tab-content" id="varsBody" data-tab="vars">
        <div class="log-empty">No variables set yet. Use a Set Variable node to store values.</div>
      </div>
      <div class="log-body log-tab-content" id="configBody" data-tab="config">
        <div class="config-panel">
          <div class="config-hint">Define secrets and config values here. Reference them in any node field with <code>$name</code> syntax.</div>
          <div id="configEntries"></div>
          <button class="config-add-btn" onclick="addConfigEntry()">+ Add</button>
        </div>
      </div>
    </div>
  </div>

</div>

<!-- Modal -->
<div class="modal-overlay" id="modalOverlay">
  <div class="modal">
    <h3 id="modalTitle">Title</h3>
    <input type="text" id="modalInput" />
    <div class="modal-btns">
      <button class="btn btn-cancel" id="modalCancel">Cancel</button>
      <button class="btn btn-ok" id="modalOk">OK</button>
    </div>
  </div>
</div>

<!-- Example Gallery -->
<div class="example-overlay" id="exampleOverlay" onclick="if(event.target===this)closeExamples()">
  <div class="example-modal">
    <div class="example-header">
      <h3>Example Flows</h3>
      <div class="example-close" onclick="closeExamples()">âœ•</div>
    </div>
    <div class="example-list" id="exampleList"></div>
  </div>
</div>

<script>
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INIT DRAWFLOW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const el = document.getElementById('drawflow');
const editor = new Drawflow(el);
editor.reroute = true;
editor.draggable_inputs = false;
editor.zoom_max = 2;
editor.zoom_min = 0.3;
editor.start();

editor.zoom_enter = function(e) { /* replaced by our scroll handler */ };

el.addEventListener('wheel', function(e) {
  e.preventDefault();
  if (e.deltaY > 0) editor.zoom_out();
  else editor.zoom_in();
}, { passive: false });

// Zoom indicator â€” update on every zoom change
function updateZoomDisplay() {
  const pct = Math.round(editor.zoom * 100);
  document.getElementById('zoomLevel').textContent = pct + '%';
}
editor.on('zoom', updateZoomDisplay);

// Auto-save every 30 seconds (silent, to localStorage)
setInterval(() => {
  if (!window._currentProjectName) return;
  try {
    const projects = JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}');
    const ws = buildWorkspaceData(window._currentProjectName);
    projects[window._currentProjectName] = ws;
    localStorage.setItem(STORAGE_KEY, JSON.stringify(projects));
  } catch(e) { /* silent */ }
}, 30000);

// Prevent buttons/toggles inside nodes from triggering drag, AND handle resize start
let _resizing = false, _resizeNode = null, _startX = 0, _startY = 0, _startW = 0, _startH = 0;

el.addEventListener('mousedown', function(e) {
  // Resize grip â€” start resize
  const grip = e.target.closest('.node-resize');
  if (grip) {
    e.preventDefault();
    e.stopPropagation();
    _resizeNode = grip.closest('.drawflow-node');
    if (!_resizeNode) return;
    _resizing = true;
    _startX = e.clientX;
    _startY = e.clientY;
    _startW = _resizeNode.offsetWidth;
    _startH = _resizeNode.offsetHeight;
    _resizeNode.classList.add('resizing');
    document.body.style.cursor = 'nwse-resize';
    document.body.style.userSelect = 'none';
    return;
  }
  // Other interactive elements â€” prevent Drawflow drag
  if (e.target.closest('.node-run-btn') || e.target.closest('.toggle') ||
      e.target.closest('.node-result') || e.target.tagName === 'BUTTON') {
    e.stopPropagation();
  }
}, true);

document.addEventListener('mousemove', function(e) {
  if (!_resizing || !_resizeNode) return;
  const zoom = editor.zoom;
  const dw = (e.clientX - _startX) / zoom;
  const dh = (e.clientY - _startY) / zoom;
  const newW = Math.max(160, _startW + dw);
  const newH = Math.max(60, _startH + dh);
    _resizeNode.style.setProperty('width', newW + 'px', 'important');
    _resizeNode.style.setProperty('min-height', newH + 'px', 'important');
    editor.updateConnectionNodes(_resizeNode.id);
});

document.addEventListener('mouseup', function() {
  if (!_resizing) return;
  if (_resizeNode) _resizeNode.classList.remove('resizing');
  _resizing = false;
  _resizeNode = null;
  document.body.style.cursor = '';
  document.body.style.userSelect = '';
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NODE RESIZE HANDLES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Inject resize handle into every new node
editor.on('nodeCreated', function(nodeId) {
  const domNode = document.getElementById('node-' + nodeId);
  if (!domNode || domNode.querySelector('.node-resize')) return;
  const grip = document.createElement('div');
  grip.className = 'node-resize';
  domNode.appendChild(grip);
});

// Also inject into nodes that already exist (e.g. after import)
function injectResizeHandles() {
  document.querySelectorAll('.drawflow-node').forEach(domNode => {
    if (domNode.querySelector('.node-resize')) return;
    const grip = document.createElement('div');
    grip.className = 'node-resize';
    domNode.appendChild(grip);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TAB / MODULE MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const tabBar = document.getElementById('tabBar');
const tabAdd = document.getElementById('tabAdd');
let activeCtx = null; // context menu element

function refreshTabs() {
  // Remove all tabs except the + button
  tabBar.querySelectorAll('.tab').forEach(t => t.remove());
  const modules = Object.keys(editor.drawflow.drawflow);
  modules.forEach(mod => {
    const tab = document.createElement('div');
    tab.className = 'tab' + (mod === editor.module ? ' active' : '');
    tab.dataset.module = mod;
    tab.textContent = mod === 'Home' ? 'Main' : mod;
    tab.addEventListener('click', () => switchModule(mod));
    tab.addEventListener('contextmenu', e => { e.preventDefault(); showTabCtx(e, mod); });
    tabBar.insertBefore(tab, tabAdd);
  });
}

function switchModule(mod) {
  editor.changeModule(mod);
  refreshTabs();
  injectResizeHandles();
}

tabAdd.addEventListener('click', async () => {
  const name = await showModal('New module name:');
  if (!name || !name.trim()) return;
  const modName = name.trim();
  if (editor.drawflow.drawflow[modName]) { alert('Module already exists.'); return; }
  editor.addModule(modName);
  switchModule(modName);
});

function showTabCtx(e, mod) {
  closeTabCtx();
  const ctx = document.createElement('div');
  ctx.className = 'tab-ctx';
  ctx.style.left = e.clientX + 'px';
  ctx.style.top = e.clientY + 'px';

  if (mod !== 'Home') {
    const renameItem = document.createElement('div');
    renameItem.className = 'tab-ctx-item';
    renameItem.textContent = 'Rename';
    renameItem.onclick = () => { closeTabCtx(); renameModule(mod); };
    ctx.appendChild(renameItem);
  }

  if (mod !== 'Home') {
    const saveItem = document.createElement('div');
    saveItem.className = 'tab-ctx-item';
    saveItem.textContent = 'ðŸ“¦ Save as Node';
    saveItem.onclick = () => { closeTabCtx(); saveModuleAsNode(mod); };
    ctx.appendChild(saveItem);
  }

  const dupeItem = document.createElement('div');
  dupeItem.className = 'tab-ctx-item';
  dupeItem.textContent = 'Duplicate';
  dupeItem.onclick = () => { closeTabCtx(); duplicateModule(mod); };
  ctx.appendChild(dupeItem);

  if (mod !== 'Home') {
    const delItem = document.createElement('div');
    delItem.className = 'tab-ctx-item danger';
    delItem.textContent = 'Delete';
    delItem.onclick = () => { closeTabCtx(); deleteModule(mod); };
    ctx.appendChild(delItem);
  }

  document.body.appendChild(ctx);
  activeCtx = ctx;
}

function closeTabCtx() {
  if (activeCtx) { activeCtx.remove(); activeCtx = null; }
}
document.addEventListener('click', closeTabCtx);

async function renameModule(oldName) {
  const newName = await showModal('New name:', oldName);
  if (!newName || !newName.trim() || newName.trim() === oldName) return;
  const nn = newName.trim();
  if (editor.drawflow.drawflow[nn]) { alert('Name already in use.'); return; }
  editor.drawflow.drawflow[nn] = editor.drawflow.drawflow[oldName];
  delete editor.drawflow.drawflow[oldName];
  if (editor.module === oldName) editor.module = nn;
  refreshTabs();
}

async function duplicateModule(mod) {
  const name = await showModal('Name for copy:', mod + ' copy');
  if (!name || !name.trim()) return;
  const nn = name.trim();
  if (editor.drawflow.drawflow[nn]) { alert('Name already in use.'); return; }
  editor.drawflow.drawflow[nn] = JSON.parse(JSON.stringify(editor.drawflow.drawflow[mod]));
  refreshTabs();
  switchModule(nn);
}

function deleteModule(mod) {
  if (!confirm(`Delete module "${mod}"?`)) return;
  editor.removeModule(mod);
  refreshTabs();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SAVE MODULE AS REUSABLE NODE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

async function saveModuleAsNode(mod) {
  const graph = editor.drawflow.drawflow[mod]?.data || {};
  const nodes = Object.values(graph);

  // Find input/output ports
  const inputPorts = nodes.filter(n => n.name === 'input_port');
  const outputPorts = nodes.filter(n => n.name === 'output_port');

  if (!inputPorts.length && !outputPorts.length) {
    alert('Add at least one Input Port or Output Port to this module before saving as a node.');
    return;
  }

  const nodeName = await showModal('Node name:', mod);
  if (!nodeName || !nodeName.trim()) return;
  const cleanName = 'custom_' + nodeName.trim().toLowerCase().replace(/[^a-z0-9]+/g, '_');

  // Build the custom node definition
  const numInputs = inputPorts.length;
  const numOutputs = outputPorts.length;
  const portInfo = [
    ...inputPorts.map((p,i) => `â†’ ${p.data.port_name || 'in_'+(i+1)}`),
    ...outputPorts.map((p,i) => `â‡¥ ${p.data.port_name || 'out_'+(i+1)}`)
  ].join(' ');

  NODE_DEFS[cleanName] = {
    name: cleanName, label: nodeName.trim(),
    inputs: numInputs, outputs: numOutputs,
    cls: 'node-compose', icon: 'ðŸ“¦', iconCls: 'compose',
    html: nodeHtml('ðŸ“¦', nodeName.trim(),
      `<div class="node-info">${esc(portInfo)}</div>
       <div class="node-info" style="color:var(--pink);">Module: ${esc(mod)}</div>`),
    data: { _module: mod },
    _sourceModule: mod,
    async exec(data, inputs) {
      // Run the sub-graph
      const subGraph = editor.drawflow.drawflow[data._module]?.data;
      if (!subGraph) throw new Error(`Module "${data._module}" not found`);

      const subNodes = JSON.parse(JSON.stringify(subGraph));

      // Inject input data into input_port nodes
      const inPorts = Object.values(subNodes).filter(n => n.name === 'input_port')
        .sort((a,b) => a.id - b.id);
      const subResults = {};
      inPorts.forEach((port, i) => {
        subResults[port.id] = inputs || {};
      });

      // Find start nodes (input_port nodes have no connections coming in)
      const startIds = inPorts.map(p => p.id);
      // Also add any trigger nodes in the sub-graph
      const subTriggers = Object.values(subNodes).filter(n =>
        n.name === 'manual_trigger' || n.name === 'interval_trigger');
      startIds.push(...subTriggers.map(t => t.id));

      // If no start nodes found, start from nodes with no incoming connections
      if (!startIds.length) {
        for (const n of Object.values(subNodes)) {
          const hasInput = Object.values(n.inputs || {}).some(inp => inp.connections.length > 0);
          if (!hasInput) startIds.push(n.id);
        }
      }

      // Execute sub-graph (depth+1 handled inside executeGraph)
      const results = await executeGraph(startIds, subNodes, subResults, 1);

      // Collect output_port results
      const outPorts = Object.values(subNodes).filter(n => n.name === 'output_port')
        .sort((a,b) => a.id - b.id);

      if (outPorts.length === 1) {
        return results[outPorts[0].id] || {};
      } else if (outPorts.length > 1) {
        const combined = {};
        outPorts.forEach(p => Object.assign(combined, results[p.id] || {}));
        return combined;
      }
      return {};
    }
  };

  // Add to sidebar
  addCustomNodeToSidebar(cleanName, nodeName.trim());
  addLog('info', `Saved "${nodeName.trim()}" as reusable node from module "${mod}"`);
}

function addCustomNodeToSidebar(defName, label) {
  const section = document.getElementById('customNodesSection');
  section.style.display = '';
  const list = document.getElementById('customNodesList');

  const item = document.createElement('div');
  item.className = 'drag-item';
  item.draggable = true;
  item.dataset.node = defName;
  item.innerHTML = `<div class="drag-icon compose">ðŸ“¦</div>${esc(label)}`;
  item.addEventListener('dragstart', e => {
    e.dataTransfer.setData('node-type', defName);
  });
  list.appendChild(item);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  HELPERS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function esc(s) { return String(s).replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;'); }
function timeStr() { return new Date().toLocaleTimeString('en-GB',{hour:'2-digit',minute:'2-digit',second:'2-digit'}); }

function resolveInput(value, inputs) {
  if (typeof value !== 'string') return value;
  // First resolve $config references
  let resolved = resolveConfig(value);
  // Then resolve {input} references
  if (inputs) {
    resolved = resolved.replace(/\{(\w+)\}/g, (_, key) => {
      if (inputs[key] !== undefined) return String(inputs[key]);
      return `{${key}}`;
    });
  }
  return resolved;
}

function nodeHtml(icon, title, bodyHtml) {
  return `<div class="node-box">
    <div class="node-header"><div class="node-icon">${icon}</div><span class="node-title">${title}</span></div>
    <div class="node-body">${bodyHtml}</div>
  </div>`;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  FLOW VARIABLES (session state)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const flowVars = {};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  NODE DEFINITIONS
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const NODE_DEFS = {

  // â”€â”€ TRIGGERS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  manual_trigger: {
    name:'manual_trigger', label:'Manual Trigger', inputs:0, outputs:1,
    cls:'node-trigger', icon:'â–¶', iconCls:'trigger',
    html: nodeHtml('â–¶', 'Manual Trigger', '<button class="node-run-btn">â–¶ Run Flow</button>'),
    data:{},
    async exec(data, inputs) { return { triggered: true, timestamp: new Date().toISOString() }; }
  },

  interval_trigger: {
    name:'interval_trigger', label:'Interval Trigger', inputs:0, outputs:1,
    cls:'node-trigger', icon:'â±', iconCls:'trigger',
    html: nodeHtml('â±', 'Interval Trigger',
      `<label>Every (seconds)</label>
       <input type="number" df-seconds value="5" min="1" step="1" />
       <div style="margin-top:0.4rem;display:flex;align-items:center;gap:0.5rem;">
         <label class="toggle"><input type="checkbox" class="interval-toggle"><span class="toggle-track"></span></label>
         <span class="interval-status" style="font-size:0.65rem;color:var(--text-faint);">stopped</span>
       </div>`),
    data:{ seconds:'5' },
    async exec(data, inputs) { return { triggered: true, tick: Date.now(), timestamp: new Date().toISOString() }; }
  },

  telegram_trigger: {
    name:'telegram_trigger', label:'Telegram Trigger', inputs:1, outputs:1,
    cls:'node-trigger', icon:'âœˆ', iconCls:'trigger',
    html: nodeHtml('âœˆ', 'Telegram Trigger',
      `<label>Bot Token</label>
       <input type="password" df-token placeholder="$tg_token or paste key" />
       <label>Poll Interval (s)</label>
       <input type="number" df-seconds value="3" min="1" step="1" />
       <div style="margin-top:0.4rem;display:flex;align-items:center;gap:0.5rem;">
         <label class="toggle"><input type="checkbox" class="telegram-toggle"><span class="toggle-track"></span></label>
         <span class="telegram-status" style="font-size:0.65rem;color:var(--text-faint);">stopped</span>
       </div>
       <div class="node-info">Fires once per incoming message</div>`),
    data:{ token:'', seconds:'3' },
    async exec(data, inputs) {
      // This is called by the polling loop for each message
      return inputs || { triggered: true, timestamp: new Date().toISOString() };
    }
  },

  // â”€â”€ API CALLS â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  dog_random: {
    name:'dog_random', label:'Dog CEO: Random', inputs:1, outputs:1,
    cls:'node-api', icon:'ðŸ•', iconCls:'api',
    html: nodeHtml('ðŸ•', 'Dog CEO: Random', '<div class="node-info">GET /breeds/image/random</div>'),
    data:{},
    async exec(data, inputs) {
      const r = await fetch('https://dog.ceo/api/breeds/image/random');
      const j = await r.json();
      const breed = j.message.split('/breeds/')[1]?.split('/')[0]?.replace(/-/g,' ') || 'unknown';
      return { image_url: j.message, breed, status: j.status };
    }
  },

  dog_breed: {
    name:'dog_breed', label:'Dog CEO: By Breed', inputs:1, outputs:1,
    cls:'node-api', icon:'ðŸ•', iconCls:'api',
    html: nodeHtml('ðŸ•', 'Dog CEO: By Breed', '<label>Breed</label><input type="text" df-breed placeholder="labrador" />'),
    data:{ breed:'labrador' },
    async exec(data, inputs) {
      const breed = resolveInput(data.breed, inputs);
      const r = await fetch(`https://dog.ceo/api/breed/${breed.replace(/\s+/g,'/')}/images/random`);
      const j = await r.json();
      if (j.status !== 'success') throw new Error(j.message || 'Breed not found');
      return { image_url: j.message, breed, status: j.status };
    }
  },

  http_get: {
    name:'http_get', label:'HTTP GET', inputs:1, outputs:1,
    cls:'node-api', icon:'â¬‡', iconCls:'api',
    html: nodeHtml('â¬‡', 'HTTP GET', '<label>URL</label><input type="text" df-url placeholder="https://api.example.com/data" />'),
    data:{ url:'' },
    async exec(data, inputs) {
      const url = resolveInput(data.url, inputs);
      const r = await fetch(url);
      return await r.json();
    }
  },

  open_meteo: {
    name:'open_meteo', label:'Weather', inputs:1, outputs:1,
    cls:'node-api', icon:'ðŸŒ¤', iconCls:'api',
    html: nodeHtml('ðŸŒ¤', 'Weather (Open-Meteo)',
      `<label>Latitude</label><input type="text" df-lat placeholder="-19.92" />
       <label>Longitude</label><input type="text" df-lon placeholder="-43.94" />
       <div class="node-info">Supports {var} from input</div>`),
    data:{ lat:'-19.92', lon:'-43.94' },
    async exec(data, inputs) {
      const lat = resolveInput(data.lat, inputs);
      const lon = resolveInput(data.lon, inputs);
      const url = `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lon}&current=temperature_2m,weather_code,wind_speed_10m,relative_humidity_2m`;
      const r = await fetch(url);
      const j = await r.json();
      const c = j.current;
      const codes = {0:'Clear',1:'Mostly clear',2:'Partly cloudy',3:'Overcast',45:'Foggy',48:'Fog',51:'Light drizzle',53:'Drizzle',55:'Heavy drizzle',61:'Light rain',63:'Rain',65:'Heavy rain',71:'Light snow',73:'Snow',75:'Heavy snow',80:'Rain showers',81:'Heavy showers',95:'Thunderstorm'};
      return {
        temperature: c.temperature_2m, unit: j.current_units.temperature_2m,
        wind_speed: c.wind_speed_10m, humidity: c.relative_humidity_2m,
        description: codes[c.weather_code] || `Code ${c.weather_code}`,
        weather_code: c.weather_code, latitude: lat, longitude: lon
      };
    }
  },

  wikipedia: {
    name:'wikipedia', label:'Wikipedia', inputs:1, outputs:1,
    cls:'node-api', icon:'W', iconCls:'api',
    html: nodeHtml('W', 'Wikipedia Summary',
      `<label>Topic</label><input type="text" df-topic placeholder="Geostatistics" />
       <div class="node-info">Supports {var} from input</div>`),
    data:{ topic:'' },
    async exec(data, inputs) {
      const topic = resolveInput(data.topic, inputs) || inputs?.value || inputs?.text || '';
      const url = `https://en.wikipedia.org/api/rest_v1/page/summary/${encodeURIComponent(topic)}`;
      const r = await fetch(url);
      if (!r.ok) throw new Error(`Wikipedia: ${r.status} for "${topic}"`);
      const j = await r.json();
      return {
        title: j.title, summary: j.extract,
        thumbnail_url: j.thumbnail?.source || null,
        url: j.content_urls?.desktop?.page || null,
        text: j.extract
      };
    }
  },

  pokeapi: {
    name:'pokeapi', label:'PokÃ©API', inputs:1, outputs:1,
    cls:'node-api', icon:'âš¡', iconCls:'api',
    html: nodeHtml('âš¡', 'PokÃ©API',
      `<label>PokÃ©mon</label><input type="text" df-pokemon placeholder="pikachu" />
       <div class="node-info">Name or ID. Supports {var}</div>`),
    data:{ pokemon:'pikachu' },
    async exec(data, inputs) {
      const name = (resolveInput(data.pokemon, inputs) || inputs?.value || 'pikachu').toString().toLowerCase().trim();
      const r = await fetch(`https://pokeapi.co/api/v2/pokemon/${encodeURIComponent(name)}`);
      if (!r.ok) throw new Error(`PokÃ©API: ${r.status} for "${name}"`);
      const j = await r.json();
      return {
        name: j.name, id: j.id,
        types: j.types.map(t => t.type.name).join(', '),
        sprite_url: j.sprites.front_default,
        image_url: j.sprites.other?.['official-artwork']?.front_default || j.sprites.front_default,
        hp: j.stats[0].base_stat, attack: j.stats[1].base_stat,
        defense: j.stats[2].base_stat, speed: j.stats[5].base_stat,
        height: j.height / 10, weight: j.weight / 10
      };
    }
  },

  jokeapi: {
    name:'jokeapi', label:'JokeAPI', inputs:1, outputs:1,
    cls:'node-api', icon:'ðŸ˜„', iconCls:'api',
    html: nodeHtml('ðŸ˜„', 'JokeAPI',
      `<label>Category</label>
       <select df-category>
         <option value="Any">Any</option><option value="Programming">Programming</option>
         <option value="Pun">Pun</option><option value="Spooky">Spooky</option>
         <option value="Christmas">Christmas</option>
       </select>`),
    data:{ category:'Any' },
    async exec(data, inputs) {
      const cat = data.category || 'Any';
      const r = await fetch(`https://v2.jokeapi.dev/joke/${cat}?safe-mode`);
      const j = await r.json();
      if (j.type === 'single') return { joke: j.joke, text: j.joke, category: j.category };
      return { joke: `${j.setup}\n${j.delivery}`, setup: j.setup, delivery: j.delivery, text: `${j.setup} â€” ${j.delivery}`, category: j.category };
    }
  },

  rest_countries: {
    name:'rest_countries', label:'REST Countries', inputs:1, outputs:1,
    cls:'node-api', icon:'ðŸŒ', iconCls:'api',
    html: nodeHtml('ðŸŒ', 'REST Countries',
      `<label>Country</label><input type="text" df-country placeholder="Brazil" />
       <div class="node-info">Supports {var} from input</div>`),
    data:{ country:'Brazil' },
    async exec(data, inputs) {
      const name = resolveInput(data.country, inputs) || inputs?.value || 'Brazil';
      const r = await fetch(`https://restcountries.com/v3.1/name/${encodeURIComponent(name)}?fullText=false`);
      if (!r.ok) throw new Error(`REST Countries: ${r.status} for "${name}"`);
      const arr = await r.json();
      const c = arr[0];
      return {
        name: c.name.common, official_name: c.name.official,
        capital: c.capital?.[0] || 'N/A',
        population: c.population, region: c.region, subregion: c.subregion,
        flag_url: c.flags?.png || null, flag_emoji: c.flag,
        image_url: c.flags?.png || null,
        languages: Object.values(c.languages || {}).join(', '),
        currencies: Object.values(c.currencies || {}).map(c => `${c.name} (${c.symbol})`).join(', '),
        lat: c.latlng?.[0], lon: c.latlng?.[1]
      };
    }
  },

  // â”€â”€ TRANSFORM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  extract_field: {
    name:'extract_field', label:'Extract Field', inputs:1, outputs:1,
    cls:'node-transform', icon:'{}', iconCls:'transform',
    html: nodeHtml('{}', 'Extract Field',
      `<label>Field Path</label><input type="text" df-field placeholder="e.g. breed or data.items[0].name" />`),
    data:{ field:'' },
    async exec(data, inputs) {
      const input = inputs || {};
      const path = data.field.trim();
      let val = input;
      for (const key of path.replace(/\[(\d+)\]/g, '.$1').split('.')) {
        if (val == null) break;
        val = val[key];
      }
      return { value: val, _passthrough: input };
    }
  },

  template: {
    name:'template', label:'Template', inputs:1, outputs:1,
    cls:'node-transform', icon:'T', iconCls:'transform',
    html: nodeHtml('T', 'Template',
      `<label>Template</label><textarea df-template rows="2" placeholder="Tell me about {breed}"></textarea>
       <div class="node-info">{field_name} inserts from input data</div>`),
    data:{ template:'' },
    async exec(data, inputs) {
      let text = data.template;
      if (inputs && typeof inputs === 'object') {
        for (const [k,v] of Object.entries(inputs)) {
          if (typeof v === 'string' || typeof v === 'number')
            text = text.replace(new RegExp(`\\{${k}\\}`, 'g'), String(v));
        }
      }
      return { text, _passthrough: inputs };
    }
  },

  merge: {
    name:'merge', label:'Merge / Relay', inputs:2, outputs:1,
    cls:'node-transform', icon:'âŠ•', iconCls:'transform',
    html: nodeHtml('âŠ•', 'Merge / Relay', '<div class="node-info">Passes through (1 input) or combines all inputs (2+)</div>'),
    data:{},
    async exec(data, inputs) { return inputs || {}; }
  },

  if_node: {
    name:'if_node', label:'If', inputs:1, outputs:2,
    cls:'node-transform', icon:'â‘‚', iconCls:'transform',
    html: nodeHtml('â‘‚', 'If',
      `<label>Field</label><input type="text" df-field placeholder="value" />
       <label>Operator</label>
       <select df-operator>
         <option value="eq">equals</option><option value="neq">not equals</option>
         <option value="gt">greater than</option><option value="lt">less than</option>
         <option value="contains">contains</option>
         <option value="empty">is empty</option><option value="notEmpty">is not empty</option>
       </select>
       <label>Compare To</label><input type="text" df-compare placeholder="" />
       <div class="output-labels">
         <div class="output-label true-label">âœ“ True â†’</div>
         <div class="output-label false-label">âœ— False â†’</div>
       </div>`),
    data:{ field:'value', operator:'eq', compare:'' },
    async exec(data, inputs) {
      const input = inputs || {};
      // Resolve the field value
      let val = input;
      for (const key of data.field.trim().replace(/\[(\d+)\]/g, '.$1').split('.')) {
        if (val == null) break;
        val = val[key];
      }
      const cmp = resolveInput(data.compare, input);
      let result = false;
      switch (data.operator) {
        case 'eq': result = String(val) === String(cmp); break;
        case 'neq': result = String(val) !== String(cmp); break;
        case 'gt': result = Number(val) > Number(cmp); break;
        case 'lt': result = Number(val) < Number(cmp); break;
        case 'contains': result = String(val).includes(String(cmp)); break;
        case 'empty': result = val == null || val === '' || (Array.isArray(val) && val.length === 0); break;
        case 'notEmpty': result = val != null && val !== '' && !(Array.isArray(val) && val.length === 0); break;
      }
      return { ...input, _condition: result, _route: result ? 1 : 2 };
    }
  },

  for_each: {
    name:'for_each', label:'ForEach', inputs:1, outputs:1,
    cls:'node-transform', icon:'â†»', iconCls:'transform',
    html: nodeHtml('â†»', 'ForEach',
      `<label>Array Field</label><input type="text" df-field placeholder="(auto-detect or field name)" />
       <div class="node-info">Runs downstream once per array item</div>`),
    data:{ field:'' },
    async exec(data, inputs) {
      const input = inputs || {};
      let arr;
      if (data.field && data.field.trim()) {
        // Extract specific field
        let val = input;
        for (const key of data.field.trim().replace(/\[(\d+)\]/g, '.$1').split('.')) {
          if (val == null) break;
          val = val[key];
        }
        arr = val;
      } else {
        // Auto-detect: find first array in input
        arr = Array.isArray(input) ? input :
          Object.values(input).find(v => Array.isArray(v));
      }
      if (!Array.isArray(arr)) throw new Error('No array found in input');
      return { _forEach: arr, count: arr.length };
    }
  },

  code_node: {
    name:'code_node', label:'Code', inputs:1, outputs:1,
    cls:'node-transform', icon:'âŒ¨', iconCls:'transform',
    html: nodeHtml('âŒ¨', 'Code',
      `<label>JavaScript</label>
       <textarea class="code-area" df-code rows="4" placeholder="// 'data' is your input â€” modify it\ndata.greeting = 'Hello ' + data.name;"></textarea>
       <div class="node-info">Mutate 'data' or return a new object</div>`),
    data:{ code:"// 'data' is your input â€” modify it directly\n// data.upper = data.text.toUpperCase();" },
    async exec(data, inputs) {
      const input = inputs ? JSON.parse(JSON.stringify(inputs)) : {};
      try {
        const fn = new Function('data', data.code);
        const result = fn(input);
        return result !== undefined ? result : input;
      } catch(e) {
        throw new Error(`Code error: ${e.message}`);
      }
    }
  },

  // â”€â”€ VARIABLES â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  set_variable: {
    name:'set_variable', label:'Set Variable', inputs:1, outputs:1,
    cls:'node-transform', icon:'âœŽ', iconCls:'transform',
    html: nodeHtml('âœŽ', 'Set Variable',
      `<label>Variable Name</label><input type="text" df-var_name placeholder="myVar" />
       <label>Value Field (blank = whole input)</label><input type="text" df-var_field placeholder="" />
       <div class="node-info">Stores a value. Data passes through.</div>`),
    data:{ var_name:'', var_field:'' },
    async exec(data, inputs) {
      const name = data.var_name?.trim();
      if (!name) throw new Error('Variable name is required');
      let val = inputs;
      if (data.var_field?.trim()) {
        val = inputs;
        for (const key of data.var_field.trim().replace(/\[(\d+)\]/g, '.$1').split('.')) {
          if (val == null) break;
          val = val[key];
        }
      }
      flowVars[name] = val;
      return inputs; // pass through â€” doesn't break the chain
    }
  },

  get_variable: {
    name:'get_variable', label:'Get Variable', inputs:1, outputs:1,
    cls:'node-transform', icon:'â¤“', iconCls:'transform',
    html: nodeHtml('â¤“', 'Get Variable',
      `<label>Variable Name</label><input type="text" df-var_name placeholder="myVar" />
       <div class="node-info">Retrieves a stored value</div>`),
    data:{ var_name:'' },
    async exec(data, inputs) {
      const name = data.var_name?.trim();
      if (!name) throw new Error('Variable name is required');
      const val = flowVars[name];
      if (val === undefined) throw new Error(`Variable "${name}" not set`);
      // If the stored value is an object, spread it; otherwise wrap as {value}
      if (val && typeof val === 'object' && !Array.isArray(val)) {
        return { ...val, _var: name };
      }
      return { value: val, _var: name, ...(inputs || {}) };
    }
  },

  // â”€â”€ LLM â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  llm_chat: {
    name:'llm_chat', label:'LLM Chat', inputs:1, outputs:1,
    cls:'node-llm', icon:'âœ¦', iconCls:'llm',
    html: nodeHtml('âœ¦', 'LLM Chat',
      `<label>Provider</label>
       <select df-provider>
         <option value="nanogpt">NanoGPT</option>
         <option value="groq">Groq (free tier)</option>
         <option value="local">Local / Ollama</option>
       </select>
       <label>API Key</label><input type="password" df-apikey placeholder="$llm_key or paste key (not needed for local)" />
       <label>Model</label><input type="text" df-model value="deepseek-chat" />
       <label>System Prompt</label>
       <textarea df-system rows="2" placeholder="You are a helpful assistant."></textarea>`),
    data:{ provider:'nanogpt', apikey:'', model:'deepseek-chat', system:'You are a helpful, concise assistant.' },
    async exec(data, inputs) {
      const LLM_URLS = {
        nanogpt: 'https://nano-gpt.com/api/v1/chat/completions',
        groq: 'https://api.groq.com/openai/v1/chat/completions',
        local: 'http://localhost:11434/v1/chat/completions',
      };
      const url = LLM_URLS[data.provider] || LLM_URLS.nanogpt;
      const userMsg = inputs?.text || inputs?.value || (typeof inputs === 'string' ? inputs : JSON.stringify(inputs));
      const headers = { 'Content-Type':'application/json' };
      const key = resolveConfig(data.apikey);
      if (key && data.provider !== 'local') headers['Authorization'] = `Bearer ${key}`;
      const r = await fetch(url, {
        method:'POST', headers,
        body:JSON.stringify({
          model:data.model,
          messages:[
            { role:'system', content:data.system },
            { role:'user', content:userMsg }
          ],
          max_tokens:500, temperature:0.7,
        }),
      });
      const j = await r.json();
      if (j.error) throw new Error(j.error.message || JSON.stringify(j.error));
      return { text: j.choices[0].message.content, model:j.model, usage:j.usage, _input:userMsg };
    }
  },

  // â”€â”€ OUTPUT â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  display: {
    name:'display', label:'Display Result', inputs:1, outputs:0,
    cls:'node-output', icon:'â—‰', iconCls:'output',
    html: nodeHtml('â—‰', 'Display Result', '<div class="node-info">Shows the final output as text</div>'),
    data:{},
    async exec(data, inputs) { return inputs; }
  },

  display_image: {
    name:'display_image', label:'Display Image', inputs:1, outputs:0,
    cls:'node-output', icon:'ðŸ–¼', iconCls:'output',
    html: nodeHtml('ðŸ–¼', 'Display Image',
      '<div class="node-info">Renders an image from URL</div><div class="node-img-container"></div>'),
    data:{},
    async exec(data, inputs) {
      const url = inputs?.image_url || inputs?.sprite_url || inputs?.thumbnail_url ||
        inputs?.flag_url || inputs?.value || inputs?.url ||
        (typeof inputs === 'string' && inputs.match(/^https?:\/\//) ? inputs : null);
      if (!url) throw new Error('No image URL found in input');
      return { image_url: url, _display: 'image' };
    }
  },

  telegram_send: {
    name:'telegram_send', label:'Telegram Send', inputs:1, outputs:0,
    cls:'node-output', icon:'âœˆ', iconCls:'output',
    html: nodeHtml('âœˆ', 'Telegram Send',
      `<label>Bot Token</label><input type="password" df-token placeholder="$tg_token or paste key" />
       <label>Chat ID</label><input type="text" df-chat_id placeholder="{chat_id}" />
       <div class="node-info">Sends text message. Uses {text} from input.</div>`),
    data:{ token:'', chat_id:'' },
    async exec(data, inputs) {
      const token = resolveConfig(data.token);
      const chatId = resolveInput(data.chat_id, inputs);
      const text = inputs?.text || inputs?.value || inputs?.joke ||
        (typeof inputs === 'string' ? inputs : JSON.stringify(inputs));
      if (!token) throw new Error('Bot token is required');
      if (!chatId) throw new Error('Chat ID is required');
      const r = await fetch(`https://api.telegram.org/bot${token}/sendMessage`, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body:JSON.stringify({ chat_id: chatId, text: text, parse_mode: 'HTML' })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.description || 'Telegram API error');
      return { sent: true, message_id: j.result.message_id, chat_id: chatId };
    }
  },

  telegram_send_image: {
    name:'telegram_send_image', label:'Telegram Send Image', inputs:1, outputs:0,
    cls:'node-output', icon:'âœˆ', iconCls:'output',
    html: nodeHtml('âœˆ', 'Telegram Send Image',
      `<label>Bot Token</label><input type="password" df-token placeholder="$tg_token or paste key" />
       <label>Chat ID</label><input type="text" df-chat_id placeholder="{chat_id}" />
       <label>Caption (optional)</label><input type="text" df-caption placeholder="{breed}" />
       <div class="node-info">Sends image by URL. Uses {image_url} from input.</div>`),
    data:{ token:'', chat_id:'', caption:'' },
    async exec(data, inputs) {
      const token = resolveConfig(data.token);
      const chatId = resolveInput(data.chat_id, inputs);
      const photo = inputs?.image_url || inputs?.sprite_url || inputs?.thumbnail_url ||
        inputs?.flag_url || inputs?.url || inputs?.value;
      const caption = resolveInput(data.caption, inputs) || '';
      if (!token) throw new Error('Bot token is required');
      if (!chatId) throw new Error('Chat ID is required');
      if (!photo) throw new Error('No image URL found in input');
      const r = await fetch(`https://api.telegram.org/bot${token}/sendPhoto`, {
        method:'POST',
        headers:{ 'Content-Type':'application/json' },
        body:JSON.stringify({ chat_id: chatId, photo: photo, caption: caption })
      });
      const j = await r.json();
      if (!j.ok) throw new Error(j.description || 'Telegram API error');
      return { sent: true, message_id: j.result.message_id, chat_id: chatId };
    }
  },

  // â”€â”€ COMPOSITION â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€

  input_port: {
    name:'input_port', label:'Input Port', inputs:0, outputs:1,
    cls:'node-compose', icon:'â†’', iconCls:'compose',
    html: nodeHtml('â†’', 'Input Port',
      `<label>Port Name</label><input type="text" df-port_name placeholder="input" />
       <div class="node-info">Entry point for a sub-graph</div>`),
    data:{ port_name:'input' },
    async exec(data, inputs) { return inputs || {}; }
  },

  output_port: {
    name:'output_port', label:'Output Port', inputs:1, outputs:0,
    cls:'node-compose', icon:'â‡¥', iconCls:'compose',
    html: nodeHtml('â‡¥', 'Output Port',
      `<label>Port Name</label><input type="text" df-port_name placeholder="output" />
       <div class="node-info">Exit point for a sub-graph</div>`),
    data:{ port_name:'output' },
    async exec(data, inputs) { return inputs || {}; }
  },
};

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  DRAG & DROP
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

document.querySelectorAll('.drag-item').forEach(item => {
  item.addEventListener('dragstart', e => {
    e.dataTransfer.setData('node-type', item.getAttribute('data-node'));
  });
});

el.addEventListener('dragover', e => e.preventDefault());

el.addEventListener('drop', e => {
  e.preventDefault();
  const type = e.dataTransfer.getData('node-type');
  if (!type || !NODE_DEFS[type]) return;
  const def = NODE_DEFS[type];
  const rect = editor.precanvas.getBoundingClientRect();
  const x = (e.clientX - rect.left) / editor.zoom;
  const y = (e.clientY - rect.top) / editor.zoom;
  editor.addNode(def.name, def.inputs, def.outputs, x, y, def.cls, {...def.data}, def.html);
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EVENT DELEGATION (buttons, toggles)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

el.addEventListener('click', function(e) {
  const btn = e.target.closest('.node-run-btn');
  if (btn) {
    e.preventDefault();
    runFlow();
  }
});

el.addEventListener('change', function(e) {
  const toggle = e.target.closest('.interval-toggle');
  if (toggle) {
    const nodeEl = toggle.closest('.drawflow-node');
    const nodeId = parseInt(nodeEl.id.replace('node-', ''));
    toggleInterval(nodeId, toggle.checked);
  }
  const tgToggle = e.target.closest('.telegram-toggle');
  if (tgToggle) {
    const nodeEl = tgToggle.closest('.drawflow-node');
    const nodeId = parseInt(nodeEl.id.replace('node-', ''));
    toggleTelegram(nodeId, tgToggle.checked);
  }
});

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  INTERVAL TRIGGER MANAGEMENT
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const activeIntervals = {}; // nodeId â†’ { handle, count }

function toggleInterval(nodeId, on) {
  const domNode = document.getElementById('node-' + nodeId);
  const statusEl = domNode?.querySelector('.interval-status');

  if (!on && activeIntervals[nodeId]) {
    clearInterval(activeIntervals[nodeId].handle);
    delete activeIntervals[nodeId];
    domNode?.classList.remove('active-trigger');
    if (statusEl) statusEl.textContent = 'stopped';
    addLog('info', `Interval (node ${nodeId}) stopped`);
    return;
  }

  if (on) {
    // Get current seconds value from Drawflow data
    const exported = editor.export();
    const node = exported.drawflow[editor.module].data[nodeId];
    if (!node) return;
    const seconds = Math.max(1, parseFloat(node.data.seconds) || 5);

    let count = 0;
    domNode?.classList.add('active-trigger');
    if (statusEl) statusEl.textContent = `running (${seconds}s)`;
    addLog('info', `Interval (node ${nodeId}) started: every ${seconds}s`);

    const handle = setInterval(async () => {
      count++;
      if (statusEl) statusEl.textContent = `tick #${count}`;
      await runFromTrigger(nodeId);
    }, seconds * 1000);

    activeIntervals[nodeId] = { handle, count };
  }
}

// Stop all intervals (e.g. when clearing)
function stopAllIntervals() {
  for (const id of Object.keys(activeIntervals)) {
    clearInterval(activeIntervals[id].handle);
    const domNode = document.getElementById('node-' + id);
    domNode?.classList.remove('active-trigger');
    const toggle = domNode?.querySelector('.interval-toggle');
    if (toggle) toggle.checked = false;
    const statusEl = domNode?.querySelector('.interval-status');
    if (statusEl) statusEl.textContent = 'stopped';
  }
  for (const k of Object.keys(activeIntervals)) delete activeIntervals[k];
  // Also stop telegram pollers
  for (const id of Object.keys(activeTelegram)) {
    clearInterval(activeTelegram[id].handle);
    const domNode = document.getElementById('node-' + id);
    domNode?.classList.remove('active-trigger');
    const toggle = domNode?.querySelector('.telegram-toggle');
    if (toggle) toggle.checked = false;
    const statusEl = domNode?.querySelector('.telegram-status');
    if (statusEl) statusEl.textContent = 'stopped';
  }
  for (const k of Object.keys(activeTelegram)) delete activeTelegram[k];
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  TELEGRAM TRIGGER POLLING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const activeTelegram = {}; // nodeId â†’ { handle, offset }

async function toggleTelegram(nodeId, on) {
  const domNode = document.getElementById('node-' + nodeId);
  const statusEl = domNode?.querySelector('.telegram-status');

  if (!on && activeTelegram[nodeId]) {
    clearInterval(activeTelegram[nodeId].handle);
    delete activeTelegram[nodeId];
    domNode?.classList.remove('active-trigger');
    if (statusEl) statusEl.textContent = 'stopped';
    addLog('info', `Telegram poller (node ${nodeId}) stopped`);
    return;
  }

  if (on) {
    const exported = editor.export();
    const node = exported.drawflow[editor.module].data[nodeId];
    if (!node) return;
    const token = resolveConfig(node.data.token);
    const seconds = Math.max(1, parseFloat(node.data.seconds) || 3);

    if (!token) {
      addLog('err', 'Telegram Trigger: bot token is required');
      const toggle = domNode?.querySelector('.telegram-toggle');
      if (toggle) toggle.checked = false;
      return;
    }

    let offset = 0;
    let msgCount = 0;
    domNode?.classList.add('active-trigger');
    if (statusEl) statusEl.textContent = `polling (${seconds}s)`;
    addLog('info', `Telegram poller (node ${nodeId}) started: every ${seconds}s`);

    const poll = async () => {
      try {
        const url = `https://api.telegram.org/bot${token}/getUpdates?offset=${offset}&timeout=0&limit=10`;
        const r = await fetch(url);
        const j = await r.json();
        if (!j.ok) { addLog('err', `Telegram: ${j.description}`); return; }

        for (const update of j.result) {
          offset = update.update_id + 1;
          const msg = update.message;
          if (!msg) continue;
          msgCount++;
          if (statusEl) statusEl.textContent = `msg #${msgCount}`;

          const msgData = {
            text: msg.text || '',
            chat_id: msg.chat.id,
            from: msg.from?.first_name || msg.from?.username || 'unknown',
            message_id: msg.message_id,
            username: msg.from?.username || '',
            date: msg.date,
          };

          // Execute downstream flow with this message as data
          const allNodes = editor.export().drawflow[editor.module].data;
          await executeGraph([nodeId], allNodes, { [nodeId]: msgData }, 0);
          refreshVarsPanel();
        }
      } catch(e) {
        addLog('err', `Telegram poll error: ${e.message}`);
      }
    };

    // Initial poll
    poll();
    const handle = setInterval(poll, seconds * 1000);
    activeTelegram[nodeId] = { handle, offset };
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOGGING
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

let logN = 0;
function addLog(tag, msg, detail) {
  const body = document.getElementById('logBody');
  const empty = body.querySelector('.log-empty');
  if (empty) empty.remove();
  const id = 'flog-' + (logN++);
  const dId = id + '-d';
  let html = `<div class="log-entry">`;
  html += `<span class="log-time">${timeStr()}</span>`;
  html += `<span class="log-tag ${tag}">${tag.toUpperCase()}</span>`;
  html += `<span class="log-text">${msg}</span>`;
  if (detail !== undefined) {
    html += `<span class="log-toggle" onclick="let d=document.getElementById('${dId}'),t=this;if(d.classList.toggle('show')){t.textContent='â–¾ details'}else{t.textContent='â–¸ details'}">â–¸ details</span>`;
    html += `<div class="log-detail" id="${dId}">${esc(typeof detail==='string'?detail:JSON.stringify(detail,null,2))}</div>`;
  }
  html += `</div>`;
  body.insertAdjacentHTML('beforeend', html);
  body.scrollTop = body.scrollHeight;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOG TABS + VARIABLE INSPECTOR
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function switchLogTab(tab) {
  document.querySelectorAll('.log-tab').forEach(t => t.classList.toggle('active', t.dataset.tab === tab));
  document.querySelectorAll('.log-tab-content').forEach(c => c.classList.toggle('active', c.dataset.tab === tab));
  if (tab === 'vars') refreshVarsPanel();
}

function refreshVarsPanel() {
  const body = document.getElementById('varsBody');
  const keys = Object.keys(flowVars);
  if (!keys.length) {
    body.innerHTML = '<div class="log-empty">No variables set yet. Use a Set Variable node to store values.</div>';
    return;
  }
  let html = '<table class="var-table"><tr><th>Name</th><th>Type</th><th>Value</th></tr>';
  for (const key of keys.sort()) {
    const val = flowVars[key];
    const type = val === null ? 'null' : Array.isArray(val) ? 'array' : typeof val;
    let display;
    if (typeof val === 'string') display = esc(val.length > 100 ? val.slice(0, 100) + 'â€¦' : val);
    else if (typeof val === 'object' && val !== null) display = esc(JSON.stringify(val).slice(0, 120));
    else display = esc(String(val));
    html += `<tr><td>${esc(key)}</td><td>${type}</td><td>${display}</td></tr>`;
  }
  html += '</table>';
  body.innerHTML = html;
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CONFIG / SECRETS STORE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const flowConfig = {};

function addConfigEntry(key = '', val = '') {
  const container = document.getElementById('configEntries');
  const row = document.createElement('div');
  row.className = 'config-row';
  const keyInput = document.createElement('input');
  keyInput.className = 'config-key';
  keyInput.placeholder = 'name';
  keyInput.value = key;
  keyInput.spellcheck = false;
  keyInput.addEventListener('input', syncConfig);

  const valInput = document.createElement('input');
  valInput.className = 'config-val config-secret';
  valInput.type = 'password';
  valInput.placeholder = 'value';
  valInput.value = val;
  valInput.spellcheck = false;
  valInput.addEventListener('input', syncConfig);

  const eye = document.createElement('div');
  eye.className = 'config-eye';
  eye.textContent = 'ðŸ‘';
  eye.title = 'Show/hide value';
  eye.addEventListener('click', () => {
    valInput.type = valInput.type === 'password' ? 'text' : 'password';
  });

  const del = document.createElement('div');
  del.className = 'config-del';
  del.textContent = 'âœ•';
  del.title = 'Remove';
  del.addEventListener('click', () => { row.remove(); syncConfig(); });

  row.appendChild(keyInput);
  row.appendChild(valInput);
  row.appendChild(eye);
  row.appendChild(del);
  container.appendChild(row);
  keyInput.focus();
}

function syncConfig() {
  // Clear and rebuild from DOM
  for (const k of Object.keys(flowConfig)) delete flowConfig[k];
  document.querySelectorAll('.config-row').forEach(row => {
    const key = row.querySelector('.config-key')?.value.trim();
    const val = row.querySelector('.config-val')?.value || '';
    if (key) flowConfig[key] = val;
  });
}

// Resolve $name references in a string from flowConfig
function resolveConfig(str) {
  if (!str || typeof str !== 'string') return str;
  return str.replace(/\$([a-zA-Z_][a-zA-Z0-9_]*)/g, (match, name) => {
    return flowConfig[name] !== undefined ? flowConfig[name] : match;
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXECUTION ENGINE v2
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
//  Supports: If routing (_route), ForEach
//  iteration (_forEach), and future sub-graph
//  execution (_composite).
//
//  Core function: executeGraph() runs BFS
//  from given start nodes through a graph.
//  ForEach calls executeGraph() recursively.

function clearRunState() {
  document.querySelectorAll('.drawflow-node').forEach(el => {
    el.classList.remove('running','done','error');
    const res = el.querySelector('.node-result');
    if (res) { res.remove(); editor.updateConnectionNodes(el.id); }
    const imgC = el.querySelector('.node-img-container');
    if (imgC) imgC.innerHTML = '';
  });
}

function showNodeResult(nodeId, result) {
  const domNode = document.getElementById('node-' + nodeId);
  if (!domNode) return;
  domNode.classList.remove('running');
  domNode.classList.add('done');

  // For display_image, render actual image
  if (result?._display === 'image' && result.image_url) {
    const imgContainer = domNode.querySelector('.node-img-container');
    if (imgContainer) {
      const img = document.createElement('img');
      img.src = result.image_url;
      img.alt = 'result';
      imgContainer.innerHTML = '';
      imgContainer.appendChild(img);
      img.onload = () => editor.updateConnectionNodes('node-' + nodeId);
    }
  }

  // Build full result text (no truncation)
  let fullText = '';
  if (result?._display === 'image') fullText = `ðŸ–¼ ${result.image_url.split('/').pop()}`;
  else if (result?.image_url) fullText = `ðŸ–¼ ${result.breed || result.name || 'image'}`;
  else if (result?.text) fullText = result.text;
  else if (result?.value !== undefined) fullText = String(result.value);
  else if (result?.joke) fullText = result.joke;
  else {
    // Pretty-print JSON, filtering out internal _ keys
    const clean = {};
    for (const [k,v] of Object.entries(result || {})) {
      if (!k.startsWith('_')) clean[k] = v;
    }
    fullText = JSON.stringify(clean, null, 2);
  }

  // Remove old result strip if any
  const old = domNode.querySelector('.node-result');
  if (old) old.remove();

  const strip = document.createElement('div');
  strip.className = 'node-result ok';
  strip.textContent = fullText;
  strip.addEventListener('click', function(e) {
    e.stopPropagation();
    this.classList.toggle('expanded');
    editor.updateConnectionNodes('node-' + nodeId);
  });
  domNode.querySelector('.drawflow_content_node').appendChild(strip);
  editor.updateConnectionNodes('node-' + nodeId);
}

function showNodeError(nodeId, error) {
  const domNode = document.getElementById('node-' + nodeId);
  if (!domNode) return;
  domNode.classList.remove('running');
  domNode.classList.add('error');
  const old = domNode.querySelector('.node-result');
  if (old) old.remove();
  const strip = document.createElement('div');
  strip.className = 'node-result err';
  strip.textContent = error.message;
  strip.addEventListener('click', function(e) {
    e.stopPropagation();
    this.classList.toggle('expanded');
    editor.updateConnectionNodes('node-' + nodeId);
  });
  domNode.querySelector('.drawflow_content_node').appendChild(strip);
  editor.updateConnectionNodes('node-' + nodeId);
}

// Get downstream node IDs for specific output ports
function getDownstream(node, outputFilter) {
  const outs = outputFilter || node.outputs;
  const ids = [];
  for (const [outKey, outPort] of Object.entries(outs || {})) {
    for (const conn of (outPort?.connections || [])) {
      ids.push(parseInt(conn.node));
    }
  }
  return ids;
}

async function executeGraph(startNodeIds, graphNodes, parentResults = {}, depth = 0) {
  if (depth > 50) { addLog('err', 'Execution depth limit reached (possible cycle)'); return parentResults; }

  const results = { ...parentResults };
  const queue = [...startNodeIds];
  const visited = new Set();
  let loopGuard = 0;
  const maxIter = Object.keys(graphNodes).length * 3 + 100;

  while (queue.length && loopGuard++ < maxIter) {
    const nodeId = queue.shift();
    if (visited.has(nodeId)) continue;

    const node = graphNodes[nodeId];
    if (!node) continue;

    // Check all input nodes are resolved
    const inputConnections = Object.values(node.inputs || {}).flatMap(inp => inp.connections.map(c => parseInt(c.node)));
    const allInputsReady = inputConnections.every(id => visited.has(id) || results[id] !== undefined);
    if (!allInputsReady) {
      queue.push(nodeId);
      continue;
    }

    visited.add(nodeId);
    const def = NODE_DEFS[node.name];
    if (!def) { addLog('err', `Unknown node type: ${node.name}`); continue; }

    // Merge input data from connected nodes
    let inputData = null;
    if (inputConnections.length === 1) {
      inputData = results[inputConnections[0]];
    } else if (inputConnections.length > 1) {
      inputData = {};
      for (const id of inputConnections) Object.assign(inputData, results[id] || {});
    }

    const nodeData = { ...node.data };
    const domNode = document.getElementById('node-' + nodeId);
    if (domNode) domNode.classList.add('running');

    if (depth === 0) addLog('run', `Executing <strong>${def.label}</strong> (node ${nodeId})`, inputData);

    try {
      const result = await def.exec(nodeData, inputData);
      results[nodeId] = result;
      showNodeResult(nodeId, result);
      if (depth === 0) addLog('data', `${def.label} â†’ done`, result);

      // â”€â”€â”€ ForEach: iterate and run downstream per item â”€â”€â”€
      if (result?._forEach) {
        const items = result._forEach;
        addLog('info', `ForEach: iterating ${items.length} items`);
        const downIds = getDownstream(node, node.outputs);

        for (let i = 0; i < items.length; i++) {
          const itemData = { value: items[i], index: i, count: items.length };
          // If item is an object, spread its properties too
          if (items[i] && typeof items[i] === 'object' && !Array.isArray(items[i])) {
            Object.assign(itemData, items[i]);
          }
          const itemResults = { ...results, [nodeId]: itemData };
          await executeGraph(downIds, graphNodes, itemResults, depth + 1);
        }
        // Don't propagate normally â€” ForEach handled its own downstream
        continue;
      }

      // â”€â”€â”€ If: only propagate through matching output â”€â”€â”€
      if (result?._route) {
        const routeKey = 'output_' + result._route;
        const filteredOutputs = {};
        if (node.outputs[routeKey]) filteredOutputs[routeKey] = node.outputs[routeKey];
        const downIds = getDownstream(node, filteredOutputs);
        for (const nextId of downIds) {
          if (!visited.has(nextId)) queue.push(nextId);
        }
        continue;
      }

      // â”€â”€â”€ Normal propagation â”€â”€â”€
      const downIds = getDownstream(node, node.outputs);
      for (const nextId of downIds) {
        if (!visited.has(nextId)) queue.push(nextId);
      }

    } catch (e) {
      showNodeError(nodeId, e);
      addLog('err', `${def.label} failed: ${esc(e.message)}`);
      // Don't propagate on error
    }
  }

  return results;
}

async function runFlow() {
  const exported = editor.export();
  const nodes = exported.drawflow[editor.module].data;

  clearRunState();
  document.getElementById('runStatus').textContent = 'running...';
  document.getElementById('runStatus').style.color = 'var(--green)';
  addLog('info', 'Flow execution started');

  // Find all trigger nodes
  const triggerNames = ['manual_trigger', 'interval_trigger', 'telegram_trigger'];
  const triggers = Object.values(nodes).filter(n => triggerNames.includes(n.name));
  if (!triggers.length) {
    addLog('err', 'No trigger node found. Add a Manual Trigger to start your flow.');
    document.getElementById('runStatus').textContent = 'error';
    document.getElementById('runStatus').style.color = 'var(--red)';
    return;
  }

  const startIds = triggers.map(n => n.id);
  const results = await executeGraph(startIds, nodes);
  const executed = Object.keys(results).length;

  document.getElementById('runStatus').textContent = 'done';
  document.getElementById('runStatus').style.color = 'var(--cyan)';
  addLog('info', `Flow complete. ${executed} nodes executed.`);
  refreshVarsPanel();
}

// Run flow starting from a specific trigger node (for intervals)
async function runFromTrigger(triggerId) {
  const exported = editor.export();
  const nodes = exported.drawflow[editor.module].data;
  if (!nodes[triggerId]) return;

  // Only clear state for downstream nodes, not the whole canvas
  clearRunState();
  addLog('info', `Interval tick â†’ running from node ${triggerId}`);

  await executeGraph([triggerId], nodes);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXAMPLE FLOW
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXAMPLE GALLERY
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const EXAMPLES = [
  {
    name: 'Dog Breed Explorer',
    icon: 'ðŸ•',
    desc: 'Fetch a random dog, extract the breed, generate a fun fact with an LLM, and display the photo alongside.',
    tags: ['API', 'Extract', 'Template', 'Fan-out', 'Image'],
    build() {
      const t = editor.addNode('manual_trigger',0,1,60,180,'node-trigger',{},NODE_DEFS.manual_trigger.html);
      const dog = editor.addNode('dog_random',1,1,300,140,'node-api',{},NODE_DEFS.dog_random.html);
      const ext = editor.addNode('extract_field',1,1,560,60,'node-transform',{field:'breed'},NODE_DEFS.extract_field.html);
      const img = editor.addNode('display_image',1,0,560,280,'node-output',{},NODE_DEFS.display_image.html);
      const tpl = editor.addNode('template',1,1,820,60,'node-transform',{template:'Tell me a fun fact about {value} dogs. One sentence.'},NODE_DEFS.template.html);
      const disp = editor.addNode('display',1,0,820,280,'node-output',{},NODE_DEFS.display.html);
      editor.addConnection(t,dog,'output_1','input_1');
      editor.addConnection(dog,ext,'output_1','input_1');
      editor.addConnection(dog,img,'output_1','input_1');
      editor.addConnection(ext,tpl,'output_1','input_1');
      editor.addConnection(tpl,disp,'output_1','input_1');
      syncFields({[ext]:{'[df-field]':'breed'},[tpl]:{'[df-template]':'Tell me a fun fact about {value} dogs. One sentence.'}});
    }
  },
  {
    name: 'PokÃ©mon Card',
    icon: 'âš¡',
    desc: 'Look up a PokÃ©mon, format its stats into a card layout, and display its sprite.',
    tags: ['PokÃ©API', 'Template', 'Fan-out', 'Image'],
    build() {
      const t = editor.addNode('manual_trigger',0,1,60,160,'node-trigger',{},NODE_DEFS.manual_trigger.html);
      const poke = editor.addNode('pokeapi',1,1,300,120,'node-api',{pokemon:'charizard'},NODE_DEFS.pokeapi.html);
      const tpl = editor.addNode('template',1,1,560,60,'node-transform',{template:'#{pokedex_id} {name}\nTypes: {types}\nHP: {hp} | ATK: {attack} | DEF: {defense}\nSpeed: {speed} | Weight: {weight}'},NODE_DEFS.template.html);
      const img = editor.addNode('display_image',1,0,560,300,'node-output',{},NODE_DEFS.display_image.html);
      const disp = editor.addNode('display',1,0,820,60,'node-output',{},NODE_DEFS.display.html);
      editor.addConnection(t,poke,'output_1','input_1');
      editor.addConnection(poke,tpl,'output_1','input_1');
      editor.addConnection(poke,img,'output_1','input_1');
      editor.addConnection(tpl,disp,'output_1','input_1');
      syncFields({[poke]:{'[df-pokemon]':'charizard'},[tpl]:{'[df-template]':'#{pokedex_id} {name}\nTypes: {types}\nHP: {hp} | ATK: {attack} | DEF: {defense}\nSpeed: {speed} | Weight: {weight}'}});
    }
  },
  {
    name: 'Weather Router',
    icon: 'ðŸŒ¤',
    desc: 'Fetch weather and take different paths based on temperature â€” hot vs cold, each with its own message.',
    tags: ['Weather', 'If', 'Branching', 'Template'],
    build() {
      const t = editor.addNode('manual_trigger',0,1,60,200,'node-trigger',{},NODE_DEFS.manual_trigger.html);
      const wx = editor.addNode('open_meteo',1,1,300,180,'node-api',{lat:'-19.92',lon:'-43.94'},NODE_DEFS.open_meteo.html);
      const ifn = editor.addNode('if_node',1,2,560,180,'node-transform',{field:'temperature',operator:'gt',compare:'25'},NODE_DEFS.if_node.html);
      const hot = editor.addNode('template',1,1,820,80,'node-transform',{template:'ðŸ”¥ {temperature}{unit} â€” Hot! {description}'},NODE_DEFS.template.html);
      const cold = editor.addNode('template',1,1,820,310,'node-transform',{template:'â„ï¸ {temperature}{unit} â€” Cool! {description}'},NODE_DEFS.template.html);
      const d1 = editor.addNode('display',1,0,1060,80,'node-output',{},NODE_DEFS.display.html);
      const d2 = editor.addNode('display',1,0,1060,310,'node-output',{},NODE_DEFS.display.html);
      editor.addConnection(t,wx,'output_1','input_1');
      editor.addConnection(wx,ifn,'output_1','input_1');
      editor.addConnection(ifn,hot,'output_1','input_1');
      editor.addConnection(ifn,cold,'output_2','input_1');
      editor.addConnection(hot,d1,'output_1','input_1');
      editor.addConnection(cold,d2,'output_1','input_1');
      syncFields({[wx]:{'[df-lat]':'-19.92','[df-lon]':'-43.94'},[ifn]:{'[df-field]':'temperature','[df-operator]':'gt','[df-compare]':'25'},[hot]:{'[df-template]':'ðŸ”¥ {temperature}{unit} â€” Hot! {description}'},[cold]:{'[df-template]':'â„ï¸ {temperature}{unit} â€” Cool! {description}'}});
    }
  },
  {
    name: 'Hound Census',
    icon: 'ðŸ”„',
    desc: 'Fetch all hound sub-breeds from the Dog CEO API, then loop through each one and display them individually.',
    tags: ['HTTP GET', 'Extract', 'ForEach', 'Template'],
    build() {
      const t = editor.addNode('manual_trigger',0,1,60,160,'node-trigger',{},NODE_DEFS.manual_trigger.html);
      const http = editor.addNode('http_get',1,1,300,140,'node-api',{url:'https://dog.ceo/api/breed/hound/list'},NODE_DEFS.http_get.html);
      const ext = editor.addNode('extract_field',1,1,560,140,'node-transform',{field:'message'},NODE_DEFS.extract_field.html);
      const fe = editor.addNode('for_each',1,1,800,140,'node-transform',{field:''},NODE_DEFS.for_each.html);
      const tpl = editor.addNode('template',1,1,1040,100,'node-transform',{template:'ðŸ• Hound #{index}: {value}'},NODE_DEFS.template.html);
      const disp = editor.addNode('display',1,0,1040,280,'node-output',{},NODE_DEFS.display.html);
      editor.addConnection(t,http,'output_1','input_1');
      editor.addConnection(http,ext,'output_1','input_1');
      editor.addConnection(ext,fe,'output_1','input_1');
      editor.addConnection(fe,tpl,'output_1','input_1');
      editor.addConnection(tpl,disp,'output_1','input_1');
      syncFields({[http]:{'[df-url]':'https://dog.ceo/api/breed/hound/list'},[ext]:{'[df-field]':'message'},[tpl]:{'[df-template]':'ðŸ• Hound #{index}: {value}'}});
    }
  },
  {
    name: 'Country Factbook',
    icon: 'ðŸŒ',
    desc: 'Look up a country, display its flag alongside formatted facts including population, capital, and languages.',
    tags: ['REST Countries', 'Code', 'Template', 'Image'],
    build() {
      const t = editor.addNode('manual_trigger',0,1,60,180,'node-trigger',{},NODE_DEFS.manual_trigger.html);
      const rc = editor.addNode('rest_countries',1,1,300,140,'node-api',{country:'brazil'},NODE_DEFS.rest_countries.html);
      const code = editor.addNode('code_node',1,1,560,60,'node-transform',{code:'data.pop_millions = (data.population / 1e6).toFixed(1) + \"M\";'},NODE_DEFS.code_node.html);
      const img = editor.addNode('display_image',1,0,560,300,'node-output',{},NODE_DEFS.display_image.html);
      const tpl = editor.addNode('template',1,1,820,60,'node-transform',{template:'ðŸŒ {name} ({code})\nCapital: {capital}\nPopulation: {pop_millions}\nRegion: {region} / {subregion}\nLanguages: {languages}'},NODE_DEFS.template.html);
      const disp = editor.addNode('display',1,0,1060,60,'node-output',{},NODE_DEFS.display.html);
      editor.addConnection(t,rc,'output_1','input_1');
      editor.addConnection(rc,code,'output_1','input_1');
      editor.addConnection(rc,img,'output_1','input_1');
      editor.addConnection(code,tpl,'output_1','input_1');
      editor.addConnection(tpl,disp,'output_1','input_1');
      syncFields({[rc]:{'[df-country]':'brazil'},[tpl]:{'[df-template]':'ðŸŒ {name} ({code})\nCapital: {capital}\nPopulation: {pop_millions}\nRegion: {region} / {subregion}\nLanguages: {languages}'}});
      syncCodeField(code, 'data.pop_millions = (data.population / 1e6).toFixed(1) + "M";');
    }
  },
  {
    name: 'Wikipedia Pipeline',
    icon: 'ðŸ“š',
    desc: 'Chain two APIs: fetch a random dog breed, then look it up on Wikipedia and display the summary with thumbnail.',
    tags: ['Dog CEO', 'Wikipedia', 'Extract', 'Chaining', 'Image'],
    build() {
      const t = editor.addNode('manual_trigger',0,1,60,180,'node-trigger',{},NODE_DEFS.manual_trigger.html);
      const dog = editor.addNode('dog_random',1,1,300,160,'node-api',{},NODE_DEFS.dog_random.html);
      const wiki = editor.addNode('wikipedia',1,1,560,160,'node-api',{topic:'{breed}'},NODE_DEFS.wikipedia.html);
      const tpl = editor.addNode('template',1,1,820,80,'node-transform',{template:'ðŸ“– {title}\n\n{summary}'},NODE_DEFS.template.html);
      const img = editor.addNode('display_image',1,0,820,320,'node-output',{},NODE_DEFS.display_image.html);
      const disp = editor.addNode('display',1,0,1060,80,'node-output',{},NODE_DEFS.display.html);
      editor.addConnection(t,dog,'output_1','input_1');
      editor.addConnection(dog,wiki,'output_1','input_1');
      editor.addConnection(wiki,tpl,'output_1','input_1');
      editor.addConnection(wiki,img,'output_1','input_1');
      editor.addConnection(tpl,disp,'output_1','input_1');
      syncFields({[wiki]:{'[df-topic]':'{breed}'},[tpl]:{'[df-template]':'ðŸ“– {title}\n\n{summary}'}});
    }
  },
];

// Helper: sync Drawflow data fields with DOM inputs
function syncFields(nodeFieldMap) {
  setTimeout(() => {
    for (const [nodeId, fields] of Object.entries(nodeFieldMap)) {
      for (const [selector, value] of Object.entries(fields)) {
        const el = document.querySelector(`#node-${nodeId} ${selector}`);
        if (el) {
          el.value = value;
          el.dispatchEvent(new Event('input', {bubbles:true}));
          if (el.tagName === 'SELECT') el.dispatchEvent(new Event('change', {bubbles:true}));
        }
      }
    }
  }, 50);
}

function syncCodeField(nodeId, code) {
  setTimeout(() => {
    const el = document.querySelector(`#node-${nodeId} [df-code]`);
    if (el) { el.value = code; el.dispatchEvent(new Event('input')); }
  }, 50);
}

function showExamples() {
  const list = document.getElementById('exampleList');
  list.innerHTML = EXAMPLES.map((ex, i) => `
    <div class="example-card" onclick="loadExampleByIndex(${i})">
      <div class="example-card-icon">${ex.icon}</div>
      <div class="example-card-info">
        <div class="example-card-name">${ex.name}</div>
        <div class="example-card-desc">${ex.desc}</div>
        <div class="example-card-tags">${ex.tags.map(t => `<span class="example-tag">${t}</span>`).join('')}</div>
      </div>
    </div>
  `).join('');
  document.getElementById('exampleOverlay').classList.add('show');
}

function closeExamples() {
  document.getElementById('exampleOverlay').classList.remove('show');
}

function canvasHasNodes() {
  const exported = editor.export();
  const mod = exported.drawflow[editor.module]?.data || {};
  return Object.keys(mod).length > 0;
}

async function loadExampleByIndex(i) {
  closeExamples();
  // Dismiss splash if still showing
  const splash = document.getElementById('splash');
  if (splash) {
    splash.classList.add('hidden');
    setTimeout(() => splash.remove(), 500);
    document.getElementById('guideToggle').style.display = '';
  }
  if (canvasHasNodes()) {
    const name = await showModal('Current flow will be replaced. Type "ok" to confirm, or cancel:', '');
    if (!name || name.trim().toLowerCase() !== 'ok') return;
  }
  stopAllIntervals();
  editor.clear();
  for (const k of Object.keys(flowVars)) delete flowVars[k];
  EXAMPLES[i].build();
  addLog('info', `Loaded example: ${EXAMPLES[i].name}`);
  injectResizeHandles();
}

async function confirmClear() {
  if (canvasHasNodes()) {
    const name = await showModal('Clear everything? Type "ok" to confirm:', '');
    if (!name || name.trim().toLowerCase() !== 'ok') return;
  }
  clearFlow();
}

function clearFlow() {
  stopAllIntervals();
  editor.clear();
  for (const k of Object.keys(flowVars)) delete flowVars[k];
  document.getElementById('logBody').innerHTML = '<div class="log-empty">Build a flow and hit Run to see execution here.</div>';
  document.getElementById('runStatus').textContent = 'idle';
  document.getElementById('runStatus').style.color = 'var(--text-faint)';
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  PROJECT MANAGEMENT (localStorage)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const STORAGE_KEY = 'flow-workshop-projects';

function getProjects() {
  try { return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); }
  catch { return {}; }
}

function buildWorkspaceData(name) {
  const customNodes = [];
  for (const [defName, def] of Object.entries(NODE_DEFS)) {
    if (def._sourceModule) {
      customNodes.push({ defName, label: def.label, module: def._sourceModule });
    }
  }
  return {
    version: 1,
    name,
    timestamp: new Date().toISOString(),
    drawflow: editor.export(),
    customNodes,
    variables: JSON.parse(JSON.stringify(flowVars)),
    configKeys: Object.keys(flowConfig),
    chapterProgress: [...chapterDone],
    currentChapter,
  };
}

async function saveProject() {
  stopAllIntervals();
  const projects = getProjects();
  const keys = Object.keys(projects);

  // If there's a current project name, offer to overwrite
  const defaultName = window._currentProjectName || ('Project ' + (keys.length + 1));
  const name = await showModal('Save project as:', defaultName);
  if (!name || !name.trim()) return;

  const ws = buildWorkspaceData(name.trim());
  projects[name.trim()] = ws;

  try {
    localStorage.setItem(STORAGE_KEY, JSON.stringify(projects));
    window._currentProjectName = name.trim();
    addLog('info', `ðŸ’¾ Saved project "${name.trim()}" (${ws.customNodes.length} custom node(s))`);
  } catch(e) {
    addLog('err', `Save failed: ${e.message}. LocalStorage may be full.`);
  }
}

function loadProject(name) {
  const projects = getProjects();
  const ws = projects[name];
  if (!ws) { addLog('err', `Project "${name}" not found`); return; }
  restoreWorkspace(ws);
  window._currentProjectName = name;
  addLog('info', `ðŸ“‚ Loaded project "${name}". Re-enter secret values in Config tab.`);
}

function deleteProject(name) {
  const projects = getProjects();
  delete projects[name];
  localStorage.setItem(STORAGE_KEY, JSON.stringify(projects));
  renderSplashProjects();
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  EXPORT / IMPORT (file)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function exportWorkspace() {
  stopAllIntervals();
  const ws = buildWorkspaceData('export');
  const blob = new Blob([JSON.stringify(ws, null, 2)], { type: 'application/json' });
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  const ts = new Date().toISOString().slice(0,16).replace(/[T:]/g, '-');
  a.download = 'flow-workshop-' + ts + '.flow.json';
  a.click();
  URL.revokeObjectURL(url);
  addLog('info', 'â†— Exported workspace to file');
}

function importWorkspace(event) {
  const file = event.target.files[0];
  if (!file) return;
  event.target.value = '';
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const ws = JSON.parse(e.target.result);
      if (!ws.drawflow) throw new Error('Invalid workspace file');
      restoreWorkspace(ws);
      addLog('info', `â†™ Imported "${file.name}". Re-enter secret values in Config tab.`);
    } catch(err) {
      addLog('err', `Import failed: ${err.message}`);
    }
  };
  reader.readAsText(file);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WORKSPACE RESTORE (shared by load + import)
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function restoreWorkspace(ws) {
  stopAllIntervals();

  // Clear existing custom nodes
  const customList = document.getElementById('customNodesList');
  customList.innerHTML = '';
  document.getElementById('customNodesSection').style.display = 'none';
  for (const key of Object.keys(NODE_DEFS)) {
    if (key.startsWith('custom_')) delete NODE_DEFS[key];
  }

  // Import drawflow state
  editor.import(ws.drawflow);
  refreshTabs();
  injectResizeHandles();

  // Recreate custom nodes
  if (ws.customNodes) {
    for (const cn of ws.customNodes) {
      registerCustomNode(cn.defName, cn.label, cn.module);
    }
  }

  // Restore variables
  for (const k of Object.keys(flowVars)) delete flowVars[k];
  if (ws.variables) Object.assign(flowVars, ws.variables);
  refreshVarsPanel();

  // Restore config keys (values blanked)
  const configEntries = document.getElementById('configEntries');
  configEntries.innerHTML = '';
  for (const k of Object.keys(flowConfig)) delete flowConfig[k];
  if (ws.configKeys) {
    for (const key of ws.configKeys) addConfigEntry(key, '');
  }

  // Restore chapter progress
  if (ws.chapterProgress) {
    ws.chapterProgress.forEach((done, i) => {
      if (i < chapterDone.length) chapterDone[i] = done;
    });
  }
  if (typeof ws.currentChapter === 'number' && ws.currentChapter < CHAPTERS.length) {
    currentChapter = ws.currentChapter;
  }
  renderGuide();
}

// Register a custom node from a module (non-interactive, for load/import)
function registerCustomNode(cleanName, label, mod) {
  const graph = editor.drawflow.drawflow[mod]?.data;
  if (!graph) return;
  const nodes = Object.values(graph);
  const inputPorts = nodes.filter(n => n.name === 'input_port');
  const outputPorts = nodes.filter(n => n.name === 'output_port');
  const numInputs = inputPorts.length || 1;
  const numOutputs = outputPorts.length || 1;
  const portInfo = [
    ...inputPorts.map((p,i) => `â†’ ${p.data.port_name || 'in_'+(i+1)}`),
    ...outputPorts.map((p,i) => `â‡¥ ${p.data.port_name || 'out_'+(i+1)}`)
  ].join(' ');

  NODE_DEFS[cleanName] = {
    name: cleanName, label,
    inputs: numInputs, outputs: numOutputs,
    cls: 'node-compose', icon: 'ðŸ“¦', iconCls: 'compose',
    html: nodeHtml('ðŸ“¦', label,
      `<div class="node-info">${esc(portInfo)}</div>
       <div class="node-info" style="color:var(--pink);">Module: ${esc(mod)}</div>`),
    data: { _module: mod },
    _sourceModule: mod,
    async exec(data, inputs) {
      const subGraph = editor.drawflow.drawflow[data._module]?.data;
      if (!subGraph) throw new Error(`Module "${data._module}" not found`);
      const subNodes = JSON.parse(JSON.stringify(subGraph));
      const inPorts = Object.values(subNodes).filter(n => n.name === 'input_port')
        .sort((a,b) => a.id - b.id);
      const subResults = {};
      inPorts.forEach((port) => { subResults[port.id] = inputs || {}; });
      const startIds = inPorts.map(p => p.id);
      const subTriggers = Object.values(subNodes).filter(n =>
        n.name === 'manual_trigger' || n.name === 'interval_trigger');
      startIds.push(...subTriggers.map(t => t.id));
      if (!startIds.length) {
        for (const n of Object.values(subNodes)) {
          const hasInput = Object.values(n.inputs || {}).some(inp => inp.connections.length > 0);
          if (!hasInput) startIds.push(n.id);
        }
      }
      const results = await executeGraph(startIds, subNodes, subResults, 1);
      const outPorts = Object.values(subNodes).filter(n => n.name === 'output_port')
        .sort((a,b) => a.id - b.id);
      if (outPorts.length === 1) return results[outPorts[0].id] || {};
      if (outPorts.length > 1) {
        const combined = {};
        outPorts.forEach(p => Object.assign(combined, results[p.id] || {}));
        return combined;
      }
      return {};
    }
  };

  addCustomNodeToSidebar(cleanName, label);
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SPLASH PROJECT LIST
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function renderSplashProjects() {
  const container = document.getElementById('splashProjects');
  if (!container) return;
  const projects = getProjects();
  const keys = Object.keys(projects);
  if (!keys.length) { container.innerHTML = ''; return; }

  // Sort by timestamp descending
  keys.sort((a, b) => (projects[b].timestamp || '').localeCompare(projects[a].timestamp || ''));

  let html = '<div class="splash-projects"><div class="splash-projects-title">Saved Projects</div>';
  for (const key of keys) {
    const p = projects[key];
    const date = p.timestamp ? new Date(p.timestamp) : null;
    const dateStr = date ? date.toLocaleDateString(undefined, { month:'short', day:'numeric', hour:'2-digit', minute:'2-digit' }) : 'â€”';
    const modules = p.drawflow?.drawflow ? Object.keys(p.drawflow.drawflow).length : 0;
    const nodeCount = p.drawflow?.drawflow ? Object.values(p.drawflow.drawflow)
      .reduce((sum, m) => sum + Object.keys(m.data || {}).length, 0) : 0;
    html += `<div class="splash-project" onclick="loadProjectFromSplash('${esc(key.replace(/'/g,"\\'"))}')">
      <div class="splash-project-icon">â—ˆ</div>
      <div class="splash-project-info">
        <div class="splash-project-name">${esc(key)}</div>
        <div class="splash-project-meta">${dateStr} Â· ${nodeCount} nodes Â· ${modules} tab${modules !== 1 ? 's' : ''}</div>
      </div>
      <div class="splash-project-del" title="Delete" onclick="event.stopPropagation(); deleteProjectConfirm('${esc(key.replace(/'/g,"\\'"))}')">âœ•</div>
    </div>`;
  }
  html += '</div>';
  container.innerHTML = html;
}

function loadProjectFromSplash(name) {
  dismissSplash('explore');
  setTimeout(() => loadProject(name), 100);
}

function deleteProjectConfirm(name) {
  if (confirm(`Delete project "${name}"?`)) {
    deleteProject(name);
  }
}

// Render on init (called at bottom of script)

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  LOG PANEL RESIZE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

(function() {
  const handle = document.getElementById('logResizeHandle');
  const panel = document.getElementById('logPanel');
  let dragging = false, startY = 0, startH = 0;

  handle.addEventListener('mousedown', e => {
    dragging = true;
    startY = e.clientY;
    startH = panel.offsetHeight;
    document.body.style.cursor = 'ns-resize';
    document.body.style.userSelect = 'none';
    e.preventDefault();
  });

  document.addEventListener('mousemove', e => {
    if (!dragging) return;
    const delta = startY - e.clientY;
    const newH = Math.min(Math.max(startH + delta, 60), window.innerHeight * 0.7);
    panel.style.height = newH + 'px';
  });

  document.addEventListener('mouseup', () => {
    if (!dragging) return;
    dragging = false;
    document.body.style.cursor = '';
    document.body.style.userSelect = '';
  });
})();

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  IN-PAGE MODAL (replaces prompt())
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

function showModal(title, defaultValue = '') {
  return new Promise((resolve) => {
    const overlay = document.getElementById('modalOverlay');
    const input = document.getElementById('modalInput');
    const okBtn = document.getElementById('modalOk');
    const cancelBtn = document.getElementById('modalCancel');

    document.getElementById('modalTitle').textContent = title;
    input.value = defaultValue;
    overlay.classList.add('show');
    setTimeout(() => input.focus(), 50);

    function cleanup() {
      overlay.classList.remove('show');
      okBtn.removeEventListener('click', onOk);
      cancelBtn.removeEventListener('click', onCancel);
      input.removeEventListener('keydown', onKey);
    }
    function onOk() { cleanup(); resolve(input.value); }
    function onCancel() { cleanup(); resolve(null); }
    function onKey(e) {
      if (e.key === 'Enter') onOk();
      if (e.key === 'Escape') onCancel();
    }

    okBtn.addEventListener('click', onOk);
    cancelBtn.addEventListener('click', onCancel);
    input.addEventListener('keydown', onKey);
  });
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  SIDEBAR: SEARCH + COLLAPSE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// Collapse toggle
document.querySelectorAll('.sidebar-section-label').forEach(label => {
  label.addEventListener('click', () => {
    label.closest('.sidebar-section').classList.toggle('collapsed');
  });
});

// Search/filter
document.getElementById('nodeSearch').addEventListener('input', function() {
  const q = this.value.toLowerCase().trim();
  document.querySelectorAll('.sidebar-section').forEach(sec => {
    let anyVisible = false;
    sec.querySelectorAll('.drag-item').forEach(item => {
      const text = item.textContent.toLowerCase();
      const nodeType = item.dataset.node || '';
      const match = !q || text.includes(q) || nodeType.includes(q);
      item.classList.toggle('filtered', !match);
      if (match) anyVisible = true;
    });
    // Auto-expand sections with matches, collapse empty ones
    if (q) {
      sec.classList.toggle('collapsed', !anyVisible);
    }
    sec.style.display = (q && !anyVisible) ? 'none' : '';
  });
  // If query is empty, show all sections and restore their collapse state
  if (!q) {
    document.querySelectorAll('.sidebar-section').forEach(sec => {
      sec.style.display = '';
    });
  }
});
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  WORKSHOP GUIDE
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

const CHAPTERS = [
  // â”€â”€ CHAPTER 0 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'The Assembly Line',
    body: `
      <p>Welcome to <strong>Flow Workshop</strong> â€” the third stop in a trilogy about building things with APIs.</p>
      <p>In the <strong>API Workshop</strong> (101), you learned to talk to web services by hand â€” typing URLs, reading JSON, understanding request and response. In the <strong>Bot Workshop</strong> (201), you wrote a Telegram bot in code â€” a polling loop, command parsing, API calls, all in JavaScript.</p>
      <p>This workshop asks a different question: <strong>what if you could see the program?</strong></p>
      <div class="concept"><strong>Visual programming</strong> isn't a toy. Unreal Engine's Blueprints ship AAA games. Node-RED runs factory floors. Zapier and n8n automate businesses. ComfyUI generates art. They all share one idea: <em>data flows through a graph of connected nodes</em>.</div>
      <p>That's what you'll build here. Not by dragging pre-made templates, but by understanding the <strong>primitives</strong> â€” the small, composable pieces that all flow systems are made of:</p>
      <p><strong>Triggers</strong> that start things. <strong>API nodes</strong> that fetch data. <strong>Transforms</strong> that reshape it. <strong>Outputs</strong> that display or send it. <strong>Conditionals</strong> that route it. <strong>Loops</strong> that repeat it. <strong>Variables</strong> that remember it. And <strong>composition</strong> â€” packaging a sub-flow into a single reusable node, which is the deepest idea in all of programming.</p>
      <div class="concept"><strong>The interface:</strong>
      <br>â€¢ <strong>Left sidebar</strong> â€” your node palette. Drag nodes onto the canvas.
      <br>â€¢ <strong>Canvas</strong> â€” where you wire nodes together. Scroll to zoom, drag to pan.
      <br>â€¢ <strong>Ports</strong> â€” small circles on nodes. Drag from an output (right) to an input (left) to connect.
      <br>â€¢ <strong>Tab bar</strong> â€” modules (separate canvases). You'll use these later for composition.
      <br>â€¢ <strong>Bottom panel</strong> â€” Execution Log, Variables inspector, and Config store. Drag the top edge to resize.
      <br>â€¢ <strong>This panel</strong> â€” your guide. Progress pips at the top let you jump between chapters. Click âœ“ Check to validate your work.</div>
      <div class="concept"><strong>Keyboard shortcuts:</strong>
      <br>â€¢ <strong>Click</strong> a node or wire to select it (cyan highlight)
      <br>â€¢ <strong>Delete / Backspace</strong> removes the selected node or wire
      <br>â€¢ <strong>Right-click</strong> a node or wire to show the âœ• delete button
      <br>â€¢ <strong>Scroll</strong> to zoom in/out (zoom level shown bottom-right)
      <br>â€¢ <strong>Drag canvas</strong> to pan around</div>
      <p>Each chapter introduces one concept, explains why it matters, and gives you a hands-on task. The entire editor is available from the start â€” nothing is locked. If you want to skip ahead or explore, go for it.</p>
      <p>One last thing: every node you see in the palette is just a packaged sub-graph. By the end of this workshop, you'll be building your own. Let's start.</p>
    `,
    check() { return true; }
  },

  // â”€â”€ CHAPTER 1 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Hello, Flow',
    body: `
      <p>Every automation tool â€” Zapier, n8n, Node-RED, Unreal Blueprints â€” is built on the same idea: <strong>data flows through a graph of connected nodes</strong>. Each node does one thing, and the wires between them carry data from left to right.</p>
      <p>Think of it like a factory assembly line. Raw material enters on the left, each station does one operation, and the finished product comes out on the right.</p>
      <div class="concept"><strong>Three rules of flow:</strong>
      <br>1. Every flow starts with a <strong>trigger</strong> â€” something that says "go"
      <br>2. Data travels left â†’ right through the <strong>wires</strong>
      <br>3. Every node <strong>transforms</strong> or <strong>consumes</strong> the data it receives</div>
      <p>Let's prove it with the simplest possible flow: two nodes and one wire.</p>
      <div class="task"><strong>Do this:</strong>
      <br>1. From the left sidebar, drag a <code>Manual Trigger</code> onto the canvas
      <br>2. Drag a <code>Display Result</code> to the right of it
      <br>3. Click the <strong>small circle</strong> on the trigger's right edge (its <em>output port</em>) and drag a wire to the display's left circle (<em>input port</em>)
      <br>4. Click <strong>â–¶ Run Flow</strong> on the trigger node</div>
      <p>Watch what happens: the trigger lights up green, then the display lights up, and a result strip appears showing the data that flowed through. Open the <strong>Execution Log</strong> at the bottom and click "â–¸ details" to see the full JSON object.</p>
      <div class="hint">The trigger sent <code>{ triggered: true, timestamp: "..." }</code> â€” a small data packet. Every node produces one of these objects, and the next node downstream receives it as input.</div>
    `,
    check(nodes) {
      const has = name => Object.values(nodes).some(n => n.name === name);
      const connected = Object.values(nodes).some(n =>
        n.name === 'manual_trigger' &&
        Object.values(n.outputs).some(o => o.connections.length > 0)
      );
      if (!has('manual_trigger')) return 'Add a Manual Trigger node.';
      if (!has('display')) return 'Add a Display Result node.';
      if (!connected) return 'Connect the trigger\'s output to the display\'s input.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 2 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Talking to the Internet',
    body: `
      <p>A trigger that sends a timestamp isn't very exciting. The real power of flows is calling <strong>APIs</strong> â€” web services that return real data.</p>
      <p>An API is just a URL that, instead of returning a web page, returns structured data (JSON). When you visit <code>dog.ceo/api/breeds/image/random</code> in a browser, you get back something like:</p>
      <p><code>{ "message": "https://.../retriever.jpg", "status": "success" }</code></p>
      <p>API nodes wrap this pattern: they take optional input, make the HTTP call, parse the JSON, and pass it downstream. You don't write any code â€” just wire it in.</p>
      <div class="task"><strong>Do this:</strong>
      <br>1. Clear your canvas or start fresh
      <br>2. Place: <code>Manual Trigger</code> â†’ <code>Dog CEO: Random</code> â†’ <code>Display Result</code>
      <br>3. Wire them left to right
      <br>4. Run the flow</div>
      <div class="concept"><strong>Notice the result strip</strong> on the Dog CEO node. It returned an object with multiple fields: <code>image_url</code>, <code>breed</code>, and <code>status</code>. The Display node received this entire object.</div>
      <p>This is a key insight: <strong>data between nodes is always a JavaScript object</strong> with named fields. Each node reads the fields it needs from its input and produces a new object as output. Understanding these field names is how you wire nodes together effectively.</p>
      <div class="hint">Click "â–¸ details" in the Execution Log to see the exact object each node produced. Get in the habit of checking this â€” it tells you which field names are available for the next node.</div>
    `,
    check(nodes) {
      const trigger = Object.values(nodes).find(n => n.name === 'manual_trigger');
      const dog = Object.values(nodes).find(n => n.name === 'dog_random');
      const display = Object.values(nodes).find(n => n.name === 'display');
      if (!trigger) return 'You need a Manual Trigger.';
      if (!dog) return 'Add a Dog CEO: Random node.';
      if (!display) return 'Add a Display Result node.';
      const triggerOutputs = Object.values(trigger.outputs).flatMap(o => o.connections.map(c => c.node));
      if (!triggerOutputs.includes(String(dog?.id))) return 'Connect the Trigger to Dog CEO.';
      const dogOutputs = Object.values(dog.outputs).flatMap(o => o.connections.map(c => c.node));
      if (!dogOutputs.includes(String(display?.id))) return 'Connect Dog CEO to Display Result.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 3 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Cherry-Picking',
    body: `
      <p>The Dog CEO node returns an object with several fields. But what if the next node only needs one of them? This is where <strong>transform nodes</strong> come in â€” they sit between other nodes and reshape the data as it passes through.</p>
      <p>Think of it like a filter on a conveyor belt: the full product goes in, but only the part you need comes out the other side.</p>
      <div class="concept"><strong>Extract Field</strong> takes one specific value out of an object using a <em>field path</em>. The result is always wrapped as <code>{ value: &lt;whatever you extracted&gt; }</code> so it can flow to the next node.</div>
      <p>Field paths can be simple (<code>breed</code>) or nested (<code>data.items[0].name</code>) â€” just like accessing properties in JavaScript.</p>
      <div class="task"><strong>Do this:</strong>
      <br>1. Start from your Trigger â†’ Dog CEO â†’ Display flow
      <br>2. Insert an <code>Extract Field</code> node between Dog CEO and Display
      <br>3. Set its Field Path to <code>breed</code>
      <br>4. Rewire: Trigger â†’ Dog CEO â†’ Extract Field â†’ Display
      <br>5. Run it</div>
      <p>Before, the Display showed the whole object. Now it shows just <code>{ value: "labrador" }</code> (or whatever breed came back). You've <strong>narrowed</strong> the data flowing through the wire.</p>
      <div class="hint">Try changing the field path to <code>image_url</code> and running again â€” now you get the URL string instead of the breed. The same node, different configuration, different output.</div>
    `,
    check(nodes) {
      const ext = Object.values(nodes).find(n => n.name === 'extract_field');
      if (!ext) return 'Add an Extract Field node.';
      if (!ext.data.field || ext.data.field.trim() === '') return 'Set the Field Path (try "breed").';
      const hasConn = Object.values(ext.inputs).some(i => i.connections.length > 0);
      if (!hasConn) return 'Wire something into the Extract Field\'s input.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 4 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Mad Libs',
    body: `
      <p>Extracting a single field is useful, but often you want to <strong>combine</strong> multiple fields into something new â€” a sentence, a URL, a formatted message. That's what the <strong>Template</strong> node does.</p>
      <div class="concept"><strong>Variable interpolation:</strong> Inside a template, anything wrapped in <code>{curly braces}</code> gets replaced with the matching field from the input data. So if the input has <code>breed: "poodle"</code>, then the template <code>I love {breed} dogs!</code> becomes <code>I love poodle dogs!</code></div>
      <p>This is the same idea as template literals in JavaScript, f-strings in Python, or mail merge in a word processor. The shape of your data determines which variables are available.</p>
      <div class="task"><strong>Do this:</strong>
      <br>1. Replace the Extract Field with a <code>Template</code> node (or add one in parallel)
      <br>2. Set the template to: <code>ðŸ• Random breed: {breed}! Status: {status}</code>
      <br>3. Wire: Trigger â†’ Dog CEO â†’ Template â†’ Display
      <br>4. Run it</div>
      <p>The display should now show your formatted sentence with the actual breed and status filled in.</p>
      <div class="concept"><strong>This works in most node fields too!</strong> The "Breed" field on Dog CEO: By Breed accepts <code>{value}</code> â€” so you could have an Extract Field feeding a breed name into it. This is how you chain API calls: one node's output becomes another node's parameter.</div>
      <div class="hint">Look at the Dog CEO result in the log to see all available field names. You can use any of them: <code>{image_url}</code>, <code>{breed}</code>, <code>{status}</code>.</div>
    `,
    check(nodes) {
      const tpl = Object.values(nodes).find(n => n.name === 'template');
      if (!tpl) return 'Add a Template node.';
      if (!tpl.data.template || !tpl.data.template.includes('{')) return 'Write a template with {placeholders}.';
      const hasConn = Object.values(tpl.inputs).some(i => i.connections.length > 0);
      if (!hasConn) return 'Wire data into the Template\'s input.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 5 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Branching Out',
    body: `
      <p>Until now, every flow has been a straight line: A â†’ B â†’ C. But data doesn't have to flow to just one place. A single output port can connect to <strong>multiple</strong> downstream nodes.</p>
      <div class="concept"><strong>Fan-out:</strong> When a node has wires going to two or more nodes, each downstream node receives a <em>copy</em> of the same data. They run independently â€” like photocopying a document and sending it to different departments.</div>
      <p>This is incredibly useful. An API returns both text data and an image URL â€” why not display both?</p>
      <div class="task"><strong>Do this:</strong>
      <br>1. Build: <code>Trigger</code> â†’ <code>Dog CEO: Random</code>
      <br>2. From Dog CEO, draw <strong>two wires</strong>:
      <br>&nbsp;&nbsp;&nbsp;â€¢ one to a <code>Template</code> â†’ <code>Display Result</code> (for the breed text)
      <br>&nbsp;&nbsp;&nbsp;â€¢ one to a <code>Display Image</code> (for the photo)
      <br>3. Run it</div>
      <p>Both branches fire! The template shows the breed name, and the image node renders the actual dog photo. Same data, two different presentations.</p>
      <div class="concept"><strong>This is the shape of real flows.</strong> Most useful pipelines aren't straight lines â€” they branch, merge, and fan out. Getting comfortable with fan-out is essential.</div>
      <div class="hint">The Display Image node automatically looks for fields named <code>image_url</code>, <code>sprite_url</code>, <code>thumbnail_url</code>, or <code>flag_url</code>. If the incoming data has one of these, it renders the image.</div>
    `,
    check(nodes) {
      const dog = Object.values(nodes).find(n => n.name === 'dog_random');
      const img = Object.values(nodes).find(n => n.name === 'display_image');
      if (!dog) return 'Add a Dog CEO: Random node.';
      if (!img) return 'Add a Display Image node.';
      const dogConns = Object.values(dog.outputs).flatMap(o => o.connections);
      if (dogConns.length < 2) return 'Connect Dog CEO to two different downstream nodes.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 6 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'The Whole Machine',
    body: `
      <p>You now know all the fundamental building blocks: triggers, API calls, transforms, and outputs. Let's put them all together into a pipeline that actually <em>does</em> something interesting.</p>
      <div class="concept"><strong>Pipeline thinking:</strong> Break a goal into small steps, assign each step to a node, wire them together. "Get a random dog, find out what breed it is, ask an AI about that breed, show the answer and the photo" becomes five nodes in a line with one branch.</div>
      <div class="task"><strong>Build this pipeline:</strong>
      <br>1. <code>Manual Trigger</code>
      <br>2. â†’ <code>Dog CEO: Random</code>
      <br>3. â†’ <code>Extract Field</code> (field: <code>breed</code>)
      <br>4. â†’ <code>Template</code> (<code>Tell me a fun fact about {value} dogs. One sentence.</code>)
      <br>5. â†’ <code>LLM Chat</code> (needs API key + model)
      <br>6. â†’ <code>Display Result</code>
      <br>Also from step 2: â†’ <code>Display Image</code></div>
      <p>When you run this, the flow fetches a random dog, extracts the breed, builds a prompt, sends it to an LLM, and displays the AI's response alongside the photo. Six nodes, one click.</p>
      <div class="hint">No API key? Select <strong>Groq</strong> in the LLM node for free cloud models (<a href="https://console.groq.com/keys" target="_blank" style="color:var(--cyan)">console.groq.com/keys</a>), or select <strong>Local / Ollama</strong> to use a model running on your own machine â€” no key needed at all. Or skip the LLM node entirely and wire Template â†’ Display.</div>
      <div class="concept"><strong>What you've built is a program.</strong> Not with text, but with boxes and wires. Every professional flow tool works exactly this way â€” the nodes are different, but the wiring pattern is identical.</div>
    `,
    check(nodes) {
      const types = Object.values(nodes).map(n => n.name);
      const has = name => types.includes(name);
      if (!has('manual_trigger')) return 'Add a Manual Trigger.';
      if (!has('dog_random')) return 'Add a Dog CEO: Random node.';
      const outputCount = types.filter(t => t === 'display' || t === 'display_image').length;
      if (outputCount < 2) return 'Add at least 2 output nodes (text + image).';
      if (Object.keys(nodes).length < 5) return 'Build out the full pipeline (need 5+ nodes).';
      return true;
    }
  },

  // â”€â”€ CHAPTER 7 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'The Bestiary',
    body: `
      <p>You've been working with Dog CEO, but the palette has several more API nodes. They all follow the <strong>exact same pattern</strong>: optional input fields (supporting <code>{variable}</code> interpolation), an HTTP call under the hood, and a structured output object.</p>
      <div class="concept"><strong>The pattern:</strong> Configure â†’ Call â†’ Output. Once you understand this with one API node, you understand all of them. The only things that change are the field names.</div>
      <p>Here's what's available:</p>
      <p>ðŸŒ¤ <strong>Weather</strong> â€” Takes lat/lon coordinates, returns <code>temperature</code>, <code>description</code>, <code>wind_speed</code>, <code>humidity</code>. Great for conditional flows ("if temp > 30...").</p>
      <p>W <strong>Wikipedia</strong> â€” Takes a topic name, returns <code>title</code>, <code>summary</code>, <code>thumbnail_url</code>. Perfect for chaining with other APIs ("get breed â†’ look it up on Wikipedia").</p>
      <p>âš¡ <strong>PokÃ©API</strong> â€” Takes a PokÃ©mon name/ID, returns <code>name</code>, <code>types</code>, <code>sprite_url</code>, <code>hp</code>, <code>attack</code>, and more. Rich structured data.</p>
      <p>ðŸ˜„ <strong>JokeAPI</strong> â€” Dropdown for category, returns <code>joke</code> or <code>setup</code>/<code>delivery</code>. Simple but fun for templates.</p>
      <p>ðŸŒ <strong>REST Countries</strong> â€” Takes a country name, returns <code>name</code>, <code>capital</code>, <code>population</code>, <code>flag_url</code>, <code>languages</code>, and much more.</p>
      <div class="task"><strong>Do this:</strong> Build a pipeline using at least one API node you haven't tried yet. Some ideas:
      <br>â€¢ Dog CEO breed â†’ <code>Wikipedia</code> summary â†’ Display
      <br>â€¢ <code>PokÃ©API</code> â†’ Template with stats â†’ Display + Display Image (sprite)
      <br>â€¢ <code>REST Countries</code> â†’ Template with facts â†’ Display + Display Image (flag)</div>
      <div class="hint">Remember: you can chain APIs by using {variable} interpolation. A Dog CEO node outputs <code>breed</code>, and you can set Wikipedia's topic field to <code>{breed}</code> to look up whatever breed was randomly selected.</div>
    `,
    check(nodes) {
      const apiNodes = ['open_meteo','wikipedia','pokeapi','jokeapi','rest_countries'];
      const types = Object.values(nodes).map(n => n.name);
      if (!apiNodes.some(a => types.includes(a))) return 'Try one of the new API nodes (Weather, Wikipedia, PokÃ©API, etc.)';
      return true;
    }
  },

  // â”€â”€ CHAPTER 8 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'The Fork in the Road',
    body: `
      <p>So far, every node in your flow runs every time. But what if you want different behavior depending on the data? "If it's hot, say one thing; if it's cold, say another."</p>
      <p>The <strong>If</strong> node introduces <em>conditional routing</em>. It has one input and <strong>two outputs</strong>: the top output (âœ“ True) fires when the condition passes, the bottom (âœ— False) fires when it doesn't. Data only flows through the matching path â€” the other side is skipped entirely.</p>
      <div class="concept"><strong>How it works:</strong> You configure three things:
      <br>â€¢ <strong>Field</strong> â€” which field from the input to test (e.g. <code>temperature</code>)
      <br>â€¢ <strong>Operator</strong> â€” how to test it (<code>greater than</code>, <code>equals</code>, <code>contains</code>, etc.)
      <br>â€¢ <strong>Compare To</strong> â€” the value to compare against (e.g. <code>30</code>)
      <br><br>The node evaluates the condition and routes the <em>entire</em> input object down only one path. Both branches receive the same data â€” they just receive it conditionally.</div>
      <div class="task"><strong>Build this:</strong>
      <br>1. <code>Manual Trigger</code> â†’ <code>Weather</code> (use default BH coordinates or your own)
      <br>2. â†’ <code>If</code> node: field = <code>temperature</code>, operator = <code>greater than</code>, compare = <code>25</code>
      <br>3. âœ“ True output â†’ <code>Template</code>: <code>ðŸ”¥ {temperature}{unit} in BH â€” hot!</code> â†’ <code>Display Result</code>
      <br>4. âœ— False output â†’ <code>Template</code>: <code>â„ï¸ {temperature}{unit} in BH â€” nice and cool</code> â†’ <code>Display Result</code>
      <br>5. Run it and see which branch lights up</div>
      <p>Only one of the two Display nodes should get data. The other branch stays dark â€” the data never reached it.</p>
      <div class="hint">The If node passes the <em>complete</em> input object to the winning branch, not just the tested field. So both template branches have access to all the weather fields like <code>{temperature}</code>, <code>{description}</code>, <code>{humidity}</code>.</div>
    `,
    check(nodes) {
      const ifNode = Object.values(nodes).find(n => n.name === 'if_node');
      if (!ifNode) return 'Add an If node.';
      if (!ifNode.data.field) return 'Set the If node\'s Field (e.g. "temperature").';
      const outConns = Object.values(ifNode.outputs).flatMap(o => o.connections);
      if (outConns.length < 2) return 'Connect both outputs of the If node (True and False paths).';
      return true;
    }
  },

  // â”€â”€ CHAPTER 9 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'One at a Time',
    body: `
      <p>Some APIs return not one result, but a <strong>list</strong> of results â€” an array. The PokÃ©API's type endpoint returns all PokÃ©mon of a given type. An email API might return 50 messages. How do you process each item individually?</p>
      <p>The <strong>ForEach</strong> node takes an array and runs the downstream flow <em>once per item</em>. If the array has 10 items, every node after ForEach executes 10 times â€” you can watch them pulse in sequence.</p>
      <div class="concept"><strong>How it works:</strong>
      <br>â€¢ ForEach receives an object containing an array
      <br>â€¢ It detects the array automatically (or you can specify the field name)
      <br>â€¢ For each element, it sends downstream: <code>{ value: &lt;the item&gt;, index: 0, 1, 2... }</code>
      <br>â€¢ If the array elements are objects, their properties are also available directly</div>
      <div class="task"><strong>Build this:</strong>
      <br>1. <code>Manual Trigger</code>
      <br>2. â†’ <code>HTTP GET</code> with URL: <code>https://dog.ceo/api/breed/hound/list</code>
      <br>3. â†’ <code>Extract Field</code>: field = <code>message</code> (this extracts the array of sub-breeds)
      <br>4. â†’ <code>ForEach</code> (leave field blank for auto-detect)
      <br>5. â†’ <code>Template</code>: <code>Hound sub-breed #{index}: {value}</code>
      <br>6. â†’ <code>Display Result</code>
      <br>7. Run it!</div>
      <p>Watch the nodes flash repeatedly â€” once for each sub-breed in the array. Each iteration, <code>{value}</code> is a different breed name and <code>{index}</code> counts up from 0.</p>
      <div class="hint">ForEach is sequential â€” it processes one item at a time, waiting for the downstream flow to complete before starting the next. This makes it easy to see what's happening, but it can be slow for large arrays. For this workshop, that's a feature, not a bug.</div>
    `,
    check(nodes) {
      const fe = Object.values(nodes).find(n => n.name === 'for_each');
      if (!fe) return 'Add a ForEach node.';
      const hasInput = Object.values(fe.inputs).some(i => i.connections.length > 0);
      if (!hasInput) return 'Wire something into the ForEach\'s input.';
      const hasOutput = Object.values(fe.outputs).some(o => o.connections.length > 0);
      if (!hasOutput) return 'Wire the ForEach\'s output to a downstream node.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 10 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'The Code Escape Hatch',
    body: `
      <p>The visual nodes cover common operations, but sometimes you need to do something custom â€” massage data in a way no pre-built node handles. That's what the <strong>Code</strong> node is for.</p>
      <p>The Code node gives you a small JavaScript editor. Your code receives the input as a variable called <code>data</code>. You can modify it directly â€” add fields, remove them, transform values â€” and the modified object flows downstream.</p>
      <div class="concept"><strong>Mutation model:</strong> You don't need to <code>return</code> anything. Just modify <code>data</code> directly:
      <br><code>data.greeting = 'Hello ' + data.name;</code>
      <br><code>data.upper = data.text.toUpperCase();</code>
      <br><code>delete data._passthrough;</code>
      <br><br>If you prefer, you <em>can</em> return a new object â€” it'll replace the data entirely. But mutation is simpler for quick transforms.</div>
      <div class="task"><strong>Build this:</strong>
      <br>1. <code>Trigger</code> â†’ <code>PokÃ©API</code> (try "charizard") â†’ <code>Code</code> â†’ <code>Display Result</code>
      <br>2. In the Code node, write:
      <br><code>data.summary = data.name + ' (' + data.types + ')';</code>
      <br><code>data.power = data.attack + data.defense;</code>
      <br><code>data.tier = data.power > 150 ? 'Strong' : 'Average';</code>
      <br>3. Run it and check the output</div>
      <p>The Code node is your escape hatch â€” when the visual nodes can't do exactly what you need, drop in a few lines of JavaScript. But the philosophy is: <strong>use visual nodes when you can, code when you must</strong>.</p>
      <div class="hint">The code runs in a sandboxed Function() â€” it has access to <code>data</code> and standard JavaScript, but not to the page DOM or external libraries. Keep it simple: data in, data out.</div>
    `,
    check(nodes) {
      const code = Object.values(nodes).find(n => n.name === 'code_node');
      if (!code) return 'Add a Code node.';
      if (!code.data.code || code.data.code.trim() === '' || code.data.code.startsWith('//')) return 'Write some JavaScript in the Code node (not just comments).';
      const hasInput = Object.values(code.inputs).some(i => i.connections.length > 0);
      if (!hasInput) return 'Wire data into the Code node\'s input.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 11 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Remember This',
    body: `
      <p>Every flow we've built so far has been <strong>stateless</strong> â€” data enters, flows through, and vanishes. If you run the same flow twice, the second run knows nothing about the first. There's no memory.</p>
      <p>But real automation often needs state. A counter that increments each run. A "last seen" value. An accumulator that builds up results. The <strong>Set Variable</strong> and <strong>Get Variable</strong> nodes give you this.</p>
      <div class="concept"><strong>How variables work:</strong>
      <br>â€¢ <strong>Set Variable</strong> saves data under a named key, then <em>passes the data through unchanged</em>. It's a "tap" on the wire â€” it doesn't block or alter the flow, it just saves a copy on the side.
      <br>â€¢ <strong>Get Variable</strong> retrieves whatever was stored under that key. It can work with or without input.
      <br>â€¢ Variables persist across runs within the session (cleared when you hit Clear).</div>
      <div class="task"><strong>Build this â€” a run counter:</strong>
      <br>1. <code>Manual Trigger</code> â†’ <code>Code</code> â†’ <code>Set Variable</code> â†’ <code>Display Result</code>
      <br>2. In the Code node:
      <br><code>const prev = typeof flowVars.count === 'number' ? flowVars.count : 0;</code>
      <br><code>data.count = prev + 1;</code>
      <br>3. Set Variable: name = <code>count</code>, value field = <code>count</code>
      <br>4. Run it multiple times â€” watch the count increment!</div>
      <p>Now check the <strong>Variables tab</strong> in the bottom panel. Every stored variable appears there with its name, type, and current value. This is your state inspector.</p>
      <div class="concept"><strong>Cross-branch communication:</strong> Variables also let one branch of your flow share data with another. Branch A stores a value, Branch B reads it. This is impossible with just wires â€” wires can only go forward. Variables give you a "side channel."</div>
      <div class="task"><strong>Try this:</strong>
      <br>1. Build a flow where Dog CEO â†’ Set Variable (name: <code>last_breed</code>)
      <br>2. In a separate branch: Trigger â†’ Get Variable (<code>last_breed</code>) â†’ Template â†’ Display
      <br>3. Run the Dog CEO branch first, then the Get branch â€” it retrieves the breed from the previous run</div>
      <div class="hint">Set Variable's "Value Field" is optional. Leave it blank to store the entire input object. Set it to a field name (like <code>breed</code>) to store just that one value.</div>
    `,
    check(nodes) {
      const setV = Object.values(nodes).find(n => n.name === 'set_variable');
      const getV = Object.values(nodes).find(n => n.name === 'get_variable');
      if (!setV && !getV) return 'Add a Set Variable or Get Variable node.';
      if (setV && (!setV.data.var_name || !setV.data.var_name.trim())) return 'Set a Variable Name on the Set Variable node.';
      if (getV && (!getV.data.var_name || !getV.data.var_name.trim())) return 'Set a Variable Name on the Get Variable node.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 12 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'The Vault',
    body: `
      <p>You've probably noticed something annoying: if you use Telegram or an LLM across multiple nodes, you have to paste the same API key or bot token into every single one. Change the key? Edit five nodes.</p>
      <p>The <strong>Config tab</strong> in the bottom panel solves this. It's a simple key-value store for secrets and configuration values that you define once and reference anywhere.</p>
      <div class="concept"><strong>The <code>$name</code> syntax:</strong>
      <br>Any node field can reference a Config value by prefixing the key name with <code>$</code>. If you define <code>tg_token</code> in Config, then any token field can simply contain <code>$tg_token</code> â€” it gets resolved at execution time.
      <br><br>Resolution order:
      <br>1. <code>$name</code> â†’ looked up from the Config tab
      <br>2. <code>{name}</code> â†’ looked up from the input data
      <br>So <code>$tg_token</code> and <code>{chat_id}</code> can coexist in the same field.</div>
      <div class="task"><strong>Set up your config:</strong>
      <br>1. Click the <strong>Config</strong> tab in the bottom panel
      <br>2. Click <strong>+ Add</strong>
      <br>3. Set key = <code>tg_token</code>, value = your Telegram bot token (or any test string)
      <br>4. Add another: key = <code>llm_key</code>, value = your NanoGPT or Groq API key
      <br>5. Now in any Telegram node's token field, just type <code>$tg_token</code>
      <br>6. In the LLM Chat node's API key field, type <code>$llm_key</code></div>
      <p>Config values are masked (shown as â€¢â€¢â€¢â€¢) by default since they're usually secrets. Click the ðŸ‘ button to reveal a value temporarily.</p>
      <div class="concept"><strong>Why this matters:</strong> Separating configuration from logic is a fundamental engineering practice. Your flow defines <em>what happens</em>. The Config defines <em>with what credentials</em>. You can share the flow without sharing your secrets, or swap keys without rewiring anything.</div>
      <div class="hint">Config entries persist for the session. If you refresh the page, you'll need to re-enter them. In a production flow tool, these would be stored securely â€” but the pattern is identical.</div>
    `,
    check(nodes) {
      if (Object.keys(flowConfig).length === 0) return 'Add at least one entry in the Config tab.';
      // Check if any node field references $
      const allNodes = Object.values(nodes);
      const hasRef = allNodes.some(n => {
        return Object.values(n.data || {}).some(v => typeof v === 'string' && v.includes('$'));
      });
      if (!hasRef) return 'Use a $config_name reference in at least one node field.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 13 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Living Flows',
    body: `
      <p>So far, every flow runs once when you click â–¶. But real automation runs <em>continuously</em> â€” checking for new data, updating dashboards, polling services. The <strong>Interval Trigger</strong> turns a flow into a living, breathing system.</p>
      <div class="concept"><strong>Interval Trigger</strong> has a seconds field and an on/off toggle. When you flip the toggle on, it fires downstream every N seconds automatically. The node pulses with a cyan border to show it's alive. Toggle it off to stop.</div>
      <p>This is the difference between a script and a service. A script runs once. A service keeps running, reacting to the world.</p>
      <div class="task"><strong>Build a live weather dashboard:</strong>
      <br>1. <code>Interval Trigger</code> (set to every <code>30</code> seconds)
      <br>2. â†’ <code>Weather</code> (use your coordinates or BH default: -19.92, -43.94)
      <br>3. â†’ <code>Template</code>: <code>ðŸŒ¡ {temperature}{unit} | {description} | Wind: {wind_speed}km/h | Updated: {_timestamp}</code>
      <br>4. â†’ <code>Display Result</code>
      <br>5. Toggle the Interval Trigger <strong>ON</strong></div>
      <p>Watch it fire every 30 seconds. The display updates with fresh weather data each time. The node status shows the tick count so you can see it's alive.</p>
      <div class="concept"><strong>Combining with variables:</strong> Interval Triggers become much more powerful with state. You could:
      <br>â€¢ Track temperature changes over time (store previous value, compare with current)
      <br>â€¢ Count how many times a condition was true
      <br>â€¢ Accumulate data across ticks for a summary</div>
      <div class="task"><strong>Advanced â€” change detector:</strong>
      <br>Add a Code node after Weather that compares with a stored previous temperature:
      <br><code>const prev = flowVars.lastTemp;</code>
      <br><code>flowVars.lastTemp = data.temperature;</code>
      <br><code>data.changed = prev !== undefined && prev !== data.temperature;</code>
      <br><code>data.delta = prev ? (data.temperature - prev).toFixed(1) : '?';</code>
      <br>Then If â†’ changed equals true â†’ Template showing the delta â†’ Display</div>
      <div class="hint">Don't forget to toggle the interval OFF when you're done experimenting. Active intervals keep running even while you edit the flow. The Clear button stops all intervals automatically.</div>
    `,
    check(nodes) {
      const interval = Object.values(nodes).find(n => n.name === 'interval_trigger');
      if (!interval) return 'Add an Interval Trigger node.';
      const hasOutput = Object.values(interval.outputs).some(o => o.connections.length > 0);
      if (!hasOutput) return 'Wire the Interval Trigger to a downstream node.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 14 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Bot Workshop Gaiden',
    body: `
      <p>This is the boss level. Everything you've learned â€” APIs, transforms, state, config, intervals, branching â€” comes together to build a <strong>Telegram bot</strong> entirely from visual nodes.</p>
      <p>In the Bot Workshop (201), you wrote a bot in code: polling loop, message parsing, command dispatch, API calls, response formatting. Here, you'll build the same thing with <em>zero lines of code</em> (well, maybe a Code node or two).</p>
      <div class="concept"><strong>The Telegram nodes:</strong>
      <br>â€¢ <strong>Telegram Trigger</strong> â€” polls your bot for new messages. Each incoming message fires downstream with <code>{ text, chat_id, from, message_id, username }</code>.
      <br>â€¢ <strong>Telegram Send</strong> â€” sends a text reply. Uses <code>{text}</code> from input and <code>{chat_id}</code> for routing.
      <br>â€¢ <strong>Telegram Send Image</strong> â€” sends a photo URL with optional caption.
      <br><br>All three accept <code>$tg_token</code> from your Config tab â€” set it up once, never paste again.</div>
      <div class="task"><strong>Step 1 â€” Setup:</strong>
      <br>1. Open the <strong>Config</strong> tab and add <code>tg_token</code> = your bot's token from @BotFather
      <br>2. Send a message to your bot in Telegram (so there's a chat to reply to)</div>
      <div class="task"><strong>Step 2 â€” Echo bot:</strong>
      <br>1. <code>Telegram Trigger</code> (token: <code>$tg_token</code>, poll: 3s)
      <br>2. â†’ <code>Template</code>: <code>Echo: {text}</code>
      <br>3. â†’ <code>Telegram Send</code> (token: <code>$tg_token</code>, chat_id: <code>{chat_id}</code>)
      <br>4. Toggle the trigger ON
      <br>5. Send a message in Telegram â€” it should echo back!</div>
      <div class="task"><strong>Step 3 â€” Smart bot with routing:</strong>
      <br>Now make it interesting. After the Trigger, add:
      <br>1. <code>If</code> node: field = <code>text</code>, operator = <code>contains</code>, compare = <code>/dog</code>
      <br>2. âœ“ True path â†’ <code>Dog CEO: Random</code> â†’ <code>Telegram Send Image</code> (token: <code>$tg_token</code>, chat_id: <code>{chat_id}</code>, caption: <code>{breed}</code>)
      <br>3. âœ— False path â†’ <code>If</code>: text contains <code>/joke</code>
      <br>4. âœ“ â†’ <code>JokeAPI</code> â†’ <code>Telegram Send</code> (text comes from <code>{text}</code>)
      <br>5. âœ— â†’ <code>Template</code>: <code>I know /dog and /joke. Try one!</code> â†’ <code>Telegram Send</code></div>
      <p>You've just built a multi-command Telegram bot with image support, entirely by wiring nodes. Send <code>/dog</code> to get a random dog photo. Send <code>/joke</code> to get a joke. Send anything else to see the help message.</p>
      <div class="concept"><strong>What you've built is the same bot from Workshop 201</strong> â€” but instead of a polling loop in JavaScript with if/else chains and fetch calls, it's a visible graph where every piece of logic is a box you can see, rewire, and extend. Want a new command? Add a branch. Want to log messages? Tap a Set Variable in. Want an LLM-powered response? Drop an LLM Chat node in one of the paths.</div>
      <div class="hint">The Telegram Trigger also has an input port. You can wire a Manual Trigger into it to do a one-shot poll for testing without keeping the interval running.</div>
    `,
    check(nodes) {
      const tgTrigger = Object.values(nodes).find(n => n.name === 'telegram_trigger');
      const tgSend = Object.values(nodes).find(n => n.name === 'telegram_send' || n.name === 'telegram_send_image');
      if (!tgTrigger) return 'Add a Telegram Trigger node.';
      if (!tgSend) return 'Add a Telegram Send or Telegram Send Image node.';
      const hasOutput = Object.values(tgTrigger.outputs).some(o => o.connections.length > 0);
      if (!hasOutput) return 'Wire the Telegram Trigger to downstream processing.';
      return true;
    }
  },

  // â”€â”€ CHAPTER 15 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Boxes Inside Boxes',
    body: `
      <p>Here's the most important idea in this workshop â€” maybe in all of programming.</p>
      <p>Look at your canvas. It's getting complicated. Wires everywhere. What if you built a useful sub-flow and wanted to reuse it in multiple places? You'd have to copy-paste all the nodes each time. That's messy and error-prone.</p>
      <p>The solution: <strong>package a sub-flow into a single reusable node</strong>. This is called <em>abstraction</em> â€” hiding complexity behind a simple interface. It's exactly what every built-in node already is: the Dog CEO node is just "make an HTTP request, parse the response, extract the fields" packaged into one box.</p>
      <div class="concept"><strong>Modules</strong> are separate canvases (tabs) where you build sub-flows. <strong>Input Port</strong> and <strong>Output Port</strong> nodes mark where data enters and exits. When you "Save as Node", the module becomes a custom node you can drag onto any canvas.</div>
      <p>Let's walk through this step by step by building a <strong>"Weather Report"</strong> node that takes coordinates and outputs a formatted weather summary.</p>
      <div class="task"><strong>Step 1 â€” Create a module:</strong>
      <br>Click the <strong>+</strong> button in the tab bar at the top of the canvas. Name it <code>Weather Report</code>.</div>
      <div class="task"><strong>Step 2 â€” Build the sub-flow:</strong>
      <br>You're now on an empty canvas. Build this flow:
      <br>1. <code>Input Port</code> (name it <code>input</code>)
      <br>2. â†’ <code>Weather</code> (set lat to <code>{lat}</code>, lon to <code>{lon}</code>)
      <br>3. â†’ <code>Template</code>: <code>Weather: {description}, {temperature}{unit}, wind {wind_speed}km/h</code>
      <br>4. â†’ <code>Output Port</code> (name it <code>output</code>)
      <br><br>Wire them left to right. This sub-flow takes coordinates in, calls the weather API, formats the result, and sends it out.</div>
      <div class="task"><strong>Step 3 â€” Save as Node:</strong>
      <br>Right-click the <strong>"Weather Report"</strong> tab and select <strong>ðŸ“¦ Save as Node</strong>. Give it a name. It now appears in the <strong>Custom Nodes</strong> section of the sidebar.</div>
      <div class="task"><strong>Step 4 â€” Use it:</strong>
      <br>Switch back to the <strong>Main</strong> tab. Drag your new custom node onto the canvas. Wire a Trigger into it, and a Display after it. Run the flow â€” your custom node executes the entire sub-flow internally!</div>
      <div class="concept"><strong>This is the core insight:</strong> Every node in the sidebar is just someone's packaged sub-graph. The HTTP GET node? It's a wrapper around <code>fetch()</code>. The Dog CEO node? It's HTTP GET + field extraction, packaged. Now you can build your own. Your abstractions are exactly as real as the built-in ones.</div>
      <div class="hint">Custom nodes are <em>live</em> â€” if you go back to the Weather Report tab and change the template, the next time you run the custom node on Main, it picks up the change automatically. The module IS the definition.</div>
    `,
    check(nodes) {
      const modules = Object.keys(editor.drawflow.drawflow);
      if (modules.length < 2) return 'Create a new module: click the + button in the tab bar.';
      for (const mod of modules) {
        if (mod === 'Home') continue;
        const data = editor.drawflow.drawflow[mod].data;
        const vals = Object.values(data);
        const hasIn = vals.some(n => n.name === 'input_port');
        const hasOut = vals.some(n => n.name === 'output_port');
        if (hasIn && hasOut) {
          const processingNodes = vals.filter(n => n.name !== 'input_port' && n.name !== 'output_port');
          if (processingNodes.length > 0) return true;
          return 'Add some processing nodes between Input Port and Output Port in your module.';
        }
        if (hasIn && !hasOut) return 'Add an Output Port to your module "' + mod + '".';
        if (!hasIn && hasOut) return 'Add an Input Port to your module "' + mod + '".';
      }
      return 'Add an Input Port and Output Port in your module.';
    }
  },

  // â”€â”€ CHAPTER 16 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Free Build',
    body: `
      <p>If this workshop left you here with nothing else, you'd already have enough. You have triggers, APIs, transforms, conditionals, loops, code, state, config, and <strong>composition</strong> â€” the ability to build your own abstractions. That's the complete toolkit.</p>
      <div class="concept"><strong>The thesis of this workshop:</strong>
      <br><br>Every node is just a packaged sub-graph. Every tool you use was built by someone composing smaller pieces. The difference between a "user" and a "builder" is just whether you can see the wiring inside the box. Now you can. And if someone asked you to change this back â€” to go back to not seeing it â€” lord help you, you can't. You can't unknow this.</div>
      <p>This is the part where you leave the nest. Seventeen chapters gave you the bird's-eye view of how data flows through a graph, but staying inside guided exercises forever won't make you a builder. <strong>Building things</strong> makes you a builder.</p>
      <p>So spread out across the canvas. If the ideas below don't move you, fly right past them â€” chase whatever calls to you. Here are some starting points:</p>
      <p>ðŸ¤– <strong>Auto-refreshing dashboard:</strong> Use an <code>Interval Trigger</code> (every 30s) â†’ Weather â†’ Template with a rich summary â†’ Display. Toggle it on and watch it update live.</p>
      <p>ðŸ“š <strong>Research chain:</strong> Pick a random PokÃ©mon â†’ get its types â†’ Wikipedia summary of the type â†’ Template â†’ Display. A three-API pipeline.</p>
      <p>ðŸ—ºï¸ <strong>Country quiz game:</strong> REST Countries â†’ Code node that hides the answer â†’ Template asking "What's the capital of {name}?" â†’ Display the question + Display Image the flag.</p>
      <p>ðŸ”§ <strong>Node library:</strong> Build reusable custom nodes â€” a "PokÃ©mon Card" node, a "Country Fact" node, a "Wikipedia Lookup" node â€” and compose them into larger flows.</p>
      <p>â‘‚ <strong>Smart routing:</strong> Fetch weather â†’ If rainy â†’ "bring an umbrella" / If sunny â†’ "enjoy the day" â†’ combine both paths with Merge/Relay.</p>
      <p>There's no check for this chapter. You're as free as it gets â€” build something that surprises you.</p>
      <div class="concept"><strong>What's next?</strong> This workshop taught the primitives â€” every visual programming tool uses these same ideas. The sky is wide open from here:
      <br><br>ðŸ”§ <strong><a href="https://nodered.org" target="_blank" style="color:var(--cyan)">Node-RED</a></strong> â€” open source, runs on Raspberry Pi. IoT, home automation, APIs. Closest to what you just built.
      <br>âš¡ <strong><a href="https://n8n.io" target="_blank" style="color:var(--cyan)">n8n</a></strong> â€” self-hostable workflow automation. 400+ integrations, fair-code license.
      <br>ðŸŽ¨ <strong><a href="https://github.com/comfyanonymous/ComfyUI" target="_blank" style="color:var(--cyan)">ComfyUI</a></strong> â€” node graph for Stable Diffusion. Same graph-of-nodes model applied to AI image generation.
      <br>ðŸŽ® <strong>Unreal Blueprints</strong> â€” visual scripting in game engines. Proves this paradigm scales to AAA production.
      <br><br>You already understand the wiring. The only difference is the node library. Now go on â€” travel on.</div>
    `,
    check() { return true; }
  },

  // â”€â”€ CHAPTER 17 â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  {
    title: 'Certificate',
    body: `
      <p>You made it through seventeen chapters of visual dataflow programming. That deserves recognition.</p>
      <div class="concept"><strong>How it works</strong>
      <br>Enter your name below, click Claim, and a pre-filled GitHub Issue opens. When you submit it, a GitHub Action validates your request, generates a unique certificate code, and replies with a link to view and download your certificate as a PDF.</div>
      <p>Enter your full name below (as you want it on the certificate), then click <strong>Claim Certificate</strong>.</p>
      <div style="margin:16px 0;">
        <label for="cert-name" style="display:block;font-size:12px;color:var(--text-dim);margin-bottom:6px;">Full name / Nome completo</label>
        <input type="text" id="cert-name" placeholder="Ana Costa" style="width:100%;padding:8px 10px;background:var(--surface);border:1px solid var(--border);border-radius:6px;color:var(--text);font-family:inherit;font-size:13px;box-sizing:border-box;">
        <button onclick="claimCertificate()" style="margin-top:10px;padding:8px 20px;background:var(--green);color:#111;border:none;border-radius:6px;font-size:13px;font-weight:600;cursor:pointer;">Claim Certificate</button>
        <div id="cert-status" style="margin-top:8px;font-size:12px;min-height:18px;"></div>
      </div>
      <div class="hint"><strong>Requires a GitHub account.</strong> If you don't have one, ask your instructor to issue the certificate on your behalf.</div>
    `,
    check() { return true; }
  },
];


let currentChapter = 0;
const chapterDone = new Array(CHAPTERS.length).fill(false);

function dismissSplash(mode) {
  const splash = document.getElementById('splash');
  splash.classList.add('hidden');
  setTimeout(() => splash.remove(), 500);
  document.getElementById('guideToggle').style.display = '';
  if (mode === 'guide') {
    toggleGuide();
  } else if (mode === 'import') {
    document.getElementById('loadFile').click();
  }
  // 'explore' and 'load:key' just dismiss
}

function toggleGuide() {
  const panel = document.getElementById('guidePanel');
  panel.classList.toggle('open');
  // Hide toggle button when panel is open
  document.getElementById('guideToggle').style.display =
    panel.classList.contains('open') ? 'none' : '';
}

function renderGuide() {
  const ch = CHAPTERS[currentChapter];

  // Progress pips
  const progress = document.getElementById('guideProgress');
  progress.innerHTML = CHAPTERS.map((_, i) => {
    const cls = i === currentChapter ? 'current' : (chapterDone[i] ? 'done' : '');
    return `<div class="guide-pip ${cls}" onclick="goToChapter(${i})"></div>`;
  }).join('');

  // Body
  document.getElementById('guideBody').innerHTML =
    `<div class="chapter-num">${currentChapter === 0 ? 'Introduction' : 'Chapter ' + currentChapter + ' of ' + (CHAPTERS.length - 1)}</div>
     <h3>${ch.title}</h3>
     ${ch.body}`;

  // Footer
  document.getElementById('guideChapterLabel').textContent =
    `${currentChapter} / ${CHAPTERS.length - 1}`;
  document.getElementById('guidePrev').style.display =
    currentChapter === 0 ? 'none' : '';
  document.getElementById('guideNext').style.display =
    currentChapter === CHAPTERS.length - 1 ? 'none' : '';
  // Hide check on intro and last chapter (free build)
  document.getElementById('guideCheck').style.display =
    (currentChapter === 0 || currentChapter === CHAPTERS.length - 1) ? 'none' : '';
}

function guideNav(dir) {
  currentChapter = Math.max(0, Math.min(CHAPTERS.length - 1, currentChapter + dir));
  renderGuide();
}

function goToChapter(i) {
  currentChapter = i;
  renderGuide();
}

function guideCheckTask() {
  const ch = CHAPTERS[currentChapter];
  if (!ch.check) return;

  const exported = editor.export();
  const nodes = exported.drawflow[editor.module].data;
  const result = ch.check(nodes);

  if (result === true) {
    chapterDone[currentChapter] = true;
    addLog('info', `âœ“ Chapter ${currentChapter + 1} "${ch.title}" â€” complete!`);
    renderGuide();
    // Brief green flash on check button
    const btn = document.getElementById('guideCheck');
    btn.textContent = 'âœ“ Done!';
    btn.style.background = 'var(--green)';
    setTimeout(() => { btn.textContent = 'âœ“ Check'; btn.style.background = ''; }, 1500);
  } else {
    addLog('info', `Chapter ${currentChapter + 1}: ${result}`);
    // Brief feedback on check button
    const btn = document.getElementById('guideCheck');
    const orig = btn.textContent;
    btn.textContent = 'âœ— ' + result;
    btn.style.background = 'var(--amber)';
    btn.style.color = '#111';
    setTimeout(() => { btn.textContent = orig; btn.style.background = ''; btn.style.color = ''; }, 2500);
  }
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//  CERTIFICATE CLAIM
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
const CERT_SALT = 'patchbay-gcu-2026';
const CERT_WORKSHOP_ID = 'PB-301';
const CERT_REPO = 'endarthur/etc';

async function computeCompletionHash(workshopId, date) {
  const data = new TextEncoder().encode(workshopId + ':' + date + ':' + CERT_SALT);
  const buf = await crypto.subtle.digest('SHA-256', data);
  return Array.from(new Uint8Array(buf)).map(b => b.toString(16).padStart(2, '0')).join('').slice(0, 16);
}

async function claimCertificate() {
  const input = document.getElementById('cert-name');
  const status = document.getElementById('cert-status');
  const name = (input.value || '').trim();
  if (!name || name.length < 2) {
    status.textContent = 'Please enter your full name (at least 2 characters).';
    status.style.color = 'var(--amber)';
    return;
  }
  const today = new Date().toISOString().slice(0, 10);
  const hash = await computeCompletionHash(CERT_WORKSHOP_ID, today);
  const params = new URLSearchParams({
    template: 'cert-request.yml',
    title: 'cert: ' + CERT_WORKSHOP_ID,
    fullname: name, workshop: CERT_WORKSHOP_ID, date: today, hash: hash,
  });
  status.textContent = 'Opening GitHub â€” submit the issue to receive your certificate.';
  status.style.color = 'var(--cyan)';
  window.open('https://github.com/' + CERT_REPO + '/issues/new?' + params, '_blank');
}

// Init guide + splash
renderGuide();
renderSplashProjects();

</script>
</body>
</html>
