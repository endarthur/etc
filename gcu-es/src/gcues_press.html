<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1">
<title>GCUES Press</title>
<link rel="preconnect" href="https://fonts.googleapis.com">
<link href="https://fonts.googleapis.com/css2?family=IBM+Plex+Mono:wght@400;500;600;700&family=IBM+Plex+Sans:wght@300;400;500;600&display=swap" rel="stylesheet">

<style>
/* ══════════════════════════════════════════════════
   GCUES Press — 3-Column Desktop App Layout
   ══════════════════════════════════════════════════ */

*, *::before, *::after { box-sizing: border-box; margin: 0; padding: 0; }

:root {
  --bg: #111110;
  --surface: #1a1a18;
  --surface-hi: #222220;
  --border: #2a2a26;
  --border-hi: #3a3a34;
  --text: #d4d0c8;
  --text-dim: #8a8780;
  --text-faint: #5a5850;
  --amber: #d4a017;
  --amber-dim: rgba(212,160,23,0.12);
  --amber-glow: rgba(212,160,23,0.3);
  --green: #6abf69;
  --green-dim: rgba(106,191,105,0.12);
  --red: #c0392b;
  --red-dim: rgba(192,57,43,0.12);
  --mono: 'IBM Plex Mono', monospace;
  --sans: 'IBM Plex Sans', sans-serif;
}

html { height: 100%; }

body {
  height: 100vh;
  overflow: hidden;
  background: var(--bg);
  color: var(--text);
  font-family: var(--sans);
  font-size: 14px;
  line-height: 1.5;
  display: flex;
  flex-direction: column;
}

/* ── Toolbar ── */
.toolbar {
  flex: 0 0 48px;
  display: flex;
  align-items: center;
  gap: 12px;
  padding: 0 16px;
  background: var(--surface);
  border-bottom: 1px solid var(--border);
}

.toolbar h1 {
  font-family: var(--mono);
  font-size: 15px;
  font-weight: 700;
  letter-spacing: 0.12em;
  text-transform: uppercase;
  color: var(--amber);
  white-space: nowrap;
}

.toolbar .sub {
  font-size: 11px;
  color: var(--text-dim);
  white-space: nowrap;
  margin-right: 8px;
}

#examples {
  font-family: var(--mono);
  font-size: 11px;
  background: var(--bg);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 8px;
  max-width: 220px;
}

#examples:focus { outline: none; border-color: var(--amber); }

.toolbar-spacer { flex: 1; }

.toolbar-auto {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-dim);
  display: flex;
  align-items: center;
  gap: 4px;
  white-space: nowrap;
  cursor: pointer;
}

.toolbar .btn {
  padding: 6px 14px;
  font-size: 11px;
}

/* ── Scrollbars ── */
* {
  scrollbar-width: thin;
  scrollbar-color: var(--border) transparent;
}
*::-webkit-scrollbar { width: 6px; height: 6px; }
*::-webkit-scrollbar-track { background: transparent; }
*::-webkit-scrollbar-thumb { background: var(--border); border-radius: 3px; }
*::-webkit-scrollbar-thumb:hover { background: var(--dim); }

/* ── Workspace: 3 columns ── */
.workspace {
  flex: 1;
  display: flex;
  overflow: hidden;
}

.panel-source {
  flex: 0 0 260px;
  min-width: 0;
  overflow-y: auto;
  padding: 16px;
  border-right: 1px solid var(--border);
}

.panel-overlay {
  flex: 0 0 340px;
  overflow-y: auto;
  padding: 16px;
  border-right: 1px solid var(--border);
}

.panel-qr {
  flex: 1 1 0;
  min-width: 0;
  overflow-y: auto;
  padding: 16px;
}

.panel-section {
  margin-bottom: 16px;
}

/* ── Section labels ── */
.section-label {
  font-family: var(--mono);
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.1em;
  text-transform: uppercase;
  color: var(--text-dim);
  margin-bottom: 10px;
}

/* ── Metadata editor (stacked / tall) ── */
.meta-editor {
  margin-bottom: 16px;
}

.meta-fields {
  display: flex;
  flex-direction: column;
  gap: 8px;
}

.meta-fields label {
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-faint);
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.meta-fields input {
  font-family: var(--mono);
  font-size: 12px;
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 8px;
}

.meta-fields input:focus,
.meta-fields textarea:focus {
  outline: none;
  border-color: var(--amber);
}

.meta-fields textarea {
  font-family: var(--mono);
  font-size: 12px;
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 8px;
  resize: vertical;
  min-height: 44px;
  line-height: 1.5;
  width: 100%;
}

.card-text-field {
  margin: 12px 0;
}

.card-text-field .card-text-label {
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-faint);
  margin-bottom: 4px;
}

.card-text-field textarea {
  width: 100%;
  min-height: 56px;
  font-family: var(--mono);
  font-size: 11px;
  line-height: 1.4;
  color: var(--text);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 6px 8px;
  resize: vertical;
}

.card-text-field textarea:focus {
  outline: none;
  border-color: var(--amber);
}

/* ── Dropzone ── */
.dropzone {
  border: 2px dashed var(--border-hi);
  border-radius: 8px;
  padding: 14px;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.2s, background 0.2s;
}

.dropzone:hover, .dropzone.dragover {
  border-color: var(--amber);
  background: var(--amber-dim);
}

.dropzone-icon {
  font-size: 22px;
  opacity: 0.4;
  margin-bottom: 2px;
}

.dropzone-text {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-dim);
}

.dropzone input[type="file"] {
  display: none;
}

/* ── Source editor ── */
.editor-wrap {
  position: relative;
  margin-top: 8px;
}

#source {
  width: 100%;
  min-height: 180px;
  font-family: var(--mono);
  font-size: 12px;
  line-height: 1.6;
  color: var(--text);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 12px;
  resize: vertical;
  tab-size: 2;
}

#source:focus {
  outline: none;
  border-color: var(--amber);
  box-shadow: 0 0 0 1px var(--amber-dim);
}

.source-info {
  display: flex;
  justify-content: space-between;
  margin-top: 4px;
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-faint);
}

/* ── Buttons ── */
.btn {
  font-family: var(--mono);
  font-size: 12px;
  font-weight: 600;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  padding: 8px 18px;
  border-radius: 5px;
  border: 1px solid var(--border);
  background: var(--surface);
  color: var(--text);
  cursor: pointer;
  transition: all 0.15s;
}

.btn:hover {
  border-color: var(--amber);
  color: var(--amber);
}

.btn-primary {
  background: var(--amber-dim);
  border-color: var(--amber);
  color: var(--amber);
}

.btn-primary:hover {
  background: rgba(212,160,23,0.25);
}

.btn:disabled {
  opacity: 0.3;
  cursor: default;
}

input[type="number"].btn {
  padding: 8px 6px;
  text-align: center;
  min-width: 60px;
  -moz-appearance: textfield;
}

/* ── Stats ── */
.result-stats {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 12px;
}

.stat {
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px 10px;
  flex: 1;
  min-width: 100px;
}

.stat-label {
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-faint);
  margin-bottom: 2px;
}

.stat-value {
  font-family: var(--mono);
  font-size: 15px;
  font-weight: 700;
  color: var(--text);
}

.stat-value.fits { color: var(--green); }
.stat-value.tight { color: var(--amber); }
.stat-value.overflow { color: var(--red); }

.stat-detail {
  font-family: var(--sans);
  font-size: 11px;
  color: var(--text-faint);
  margin-top: 2px;
}

/* ── Budget bar ── */
.budget-bar {
  height: 8px;
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 4px;
  margin-bottom: 12px;
  overflow: hidden;
}

.budget-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.4s, background 0.3s;
}

.budget-fill.fits { background: var(--green); }
.budget-fill.tight { background: var(--amber); }
.budget-fill.overflow { background: var(--red); }

/* ── Data URI output ── */
.uri-output {
  position: relative;
}

#data-uri {
  width: 100%;
  height: 64px;
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-dim);
  background: var(--surface);
  border: 1px solid var(--border);
  border-radius: 6px;
  padding: 8px;
  resize: vertical;
  word-break: break-all;
}

.uri-actions {
  display: flex;
  gap: 8px;
  margin-top: 6px;
}

/* ── Output tabs ── */
.output-tabs {
  display: flex;
  gap: 0;
  margin-bottom: 12px;
  border-bottom: 1px solid var(--border);
}

.output-tab {
  font-family: var(--mono);
  font-size: 11px;
  font-weight: 600;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-dim);
  background: none;
  border: none;
  border-bottom: 2px solid transparent;
  padding: 6px 14px;
  cursor: pointer;
  transition: color 0.15s, border-color 0.15s;
}

.output-tab:hover { color: var(--text); }
.output-tab.active {
  color: var(--amber);
  border-bottom-color: var(--amber);
}

.tab-content { display: none; }
.tab-content.active { display: block; }

/* ── QR canvas area ── */
.qr-canvas-area {
  display: flex;
  justify-content: center;
  padding: 12px 0;
}

.qr-wrap {
  text-align: center;
  padding: 12px;
  background: #fff;
  border-radius: 8px;
  display: inline-block;
}

.canvas-container {
  position: relative;
  display: inline-block;
  line-height: 0;
}

#qr-canvas {
  image-rendering: pixelated;
  max-width: 100%;
  height: auto;
}

#handle-canvas {
  position: absolute;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  touch-action: none;
  border-radius: 6px;
}

.qr-actions {
  display: flex;
  gap: 8px;
  justify-content: center;
  margin: 12px 0;
}

/* ── Card preview ── */
.card-preview-area {
  display: flex;
  justify-content: center;
  padding: 12px 0;
}

.card-preview-wrap {
  position: relative;
  display: inline-block;
  border-radius: 6px;
  box-shadow: 0 2px 12px rgba(0,0,0,0.3), 0 0 0 1px rgba(255,255,255,0.06);
  line-height: 0;
}

#card-preview {
  border-radius: 6px;
  max-width: 100%;
  height: auto;
}

.card-preview-label {
  text-align: center;
  font-family: var(--mono);
  font-size: 10px;
  color: var(--text-faint);
  margin-top: 8px;
}

.card-actions {
  display: flex;
  flex-wrap: wrap;
  gap: 8px;
  justify-content: center;
  align-items: center;
  margin: 12px 0;
}

/* ── QR settings (always visible) ── */
.qr-settings {
  display: flex;
  flex-wrap: wrap;
  gap: 10px;
  margin-bottom: 4px;
}

.qr-field {
  display: flex;
  flex-direction: column;
  gap: 4px;
}

.qr-field label {
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.06em;
  text-transform: uppercase;
  color: var(--text-faint);
}

.qr-field select,
.qr-field input[type="number"],
.qr-field input[type="color"] {
  font-family: var(--mono);
  font-size: 12px;
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 8px;
}

.qr-field select:focus,
.qr-field input:focus {
  outline: none;
  border-color: var(--amber);
}

.qr-field input[type="color"] {
  width: 40px;
  height: 30px;
  padding: 2px;
  cursor: pointer;
}

/* ── Overlay (middle panel) ── */
.overlay-dropzone {
  border: 1.5px dashed var(--border-hi);
  border-radius: 6px;
  padding: 12px;
  text-align: center;
  cursor: pointer;
  transition: border-color 0.2s;
  margin-bottom: 12px;
}

.overlay-dropzone:hover, .overlay-dropzone.dragover {
  border-color: var(--amber);
}

.overlay-dropzone-text {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--text-dim);
}

.overlay-controls {
  display: flex;
  flex-wrap: wrap;
  gap: 8px 12px;
  align-items: end;
}

.overlay-controls .qr-field {
  flex: 1;
  min-width: 70px;
}

.overlay-controls input[type="number"] {
  width: 100%;
  font-family: var(--mono);
  font-size: 12px;
  background: var(--surface);
  color: var(--text);
  border: 1px solid var(--border);
  border-radius: 4px;
  padding: 5px 8px;
  box-sizing: border-box;
}

/* ── Readability meter ── */
.readability {
  margin-top: 14px;
  padding: 10px;
  border: 1px solid var(--border);
  border-radius: 6px;
  background: var(--bg);
}

.readability-header {
  display: flex;
  justify-content: space-between;
  align-items: center;
  margin-bottom: 6px;
}

.readability-label {
  font-family: var(--mono);
  font-size: 10px;
  font-weight: 600;
  letter-spacing: 0.08em;
  text-transform: uppercase;
  color: var(--text-faint);
}

.readability-score {
  font-family: var(--mono);
  font-size: 16px;
  font-weight: 700;
}

.readability-score.good { color: var(--green); }
.readability-score.ok { color: var(--amber); }
.readability-score.bad { color: var(--red); }

.readability-bar {
  height: 6px;
  background: var(--surface);
  border-radius: 3px;
  overflow: hidden;
  margin-bottom: 6px;
}

.readability-fill {
  height: 100%;
  border-radius: 3px;
  transition: width 0.3s, background 0.3s;
}

.readability-fill.good { background: var(--green); }
.readability-fill.ok { background: var(--amber); }
.readability-fill.bad { background: var(--red); }

.readability-hints {
  font-family: var(--sans);
  font-size: 11px;
  color: var(--text-dim);
  line-height: 1.5;
}

.readability-hints li {
  margin-left: 16px;
  margin-bottom: 2px;
}

.readability-settings {
  display: flex; flex-wrap: wrap; gap: 6px 10px; align-items: center; margin-top: 6px;
  font-family: var(--mono); font-size: 11px; color: var(--dim);
}
.readability-settings label { display: flex; align-items: center; gap: 3px; white-space: nowrap; }
.readability-settings input {
  background: var(--surface); color: var(--fg); border: 1px solid var(--border);
  font-family: var(--mono); font-size: 11px; padding: 2px 4px; border-radius: 3px;
  width: 42px;
}

.readability-note {
  font-family: var(--mono); font-size: 10px; color: var(--dim);
  margin: 8px 0 0; line-height: 1.4; font-style: italic;
}

.readability-checking {
  font-family: var(--mono);
  font-size: 11px;
  color: var(--amber);
  animation: pulse-text 1s ease-in-out infinite;
}

@keyframes pulse-text {
  0%, 100% { opacity: 0.5; }
  50% { opacity: 1; }
}

/* ── Messages ── */
.msg {
  font-family: var(--sans);
  font-size: 12px;
  padding: 10px 14px;
  border-radius: 6px;
  margin-bottom: 12px;
}

.msg-warn {
  color: var(--amber);
  background: var(--amber-dim);
  border: 1px solid rgba(212,160,23,0.2);
}

.msg-err {
  color: var(--red);
  background: var(--red-dim);
  border: 1px solid rgba(192,57,43,0.2);
}

/* ── Footer ── */
footer {
  flex: 0 0 auto;
  padding: 6px 16px;
  border-top: 1px solid var(--border);
  font-size: 11px;
  color: var(--text-faint);
}

footer a { color: var(--text-dim); }

/* ── Test overlay ── */
.test-overlay {
  position: fixed; inset: 0; z-index: 9999;
  background: #000;
  display: flex; align-items: stretch; justify-content: stretch;
}
.test-overlay[hidden] { display: none; }
.test-iframe {
  flex: 1; border: none; background: #fff;
}
.test-close {
  position: absolute; top: 8px; right: 12px; z-index: 10000;
  background: rgba(0,0,0,0.6); color: #fff; border: 1px solid rgba(255,255,255,0.2);
  font-size: 24px; line-height: 1; width: 36px; height: 36px;
  border-radius: 50%; cursor: pointer; display: flex; align-items: center; justify-content: center;
  opacity: 0.5; transition: opacity 0.2s;
}
.test-close:hover { opacity: 1; }

/* ── Responsive ── */
@media (max-width: 900px) {
  body {
    height: auto;
    overflow: auto;
  }

  .toolbar {
    flex-wrap: wrap;
    height: auto;
    padding: 8px 12px;
    gap: 8px;
  }

  .toolbar h1 { font-size: 13px; }
  .toolbar-spacer { display: none; }
  #examples { max-width: none; flex: 1 1 100%; order: 10; }

  .workspace {
    flex-direction: column;
    overflow: visible;
  }

  .panel-source { order: 1; }
  .panel-qr { order: 2; }
  .panel-overlay { order: 3; }

  .panel-source, .panel-overlay, .panel-qr {
    flex: none;
    width: 100%;
    overflow-y: visible;
    border-right: none;
  }

  .panel-source, .panel-overlay {
    border-bottom: 1px solid var(--border);
  }

  .panel-overlay {
    flex-basis: auto;
  }

  #source { min-height: 140px; }
}
</style>
</head>

<body>

  <!-- ── Toolbar ── -->
  <div class="toolbar">
    <h1>GCUES Press</h1>
    <span class="sub">cartridge generator</span>
    <select id="examples">
      <option value="">Load example...</option>
    </select>
    <div class="toolbar-spacer"></div>
    <label class="toolbar-auto">
      <input type="checkbox" id="chk-debug"> Debug
    </label>
    <label class="toolbar-auto">
      <input type="checkbox" id="chk-auto" checked> Auto
    </label>
    <button type="button" class="btn" id="btn-minify">Minify</button>
    <button type="button" class="btn btn-primary" id="btn-press">Press</button>
  </div>

  <!-- ── Workspace: 3 columns ── -->
  <div class="workspace">

    <!-- ── Col 1: Source ── -->
    <div class="panel-source">

      <div class="meta-editor">
        <div class="section-label">Metadata</div>
        <div class="meta-fields">
          <label>Title <input id="meta-title" type="text"></label>
          <label>Author <input id="meta-author" type="text"></label>
          <label>Desc <textarea id="meta-desc" rows="2" placeholder="Short description"></textarea></label>
          <label>Extra <input id="meta-extra" type="text" placeholder="key: val; key: val"></label>
        </div>
      </div>

      <div class="panel-section">
        <div class="section-label">Source HTML</div>
        <div class="dropzone" id="dropzone">
          <div class="dropzone-icon">&#x1F4C4;</div>
          <div class="dropzone-text">Drop .html / .pdf or click to browse</div>
          <input type="file" id="file-input" accept=".html,.htm,.pdf">
        </div>
        <div class="editor-wrap">
          <textarea id="source" placeholder="Paste or type cartridge HTML..."></textarea>
          <div class="source-info">
            <span id="source-size">0 bytes</span>
            <span id="source-meta"></span>
          </div>
        </div>
      </div>

      <div class="panel-section" id="uri-section" style="display:none">
        <div class="section-label">Data URI</div>
        <div class="uri-output">
          <textarea id="data-uri" readonly></textarea>
          <div class="uri-actions">
            <button type="button" class="btn" id="btn-copy">Copy URI</button>
            <button type="button" class="btn" id="btn-test">Test in GCUES</button>
          </div>
        </div>
      </div>

    </div>

    <!-- ── Col 2: Overlay ── -->
    <div class="panel-overlay">

      <div class="section-label">Image Overlay</div>

      <div class="overlay-dropzone" id="overlay-dropzone">
        <div class="overlay-dropzone-text">Drop a PNG/SVG or click to browse</div>
        <input type="file" id="overlay-input" accept="image/*" style="display:none;">
      </div>

      <div class="overlay-controls">
        <div class="qr-field">
          <label>X %</label>
          <input type="number" id="ov-x" value="50" step="1">
        </div>
        <div class="qr-field">
          <label>Y %</label>
          <input type="number" id="ov-y" value="50" step="1">
        </div>
        <div class="qr-field">
          <label>Scale %</label>
          <input type="number" id="ov-scale" value="25" min="1" step="1">
        </div>
        <div class="qr-field">
          <label>Opacity %</label>
          <input type="number" id="ov-opacity" value="100" min="0" max="100" step="1">
        </div>
        <div class="qr-field">
          <label>Rotation</label>
          <input type="number" id="ov-rotation" value="0" step="1">
        </div>
      </div>
      <div style="display:flex;gap:6px;margin-top:6px;">
        <button type="button" class="btn" id="btn-ov-center" style="padding:5px 10px;">Center</button>
        <button type="button" class="btn" id="btn-ov-clear" style="padding:5px 10px;">Clear</button>
      </div>

      <div class="readability" id="readability">
        <div class="readability-header">
          <span class="readability-label">Scan readability</span>
          <span class="readability-score" id="read-score">&mdash;</span>
        </div>
        <div class="readability-bar">
          <div class="readability-fill" id="read-fill"></div>
        </div>
        <div class="readability-settings">
          <label title="Number of scale variations to test">Samples <input type="number" id="read-samples" value="5" min="3" max="50"></label>
          <label title="Smallest scale factor (%)">Min <input type="number" id="read-min" value="55" min="10" max="95">%</label>
          <label title="Largest scale factor (%)">Max <input type="number" id="read-max" value="115" min="105" max="300">%</label>
        </div>
        <div id="read-status"></div>
        <p class="readability-note">Approximate test &mdash; rescales the bitmap and runs jsQR at each size. Real phone cameras have better decoders and optics, so actual results will vary. When in doubt, scan it with your phone.</p>
        <button type="button" class="btn" id="btn-find-mask" style="margin-top:8px;">Find best mask</button>
      </div>

    </div>

    <!-- ── Col 3: QR Output ── -->
    <div class="panel-qr">

      <div class="panel-section">
        <div class="section-label">QR Settings</div>
        <div class="qr-settings">
          <div class="qr-field">
            <label>Error Correction</label>
            <select id="qr-ecc">
              <option value="LOW" selected>Low (7%)</option>
              <option value="MEDIUM">Medium (15%)</option>
              <option value="QUARTILE">Quartile (25%)</option>
              <option value="HIGH">High (30%)</option>
            </select>
          </div>
          <div class="qr-field">
            <label>Mask</label>
            <select id="qr-mask">
              <option value="-1" selected>Auto</option>
              <option value="0">0</option>
              <option value="1">1</option>
              <option value="2">2</option>
              <option value="3">3</option>
              <option value="4">4</option>
              <option value="5">5</option>
              <option value="6">6</option>
              <option value="7">7</option>
            </select>
          </div>
          <div class="qr-field">
            <label>Min ver</label>
            <input type="number" id="qr-min-ver" value="1" min="1" max="40" style="width:56px;">
          </div>
          <div class="qr-field">
            <label>Max ver</label>
            <input type="number" id="qr-max-ver" value="40" min="1" max="40" style="width:56px;">
          </div>
          <div class="qr-field">
            <label>Boost ECC</label>
            <select id="qr-boost">
              <option value="1" selected>Yes</option>
              <option value="0">No</option>
            </select>
          </div>
          <div class="qr-field">
            <label>FG</label>
            <input type="color" id="qr-fg" value="#0a0a08">
          </div>
          <div class="qr-field">
            <label>BG</label>
            <input type="color" id="qr-bg" value="#ffffff">
          </div>
          <div class="qr-field">
            <label>Scale</label>
            <input type="number" id="qr-scale" value="0" min="0" max="20" style="width:56px;" title="0 = auto">
          </div>
        </div>
      </div>

      <div id="msg-area"></div>

      <!-- Hidden QR canvas (used internally by overlay, readability, download) -->
      <div style="display:none;">
        <canvas id="qr-canvas" width="1" height="1"></canvas>
      </div>

      <!-- ── Card preview ── -->
      <div class="card-preview-area">
        <div class="card-preview-wrap">
          <canvas id="card-preview" width="1" height="1"></canvas>
          <canvas id="handle-canvas" width="1" height="1"></canvas>
        </div>
      </div>
      <div class="card-preview-label" id="card-preview-label"></div>
      <div class="card-text-field">
        <div class="card-text-label">
          Card text
          <label style="margin-left:12px;font-weight:400;font-size:10px;text-transform:none;letter-spacing:0;">
            <input type="checkbox" id="chk-auto-title" checked> Auto title/author
          </label>
          <label style="margin-left:8px;font-weight:400;font-size:10px;text-transform:none;letter-spacing:0;">
            <input type="checkbox" id="chk-wrap-text" checked> Wrap below
          </label>
          <span style="margin-left:8px;font-size:9px;color:var(--text-faint);font-weight:400;text-transform:none;letter-spacing:0;"># title &ensp; ~ subtitle &ensp; **bold** &ensp; *italic*</span>
        </div>
        <textarea id="card-text" rows="3" placeholder="Auto-fills from desc (editable)"></textarea>
      </div>
      <div class="card-actions">
        <select id="pdf-size" class="btn" style="text-transform:none;font-weight:400;">
          <option value="tcg">TCG 63.5&times;88.9mm</option>
          <option value="tarot">Tarot 70&times;120mm</option>
          <option value="custom">Custom&hellip;</option>
        </select>
        <span id="custom-size-inputs" style="display:none;">
          <input type="number" id="custom-w" min="30" max="300" step="0.1" value="63.5" class="btn" placeholder="W">&times;<input type="number" id="custom-h" min="30" max="300" step="0.1" value="88.9" class="btn" placeholder="H"><span style="font-size:9px;color:var(--text-dim);margin-left:2px;">mm</span>
        </span>
        <span style="font-size:9px;color:var(--text-dim);">safe</span><input type="number" id="safe-zone" min="0" max="10" step="0.1" value="2" class="btn"><span style="font-size:9px;color:var(--text-dim);">mm</span>
        <label style="font-size:10px;color:var(--text-dim);cursor:pointer;"><input type="checkbox" id="chk-data-page" checked style="vertical-align:middle;"> Data page</label>
        <button type="button" class="btn btn-primary" id="btn-dl-pdf">Download PDF</button>
        <button type="button" class="btn" id="btn-dl-qr">QR PNG</button>
      </div>
      <div style="font-size:9px;color:var(--text-faint);padding:2px 0;">For print production, open the PDF in Affinity/Illustrator to convert to CMYK and export as PDF/X.</div>

      <div class="result-stats">
        <div class="stat">
          <div class="stat-label">Mode</div>
          <div class="stat-value" id="stat-mode">&mdash;</div>
        </div>
        <div class="stat">
          <div class="stat-label">URI size</div>
          <div class="stat-value" id="stat-uri-size">&mdash;</div>
          <div class="stat-detail" id="stat-uri-detail"></div>
        </div>
        <div class="stat">
          <div class="stat-label">QR ver</div>
          <div class="stat-value" id="stat-qr-ver">&mdash;</div>
          <div class="stat-detail" id="stat-qr-detail"></div>
        </div>
      </div>

      <div class="budget-bar">
        <div class="budget-fill" id="budget-fill"></div>
      </div>

    </div>

  </div>

  <div id="test-overlay" class="test-overlay" hidden>
    <button type="button" class="test-close" id="test-close" title="Close (Esc)">&times;</button>
    <iframe id="test-iframe" class="test-iframe"></iframe>
  </div>

  <footer>
    GCUES Press &mdash;
    QR: <a href="https://www.nayuki.io/page/qr-code-generator-library">qrcodegen</a> (Nayuki, MIT).
    Decode: <a href="https://github.com/cozmo/jsQR">jsQR</a> (Wolfe, Apache-2.0).
    PDF: <a href="https://github.com/parallax/jsPDF">jsPDF</a> (parallax, MIT).
    Compression: native <code>CompressionStream</code>.
  </footer>

<!-- ── Vendored: qrcodegen (injected by build.js) ── -->
<script>
// __INJECT_QRCODEGEN__
</script>

<!-- ── Vendored: jsQR (injected by build.js) ── -->
<script>
// __INJECT_JSQR__
</script>

<!-- ── Vendored: jsPDF (injected by build.js) ── -->
<script>
// __INJECT_JSPDF__
</script>

<script>
/* ══════════════════════════════════════════════════
   GCUES Press — Runtime
   ══════════════════════════════════════════════════ */
(function() {
'use strict';

const QR_CAPACITY = { LOW: 2953, MEDIUM: 2331, QUARTILE: 1663, HIGH: 1273 };

const $ = (s) => document.querySelector(s);
const $source       = $('#source');
const $msgArea      = $('#msg-area');
const $dataUri      = $('#data-uri');
const $qrCanvas     = $('#qr-canvas');
const $handleCanvas = $('#handle-canvas');
const $metaTitle    = $('#meta-title');
const $metaAuthor   = $('#meta-author');
const $metaExtra    = $('#meta-extra');
const $metaDesc     = $('#meta-desc');
const $cardText     = $('#card-text');
const $examples     = $('#examples');

// State flag: have we pressed at least once?
let hasResults = false;
let lastHash = '';

// ══════════════════════════════════════════════════
// HASH ART GENERATOR
// ══════════════════════════════════════════════════

async function hashHTML(html) {
  const buf = new TextEncoder().encode(html);
  const digest = await crypto.subtle.digest('SHA-256', buf);
  return Array.from(new Uint8Array(digest)).map(b => b.toString(16).padStart(2, '0')).join('');
}

function generateHashArt(hexHash, sizePx) {
  const COLORS = ['#7b68ae', '#c0392b', '#d4a017', '#2e86c1'];
  const hb = [];
  for (let i = 0; i < 32; i++) hb.push(parseInt(hexHash.substr(i * 2, 2), 16) || 0);

  const canvas = document.createElement('canvas');
  canvas.width = sizePx;
  canvas.height = sizePx;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = '#ffffff';
  ctx.fillRect(0, 0, sizePx, sizePx);

  const cell = sizePx / 8;
  for (let row = 0; row < 8; row++) {
    for (let col = 0; col < 4; col++) {
      const idx = row * 4 + col;
      if ((hb[idx >> 3] >> (idx & 7)) & 1) {
        ctx.fillStyle = COLORS[(hb[4 + (idx >> 2)] >> ((idx & 3) * 2)) & 3];
        ctx.fillRect(col * cell, row * cell, cell, cell);
        ctx.fillRect((7 - col) * cell, row * cell, cell, cell);
      }
    }
  }
  return canvas;
}


function wrapCardText(ctx, text, maxWidth) {
  if (!text) return [];
  const lines = [];
  for (const raw of text.split('\n')) {
    if (!raw) { lines.push(''); continue; }
    if (ctx.measureText(raw).width <= maxWidth) {
      lines.push(raw);
    } else {
      let current = '';
      for (const ch of raw) {
        if (ctx.measureText(current + ch).width > maxWidth && current) {
          lines.push(current);
          current = ch;
        } else {
          current += ch;
        }
      }
      if (current) lines.push(current);
    }
  }
  return lines;
}

// Parse card markup: # title, ~ subtitle, **bold**, *italic*, plain mono
function parseCardMarkup(text) {
  if (!text) return [];
  return text.split('\n').map(line => {
    if (line.startsWith('# ')) return { style: 'title', segments: [{ text: line.slice(2), style: 'title' }] };
    if (line.startsWith('~ ')) return { style: 'subtitle', segments: [{ text: line.slice(2), style: 'subtitle' }] };
    // Inline: **bold** and *italic* within mono text
    const segments = [];
    const re = /\*\*(.+?)\*\*|\*(.+?)\*/g;
    let last = 0, m;
    while ((m = re.exec(line)) !== null) {
      if (m.index > last) segments.push({ text: line.slice(last, m.index), style: 'mono' });
      if (m[1] !== undefined) segments.push({ text: m[1], style: 'bold' });
      else segments.push({ text: m[2], style: 'italic' });
      last = m.index + m[0].length;
    }
    if (last < line.length) segments.push({ text: line.slice(last), style: 'mono' });
    if (!segments.length) segments.push({ text: '', style: 'mono' });
    return { style: 'mixed', segments };
  });
}

// Draw parsed segments on a canvas context, returns y after last line.
// float: optional { wrapY, fullX, fullMaxW } — after curY passes wrapY,
// text uses fullX and fullMaxW (wraps below the identicon).
function drawCardMarkup(ctx, parsed, x, y, maxW, fonts, colors, lineHeights, float) {
  let curY = y;
  function getX() { return (float && curY >= float.wrapY) ? float.fullX : x; }
  function getW() { return (float && curY >= float.wrapY) ? float.fullMaxW : maxW; }

  for (const line of parsed) {
    const lx = getX(), lw = getW();
    if (line.style === 'title' || line.style === 'subtitle') {
      ctx.font = fonts[line.style];
      ctx.fillStyle = colors[line.style];
      ctx.fillText(line.segments[0].text, lx, curY);
      curY += lineHeights[line.style];
    } else {
      let curX = lx;
      for (const seg of line.segments) {
        ctx.font = fonts[seg.style];
        ctx.fillStyle = colors[seg.style];
        const chars = [...seg.text];
        for (const ch of chars) {
          const w = ctx.measureText(ch).width;
          const cx = getX(), cw = getW();
          if (curX + w > cx + cw && curX > cx) {
            curY += lineHeights.mono;
            curX = getX();
          }
          ctx.fillText(ch, curX, curY);
          curX += w;
        }
      }
      curY += lineHeights.mono;
    }
  }
  return curY;
}

// ══════════════════════════════════════════════════
// EXAMPLES
// ══════════════════════════════════════════════════

const EXAMPLES = {
  hello:
    '<h1 style="font-family:monospace;text-align:center;margin-top:40vh">Hello from GCUES!</h1>',

  gradient:
    '<!-- gcues title: Gradient Wave; author: GCU --><body style="margin:0;height:100vh;background:linear-gradient(45deg,#ff006e,#0ff,#ff006e);background-size:400%;animation:g 3s ease infinite"><style>@keyframes g{0%,100%{background-position:0 50%}50%{background-position:100% 50%}}</style>',

  ball:
    '<!-- gcues title: Bouncing Ball; author: GCU Lab --><canvas id=c><\/canvas><script>const c=document.getElementById(\'c\'),x=c.getContext(\'2d\');c.width=innerWidth;c.height=innerHeight;let bx=100,by=100,dx=3,dy=2;function d(){x.fillStyle=\'#0a0a08\';x.fillRect(0,0,c.width,c.height);bx+=dx;by+=dy;if(bx<20||bx>c.width-20)dx=-dx;if(by<20||by>c.height-20)dy=-dy;x.beginPath();x.arc(bx,by,18,0,7);x.fillStyle=\'#d4a017\';x.fill();requestAnimationFrame(d)}d()<\/script>',

  clock:
    '<!-- gcues title: Amber Clock --><body style="margin:0;display:flex;align-items:center;justify-content:center;height:100vh;background:#0a0a08;font-family:monospace"><div id=t style="font-size:15vw;color:#d4a017;text-shadow:0 0 30px rgba(212,160,23,0.4)"><\/div><script>setInterval(()=>t.textContent=new Date().toLocaleTimeString(),500)<\/script>',

  notepad:
    '<!-- gcues title: Notepad; author: GCU --><body style="margin:0;font-family:sans-serif"><div contenteditable style="padding:24px;min-height:100vh;font-size:16px;line-height:1.6;outline:none;background:#f4efe6;color:#3a3530" spellcheck=false>Start typing...<\/div>'
};

const EXAMPLE_LABELS = {
  hello: 'Hello World',
  gradient: 'Gradient Wave',
  ball: 'Bouncing Ball',
  clock: 'Amber Clock',
  notepad: 'Notepad'
};

for (var key in EXAMPLES) {
  var opt = document.createElement('option');
  opt.value = key;
  opt.textContent = EXAMPLE_LABELS[key] + ' (' + new Blob([EXAMPLES[key]]).size + ' B)';
  $examples.appendChild(opt);
}

// ══════════════════════════════════════════════════
// METADATA
// ══════════════════════════════════════════════════

let metaSyncing = false;

function parseMeta(html) {
  const m = html.match(/<!--\s*gcues\s+([\s\S]+?)\s*-->/i);
  if (!m) return {};
  const meta = {};
  m[1].split(';').forEach(pair => {
    const idx = pair.indexOf(':');
    if (idx > 0) {
      const k = pair.slice(0, idx).trim().toLowerCase();
      const v = pair.slice(idx + 1).trim();
      if (k && v) meta[k] = v;
    }
  });
  return meta;
}

function updateSourceInfo() {
  const html = $source.value;
  const size = new Blob([html]).size;
  $('#source-size').textContent = size + ' bytes';
  const meta = parseMeta(html);
  const parts = [];
  if (meta.title) parts.push(meta.title);
  if (meta.author) parts.push('by ' + meta.author);
  $('#source-meta').textContent = parts.length ? parts.join(' \u2014 ') : '';
}

function syncSourceToMeta() {
  if (metaSyncing) return;
  metaSyncing = true;
  const meta = parseMeta($source.value);
  $metaTitle.value = meta.title || '';
  $metaAuthor.value = meta.author || '';
  $metaDesc.value = meta.desc || '';
  $cardText.placeholder = meta.desc || 'Auto-fills from desc (editable)';
  const extras = [];
  for (var k in meta) {
    if (k !== 'title' && k !== 'author' && k !== 'desc') extras.push(k + ': ' + meta[k]);
  }
  $metaExtra.value = extras.join('; ');
  metaSyncing = false;
}

function syncMetaToSource() {
  if (metaSyncing) return;
  metaSyncing = true;
  const parts = [];
  const title = $metaTitle.value.trim();
  const author = $metaAuthor.value.trim();
  const desc = $metaDesc.value.replace(/\n/g, ' ').trim();
  const extra = $metaExtra.value.trim();
  if (title) parts.push('title: ' + title);
  if (author) parts.push('author: ' + author);
  if (desc) parts.push('desc: ' + desc);
  if (extra) parts.push(extra);
  const comment = parts.length ? '<!-- gcues ' + parts.join('; ') + ' -->' : '';
  const html = $source.value;
  const existing = html.match(/<!--\s*gcues\s+[\s\S]+?\s*-->/i);
  if (existing) {
    $source.value = comment ? html.replace(existing[0], comment) : html.replace(/<!--\s*gcues\s+[\s\S]+?\s*-->\s*/i, '');
  } else if (comment) {
    $source.value = comment + '\n' + html;
  }
  updateSourceInfo();
  metaSyncing = false;
  if ($('#chk-auto').checked) {
    clearTimeout(pressTimer);
    pressTimer = setTimeout(press, 500);
  }
}

// ══════════════════════════════════════════════════
// MINIFICATION
// ══════════════════════════════════════════════════

function minifyHTML(html) {
  let metaComment = '';
  html = html.replace(/(<!--\s*gcues\s+.+?\s*-->)\s*/i, (_, m) => { metaComment = m; return ''; });
  html = html.replace(/<!--[\s\S]*?-->/g, '');
  html = html.replace(/>\s+</g, '><');
  html = html.replace(/\s{2,}/g, ' ');
  html = html.trim();
  if (metaComment) html = metaComment + html;
  return html;
}

// ══════════════════════════════════════════════════
// COMPRESSION
// ══════════════════════════════════════════════════

async function compressHTML(html) {
  const encoded = new TextEncoder().encode(html);
  const cs = new CompressionStream('deflate-raw');
  const writer = cs.writable.getWriter();
  writer.write(encoded);
  writer.close();
  const reader = cs.readable.getReader();
  const chunks = [];
  while (true) { const { done, value } = await reader.read(); if (done) break; chunks.push(value); }
  const totalLen = chunks.reduce((s, c) => s + c.length, 0);
  const compressed = new Uint8Array(totalLen);
  let offset = 0;
  for (const chunk of chunks) { compressed.set(chunk, offset); offset += chunk.length; }
  let binary = '';
  for (let i = 0; i < compressed.length; i++) binary += String.fromCharCode(compressed[i]);
  const b64 = btoa(binary);
  return "<script>fetch('data:application/octet-stream;base64," + b64 + "').then(r=>r.blob()).then(b=>new Response(b.stream().pipeThrough(new DecompressionStream('deflate-raw'))).text()).then(h=>{document.open();document.write(h);document.close()})<\\/script>";
}

function makeRawDataURI(html) { return 'data:text/html,' + encodeURIComponent(html); }

async function makeCompressedDataURI(html) {
  return 'data:text/html,' + encodeURIComponent(await compressHTML(html));
}

// ══════════════════════════════════════════════════
// QR CODE RENDERING
// ══════════════════════════════════════════════════

function getQRSettings() {
  const QrCode = qrcodegen.QrCode;
  return {
    ecc: QrCode.Ecc[$('#qr-ecc').value],
    mask: parseInt($('#qr-mask').value),
    minVer: parseInt($('#qr-min-ver').value) || 1,
    maxVer: parseInt($('#qr-max-ver').value) || 40,
    boost: $('#qr-boost').value === '1',
    fg: $('#qr-fg').value,
    bg: $('#qr-bg').value,
    scale: parseInt($('#qr-scale').value) || 0
  };
}

function renderQRToCanvas(canvas, dataUri, settingsOverride) {
  const QrCode = qrcodegen.QrCode;
  const QrSeg = qrcodegen.QrSegment;
  const s = Object.assign(getQRSettings(), settingsOverride || {});
  let qr;
  try {
    qr = QrCode.encodeSegments(QrSeg.makeSegments(dataUri), s.ecc, s.minVer, s.maxVer, s.mask, s.boost);
  } catch (e) {
    return { ok: false, error: 'Data too large for QR (' + dataUri.length + ' chars)' };
  }
  const modules = qr.size;
  const scale = s.scale > 0 ? s.scale : Math.max(4, Math.floor(400 / modules));
  const border = s.border !== undefined ? s.border : 4;
  const totalSize = (modules + border * 2) * scale;
  canvas.width = totalSize;
  canvas.height = totalSize;
  const ctx = canvas.getContext('2d');
  ctx.fillStyle = s.bg;
  ctx.fillRect(0, 0, totalSize, totalSize);
  ctx.fillStyle = s.fg;
  for (let y = 0; y < modules; y++)
    for (let x = 0; x < modules; x++)
      if (qr.getModule(x, y))
        ctx.fillRect((x + border) * scale, (y + border) * scale, scale, scale);
  return { ok: true, version: qr.version, modules, ecc: s.ecc };
}

function renderQR(dataUri) {
  return renderQRToCanvas($qrCanvas, dataUri);
}

// Composite overlay onto a canvas. If qrRegion is provided, remap card-space
// overlay coordinates into the QR-only canvas (for readability testing).
// qrRegion: { qrX, qrY, qrSize, cardW, cardH } — all in mm.
function compositeOverlayToCanvas(canvas, qrRegion) {
  if (!overlayImg) return;
  const ctx = canvas.getContext('2d');
  const cw = canvas.width, ch = canvas.height;
  const xPct = parseInt($('#ov-x').value) / 100;
  const yPct = parseInt($('#ov-y').value) / 100;
  const scalePct = parseInt($('#ov-scale').value) / 100;
  const opacity = parseInt($('#ov-opacity').value) / 100;
  const rotation = (parseInt($('#ov-rotation').value) || 0) * Math.PI / 180;
  const maxDim = Math.max(overlayImg.naturalWidth, overlayImg.naturalHeight);

  let cx, cy, targetSize;
  if (qrRegion) {
    // Overlay coords are card-relative %, remap to QR canvas pixels
    const { qrX, qrY, qrSize, cardW, cardH } = qrRegion;
    cx = ((xPct * cardW - qrX) / qrSize) * cw;
    cy = ((yPct * cardH - qrY) / qrSize) * ch;
    targetSize = (scalePct * cardW / qrSize) * cw;
  } else {
    cx = xPct * cw;
    cy = yPct * ch;
    targetSize = cw * scalePct;
  }

  const ratio = targetSize / maxDim;
  const ow = overlayImg.naturalWidth * ratio;
  const oh = overlayImg.naturalHeight * ratio;
  ctx.save();
  ctx.globalAlpha = opacity;
  ctx.translate(cx, cy);
  ctx.rotate(rotation);
  ctx.drawImage(overlayImg, -ow / 2, -oh / 2, ow, oh);
  ctx.restore();
}

function getScaleVariations() {
  const n = Math.max(3, Math.min(50, parseInt($('#read-samples').value) || 5));
  const lo = (parseInt($('#read-min').value) || 55) / 100;
  const hi = (parseInt($('#read-max').value) || 115) / 100;
  // Generate n evenly spaced steps, then ensure 1.0 is always included
  const set = new Set();
  for (let i = 0; i < n; i++) {
    const t = i / (n - 1);                     // 0..1
    const s = lo + (hi - lo) * t;
    set.add(Math.round(s * 1000) / 1000);       // round to 3dp to avoid float noise
  }
  set.add(1.0);                                  // always test native scale
  return [...set].sort((a, b) => a - b);
}

async function scoreCanvas(canvas) {
  const variations = getScaleVariations();
  let successes = 0;
  for (const sc of variations) {
    const t = document.createElement('canvas');
    t.width = Math.round(canvas.width * sc);
    t.height = Math.round(canvas.height * sc);
    t.getContext('2d').drawImage(canvas, 0, 0, t.width, t.height);
    if (await decodeCanvas(t) !== null) successes++;
  }
  return successes;
}

async function findBestMask() {
  if (!lastQrDataUri || !overlayImg) return;
  if (!hasJsQR && !hasBarcodeDetector) return;
  const $btn = $('#btn-find-mask'), $status = $('#read-status');
  const origText = $btn.textContent;
  $btn.disabled = true;
  const region = getQrRegion();
  const results = [];
  for (let mask = 0; mask <= 7; mask++) {
    $btn.textContent = 'Testing mask ' + mask + '/7\u2026';
    const off = document.createElement('canvas');
    const r = renderQRToCanvas(off, lastQrDataUri, { mask });
    if (!r.ok) { results.push({ mask, score: 0 }); continue; }
    compositeOverlayToCanvas(off, region);
    results.push({ mask, score: await scoreCanvas(off) });
    await new Promise(r => setTimeout(r, 10));
  }
  $btn.textContent = 'Testing auto\u2026';
  const offA = document.createElement('canvas');
  const rA = renderQRToCanvas(offA, lastQrDataUri, { mask: -1 });
  if (rA.ok) { compositeOverlayToCanvas(offA, region); results.push({ mask: -1, score: await scoreCanvas(offA), label: 'auto' }); }
  const total = getScaleVariations().length;
  results.sort((a, b) => b.score - a.score);
  const best = results[0];
  maskResultsShown = true;
  const barLen = 10;
  $status.innerHTML = '<ul class="readability-hints">' + results.map(r => {
    const label = r.label || ('mask ' + r.mask);
    const pct = Math.round((r.score / total) * 100);
    const filled = Math.round(barLen * r.score / total);
    return '<li>' + label + ': ' + '\u2588'.repeat(filled) + '\u2591'.repeat(barLen - filled) + ' ' + r.score + '/' + total + ' (' + pct + '%)' + (r === best ? ' \u2190 best' : '') + '</li>';
  }).join('') + '</ul>';
  $('#qr-mask').value = String(best.mask);
  refreshComposite();
  $btn.textContent = origText;
  $btn.disabled = false;
}

// ══════════════════════════════════════════════════
// PRESS
// ══════════════════════════════════════════════════

async function press() {
  const html = $source.value;
  if (!html.trim()) return;
  $msgArea.innerHTML = '';
  lastHash = await hashHTML(html);

  const rawUri = makeRawDataURI(html);
  let compUri = null, useCompressed = false;
  try { compUri = await makeCompressedDataURI(html); if (compUri.length < rawUri.length) useCompressed = true; } catch {}

  const finalUri = useCompressed ? compUri : rawUri;
  const uriBytesRaw = new Blob([rawUri]).size;
  const uriBytesComp = compUri ? new Blob([compUri]).size : null;
  const uriBytesUsed = new Blob([finalUri]).size;

  $('#stat-mode').textContent = useCompressed ? 'Compressed' : 'Raw';
  $('#stat-mode').className = 'stat-value';

  const eccName = $('#qr-ecc').value;
  const qrMax = QR_CAPACITY[eccName] || QR_CAPACITY.LOW;
  const pct = uriBytesUsed / qrMax * 100;
  const cls = pct <= 75 ? 'fits' : pct <= 100 ? 'tight' : 'overflow';

  const $uriSize = $('#stat-uri-size');
  $uriSize.textContent = uriBytesUsed.toLocaleString() + ' B';
  $uriSize.className = 'stat-value ' + cls;

  let detail = 'raw: ' + uriBytesRaw.toLocaleString();
  if (uriBytesComp !== null) detail += ' / comp: ' + uriBytesComp.toLocaleString();
  $('#stat-uri-detail').textContent = detail;

  const $fill = $('#budget-fill');
  $fill.style.width = Math.min(100, pct).toFixed(1) + '%';
  $fill.className = 'budget-fill ' + cls;

  $dataUri.value = finalUri;
  $('#uri-section').style.display = '';

  lastQrDataUri = finalUri;
  const qrResult = renderQR(finalUri);
  syncHandleCanvas();
  if (qrResult.ok && overlayImg) { compositeOverlay(); checkReadability(); }

  const $qrVer = $('#stat-qr-ver');
  if (qrResult.ok) {
    $qrVer.textContent = 'V' + qrResult.version;
    $qrVer.className = 'stat-value ' + (qrResult.version <= 30 ? 'fits' : 'tight');
    $('#stat-qr-detail').textContent = qrResult.modules + '\u00D7' + qrResult.modules;
  } else {
    $qrVer.textContent = 'N/A';
    $qrVer.className = 'stat-value overflow';
    $('#stat-qr-detail').textContent = '';
    $msgArea.innerHTML = '<div class="msg msg-err">' + qrResult.error + '</div>';
  }

  if (pct > 100) $msgArea.innerHTML += '<div class="msg msg-warn">Exceeds QR V40 capacity. Minify or simplify.</div>';
  else if (pct > 85) $msgArea.innerHTML += '<div class="msg msg-warn">Tight fit. Consider reducing size.</div>';

  hasResults = true;

  // Update card preview if that tab is visible
  if (typeof renderCardPreview === 'function') renderCardPreview();
}

// ══════════════════════════════════════════════════
// OVERLAY + READABILITY
// ══════════════════════════════════════════════════

let overlayImg = null;
let lastQrDataUri = null;

function getQrRegion() {
  const preset = getPreset();
  const meta = parseMeta($source.value);
  const L = cardLayout(preset);
  return { qrX: L.qrX, qrY: L.qrY, qrSize: L.qrSize, cardW: L.w, cardH: L.h };
}

function compositeOverlay() { compositeOverlayToCanvas($qrCanvas, getQrRegion()); }

function refreshComposite() {
  if (lastQrDataUri) {
    renderQR(lastQrDataUri);
    if (overlayImg) { compositeOverlay(); checkReadability(); }
    syncHandleCanvas();
    drawHandles();
    if (typeof renderCardPreview === 'function') renderCardPreview();
  }
}

const hasBarcodeDetector = typeof BarcodeDetector !== 'undefined';
const hasJsQR = typeof jsQR !== 'undefined';
let checkTimer = null;
let maskResultsShown = false;

async function checkReadability() {
  if (maskResultsShown) return;
  const $score = $('#read-score'), $fill = $('#read-fill'), $status = $('#read-status');
  if (!hasJsQR && !hasBarcodeDetector) {
    $status.innerHTML = '<div class="readability-hints">No decoder. Test with phone camera.</div>';
    $score.textContent = '?'; $score.className = 'readability-score'; $fill.style.width = '0%'; return;
  }
  if (!overlayImg) {
    $score.textContent = '\u2014'; $score.className = 'readability-score'; $fill.style.width = '0%'; $status.innerHTML = ''; return;
  }
  $status.innerHTML = '<div class="readability-checking">Checking\u2026</div>';
  clearTimeout(checkTimer);
  checkTimer = setTimeout(async () => { await runReadabilityTest($score, $fill, $status); }, 200);
}

async function decodeCanvas(canvas) {
  if (hasJsQR) {
    const ctx = canvas.getContext('2d');
    const d = ctx.getImageData(0, 0, canvas.width, canvas.height);
    const r = jsQR(d.data, canvas.width, canvas.height);
    if (r) return r.data;
  }
  if (hasBarcodeDetector) {
    try { const codes = await new BarcodeDetector({ formats: ['qr_code'] }).detect(canvas); if (codes.length) return codes[0].rawValue; } catch {}
  }
  return null;
}

async function runReadabilityTest($score, $fill, $status) {
  const variations = getScaleVariations();
  const total = variations.length;
  let successes = 0, correct = 0;
  for (const sc of variations) {
    const t = document.createElement('canvas');
    t.width = Math.round($qrCanvas.width * sc);
    t.height = Math.round($qrCanvas.height * sc);
    t.getContext('2d').drawImage($qrCanvas, 0, 0, t.width, t.height);
    const decoded = await decodeCanvas(t);
    if (decoded !== null) { successes++; if (lastQrDataUri && decoded === lastQrDataUri) correct++; }
  }
  const pct = Math.round((successes / total) * 100);
  const cls = pct >= 80 ? 'good' : pct >= 40 ? 'ok' : 'bad';
  $score.textContent = pct + '%'; $score.className = 'readability-score ' + cls;
  $fill.style.width = pct + '%'; $fill.className = 'readability-fill ' + cls;
  const hints = [];
  if (pct === 0) hints.push('QR unreadable with current overlay.');
  if (pct < 80 && overlayImg) {
    const ecc = $('#qr-ecc').value, ovs = parseInt($('#ov-scale').value);
    if (ecc !== 'HIGH') hints.push('Try <strong>High</strong> error correction.');
    if (ovs > 25) hints.push('Reduce overlay scale (now ' + ovs + '%).');
    if (parseInt($('#ov-opacity').value) > 90) hints.push('Reduce overlay opacity.');
    const xP = parseInt($('#ov-x').value), yP = parseInt($('#ov-y').value);
    if ((xP < 25 && yP < 25) || (xP > 75 && yP < 25) || (xP < 25 && yP > 75)) hints.push('Move overlay away from finder patterns.');
    if ($('#qr-mask').value === '-1' && pct > 0 && pct < 60) hints.push('Try different mask patterns.');
  }
  if (pct >= 80 && successes === total) { hints.push('Scans reliably (' + successes + '/' + total + ').'); if (correct === successes) hints.push('All decodes correct.'); }
  hints.push('<em>' + (hasJsQR ? 'jsQR' : 'BarcodeDetector') + '</em>');
  $status.innerHTML = '<ul class="readability-hints">' + hints.map(h => '<li>' + h + '</li>').join('') + '</ul>';
}

// ══════════════════════════════════════════════════
// INTERACTIVE OVERLAY HANDLES
// ══════════════════════════════════════════════════

let dragState = null;

function screenPx(px) {
  const rect = $handleCanvas.getBoundingClientRect();
  return px * ($handleCanvas.width / (rect.width || 1));
}

function canvasCoords(e) {
  const rect = $handleCanvas.getBoundingClientRect();
  return {
    x: (e.clientX - rect.left) * ($handleCanvas.width / rect.width),
    y: (e.clientY - rect.top) * ($handleCanvas.height / rect.height)
  };
}

function syncHandleCanvas() {
  $handleCanvas.width = $cardPreview.width;
  $handleCanvas.height = $cardPreview.height;
}

function getOverlayBounds() {
  if (!overlayImg) return null;
  const cw = $cardPreview.width, ch = $cardPreview.height;
  const cx = (parseInt($('#ov-x').value) / 100) * cw;
  const cy = (parseInt($('#ov-y').value) / 100) * ch;
  const scalePct = parseInt($('#ov-scale').value) / 100;
  const rotation = (parseInt($('#ov-rotation').value) || 0) * Math.PI / 180;
  const maxDim = Math.max(overlayImg.naturalWidth, overlayImg.naturalHeight);
  const ratio = (cw * scalePct) / maxDim;
  return { cx, cy, w: overlayImg.naturalWidth * ratio, h: overlayImg.naturalHeight * ratio, rotation };
}

function snapAngle(deg) {
  for (const s of [0, 45, 90, 135, 180, 225, 270, 315, 360])
    if (Math.abs(deg - s) < 4) return s % 360;
  return deg;
}

let handlesVisible = true;

function drawHandles() {
  const ctx = $handleCanvas.getContext('2d');
  ctx.clearRect(0, 0, $handleCanvas.width, $handleCanvas.height);
  if (!handlesVisible) return;
  const b = getOverlayBounds();
  if (!b) return;

  const hs = screenPx(8), rotOff = screenPx(28), lw = screenPx(1.5);

  ctx.save();
  ctx.translate(b.cx, b.cy);
  ctx.rotate(b.rotation);

  // Selection rect
  ctx.setLineDash([screenPx(6), screenPx(4)]);
  ctx.strokeStyle = 'rgba(212,160,23,0.85)';
  ctx.lineWidth = lw;
  ctx.strokeRect(-b.w / 2, -b.h / 2, b.w, b.h);
  ctx.setLineDash([]);

  // Corners
  const corners = [[-b.w/2,-b.h/2],[b.w/2,-b.h/2],[b.w/2,b.h/2],[-b.w/2,b.h/2]];
  ctx.fillStyle = '#d4a017';
  ctx.strokeStyle = '#1a1a18';
  ctx.lineWidth = screenPx(1);
  for (const [hx, hy] of corners) {
    ctx.fillRect(hx - hs, hy - hs, hs * 2, hs * 2);
    ctx.strokeRect(hx - hs, hy - hs, hs * 2, hs * 2);
  }

  // Rotation handle
  ctx.beginPath();
  ctx.moveTo(0, -b.h / 2);
  ctx.lineTo(0, -b.h / 2 - rotOff);
  ctx.strokeStyle = 'rgba(212,160,23,0.85)';
  ctx.lineWidth = lw;
  ctx.stroke();
  const rr = screenPx(6);
  ctx.beginPath();
  ctx.arc(0, -b.h / 2 - rotOff, rr, 0, Math.PI * 2);
  ctx.fillStyle = '#d4a017';
  ctx.fill();
  ctx.strokeStyle = '#1a1a18';
  ctx.lineWidth = screenPx(1);
  ctx.stroke();
  // Arc hint
  ctx.beginPath();
  ctx.arc(0, -b.h / 2 - rotOff, rr * 0.55, -Math.PI * 0.7, Math.PI * 0.3);
  ctx.strokeStyle = '#1a1a18';
  ctx.lineWidth = screenPx(1);
  ctx.stroke();

  ctx.restore();
}

function hitTest(px, py) {
  const b = getOverlayBounds();
  if (!b) return null;
  const dx = px - b.cx, dy = py - b.cy;
  const cos = Math.cos(-b.rotation), sin = Math.sin(-b.rotation);
  const lx = dx * cos - dy * sin, ly = dx * sin + dy * cos;
  const hs = screenPx(12), rotOff = screenPx(28), rotR = screenPx(10);

  if (Math.sqrt(lx * lx + (ly + b.h / 2 + rotOff) ** 2) < rotR) return { type: 'rotate' };
  for (const c of [{n:'tl',x:-b.w/2,y:-b.h/2},{n:'tr',x:b.w/2,y:-b.h/2},{n:'br',x:b.w/2,y:b.h/2},{n:'bl',x:-b.w/2,y:b.h/2}])
    if (Math.abs(lx - c.x) < hs && Math.abs(ly - c.y) < hs) return { type: 'resize', corner: c.n };
  if (Math.abs(lx) < b.w / 2 && Math.abs(ly) < b.h / 2) return { type: 'move' };
  return null;
}

function setSlider(id, val) {
  $('#' + id).value = val;
}

function onHandleDown(e) {
  if (!overlayImg) return;
  const pos = canvasCoords(e), hit = hitTest(pos.x, pos.y);
  if (!hit) {
    // Click outside overlay — hide handles for clean preview
    if (handlesVisible) { handlesVisible = false; drawHandles(); }
    return;
  }
  // Click on overlay — show handles if hidden, then start drag
  if (!handlesVisible) { handlesVisible = true; drawHandles(); return; }
  e.preventDefault();
  $handleCanvas.setPointerCapture(e.pointerId);
  const b = getOverlayBounds();
  dragState = {
    type: hit.type, corner: hit.corner,
    startX: pos.x, startY: pos.y,
    startOvX: parseInt($('#ov-x').value), startOvY: parseInt($('#ov-y').value),
    startOvScale: parseInt($('#ov-scale').value),
    cx: b.cx, cy: b.cy
  };
}

function onHandleMove(e) {
  if (!overlayImg) { $handleCanvas.style.cursor = 'default'; return; }
  const pos = canvasCoords(e);
  if (!dragState) {
    const hit = hitTest(pos.x, pos.y);
    $handleCanvas.style.cursor = !hit ? 'default' : hit.type === 'move' ? 'move' : hit.type === 'rotate' ? 'crosshair' : 'nwse-resize';
    return;
  }
  e.preventDefault();
  const cw = $cardPreview.width, ch = $cardPreview.height;
  if (dragState.type === 'move') {
    setSlider('ov-x', Math.round(dragState.startOvX + (pos.x - dragState.startX) / cw * 100));
    setSlider('ov-y', Math.round(dragState.startOvY + (pos.y - dragState.startY) / ch * 100));
    refreshComposite();
  }
  if (dragState.type === 'resize') {
    const sd = Math.sqrt((dragState.startX - dragState.cx) ** 2 + (dragState.startY - dragState.cy) ** 2);
    const cd = Math.sqrt((pos.x - dragState.cx) ** 2 + (pos.y - dragState.cy) ** 2);
    if (sd > 0) { setSlider('ov-scale', Math.round(Math.max(1, dragState.startOvScale * cd / sd))); refreshComposite(); }
  }
  if (dragState.type === 'rotate') {
    let deg = Math.atan2(pos.x - dragState.cx, -(pos.y - dragState.cy)) * 180 / Math.PI;
    deg = snapAngle(Math.round(((deg % 360) + 360) % 360));
    setSlider('ov-rotation', deg);
    refreshComposite();
  }
}

function onHandleUp(e) {
  if (dragState) { $handleCanvas.releasePointerCapture(e.pointerId); dragState = null; }
}

$handleCanvas.addEventListener('pointerdown', onHandleDown);
$handleCanvas.addEventListener('pointermove', onHandleMove);
$handleCanvas.addEventListener('pointerup', onHandleUp);
$handleCanvas.addEventListener('pointercancel', onHandleUp);

// ══════════════════════════════════════════════════
// CONTROLS
// ══════════════════════════════════════════════════

// Examples
$examples.addEventListener('change', function() {
  var key = $examples.value;
  if (!key) return;
  $source.value = EXAMPLES[key] || '';
  updateSourceInfo();
  syncSourceToMeta();
  press();
  $examples.value = '';
});

// Metadata
$metaTitle.addEventListener('input', syncMetaToSource);
$metaAuthor.addEventListener('input', syncMetaToSource);
$metaExtra.addEventListener('input', syncMetaToSource);
$metaDesc.addEventListener('input', () => {
  syncMetaToSource();
  $cardText.placeholder = $metaDesc.value.trim() || 'Auto-fills from desc (editable)';
  if (lastQrDataUri) renderCardPreview();
});
$cardText.addEventListener('input', () => {
  if (lastQrDataUri) renderCardPreview();
});

// File drop
const $dropzone = $('#dropzone'), $fileInput = $('#file-input');
$dropzone.addEventListener('click', () => $fileInput.click());
$dropzone.addEventListener('dragover', e => { e.preventDefault(); $dropzone.classList.add('dragover'); });
$dropzone.addEventListener('dragleave', () => $dropzone.classList.remove('dragover'));
$dropzone.addEventListener('drop', e => {
  e.preventDefault(); $dropzone.classList.remove('dragover');
  if (e.dataTransfer.files[0]) { loadFile(e.dataTransfer.files[0]); return; }
  const text = e.dataTransfer.getData('text');
  if (text) {
    const html = decodeDataURI(text);
    if (html) { $source.value = html; updateSourceInfo(); syncSourceToMeta(); if ($('#chk-auto').checked) press(); }
  }
});
$fileInput.addEventListener('change', () => { if ($fileInput.files[0]) loadFile($fileInput.files[0]); });

async function loadFile(file) {
  if (file.name.toLowerCase().endsWith('.pdf')) {
    const uri = await extractFromPDF(file);
    if (!uri) { $msgArea.innerHTML = '<div class="msg msg-err">No GCUES cartridge data found in PDF.</div>'; return; }
    const html = decodeDataURI(uri);
    if (html) { $source.value = html; } else { $source.value = uri; }
    updateSourceInfo(); syncSourceToMeta();
    if ($('#chk-auto').checked) press();
    return;
  }
  const reader = new FileReader();
  reader.onload = () => {
    const raw = reader.result;
    $source.value = decodeDataURI(raw) || raw;
    updateSourceInfo(); syncSourceToMeta();
    if ($('#chk-auto').checked) press();
  };
  reader.readAsText(file);
}

// Press / Minify
$('#btn-press').addEventListener('click', press);
$('#btn-minify').addEventListener('click', () => {
  if (!$source.value.trim()) return;
  $source.value = minifyHTML($source.value);
  updateSourceInfo(); syncSourceToMeta();
  if ($('#chk-auto').checked) press();
});

// Auto-decode data URIs pasted into source
function decodeDataURI(str) {
  const s = str.trim();
  const b64 = s.match(/^data:text\/html;base64,(.+)$/i);
  if (b64) try { return atob(b64[1]); } catch { return null; }
  const plain = s.match(/^data:text\/html,(.+)$/is);
  if (plain) try { return decodeURIComponent(plain[1]); } catch { return plain[1]; }
  return null;
}

$source.addEventListener('paste', (e) => {
  const text = (e.clipboardData || window.clipboardData).getData('text');
  const html = decodeDataURI(text);
  if (html) {
    e.preventDefault();
    $source.value = html;
    updateSourceInfo(); syncSourceToMeta();
    if ($('#chk-auto').checked) press();
  }
});

// Auto-press on edit
let pressTimer = null;
$source.addEventListener('input', () => {
  updateSourceInfo(); syncSourceToMeta();
  if ($('#chk-auto').checked) { clearTimeout(pressTimer); pressTimer = setTimeout(press, 500); }
});

// QR settings change → re-press
for (const id of ['qr-ecc','qr-mask','qr-min-ver','qr-max-ver','qr-boost','qr-fg','qr-bg','qr-scale'])
  $('#' + id).addEventListener('change', () => { maskResultsShown = false; if (hasResults) press(); });

// Overlay file
const $ovDrop = $('#overlay-dropzone'), $ovInput = $('#overlay-input');
$ovDrop.addEventListener('click', () => $ovInput.click());
$ovDrop.addEventListener('dragover', e => { e.preventDefault(); $ovDrop.classList.add('dragover'); });
$ovDrop.addEventListener('dragleave', () => $ovDrop.classList.remove('dragover'));
$ovDrop.addEventListener('drop', e => { e.preventDefault(); $ovDrop.classList.remove('dragover'); const f = e.dataTransfer.files[0]; if (f && f.type.startsWith('image/')) loadOverlay(f); });
$ovInput.addEventListener('change', () => { if ($ovInput.files[0]) loadOverlay($ovInput.files[0]); });

function loadOverlay(file) {
  const reader = new FileReader();
  reader.onload = () => {
    const img = new Image();
    img.onload = () => {
      overlayImg = img; maskResultsShown = false;
      $ovDrop.querySelector('.overlay-dropzone-text').textContent = file.name + ' (' + img.naturalWidth + '\u00D7' + img.naturalHeight + ')';
      refreshComposite();
    };
    img.src = reader.result;
  };
  reader.readAsDataURL(file);
}

// Overlay inputs
for (const id of ['ov-x','ov-y','ov-scale','ov-opacity','ov-rotation']) {
  $('#' + id).addEventListener('input', () => { maskResultsShown = false; refreshComposite(); });
}

// Center overlay
$('#btn-ov-center').addEventListener('click', () => {
  setSlider('ov-x', 50);
  setSlider('ov-y', 50);
  setSlider('ov-scale', 25);
  setSlider('ov-rotation', 0);
  handlesVisible = true;
  refreshComposite();
});

// Clear overlay
$('#btn-ov-clear').addEventListener('click', () => {
  overlayImg = null; maskResultsShown = false;
  $ovDrop.querySelector('.overlay-dropzone-text').textContent = 'Drop a PNG/SVG or click to browse';
  $ovInput.value = '';
  setSlider('ov-rotation', 0);
  if (lastQrDataUri) { renderQR(lastQrDataUri); checkReadability(); }
  syncHandleCanvas(); drawHandles();
});

$('#btn-find-mask').addEventListener('click', findBestMask);

// Readability settings → re-check
for (const id of ['read-samples','read-min','read-max'])
  $('#' + id).addEventListener('change', () => { maskResultsShown = false; if (overlayImg && lastQrDataUri) checkReadability(); });

// Copy / Test / Download
$('#btn-copy').addEventListener('click', () => {
  navigator.clipboard.writeText($dataUri.value).then(() => {
    $('#btn-copy').textContent = 'Copied!';
    setTimeout(() => $('#btn-copy').textContent = 'Copy URI', 1500);
  });
});
// Test overlay
const $testOverlay = $('#test-overlay'), $testIframe = $('#test-iframe');
function openTest() {
  const u = $dataUri.value; if (!u) return;
  $testIframe.src = 'gcues.html#' + encodeURIComponent(u);
  $testOverlay.hidden = false;
}
function closeTest() {
  $testOverlay.hidden = true;
  $testIframe.src = 'about:blank';
}
$('#btn-test').addEventListener('click', openTest);
$('#test-close').addEventListener('click', closeTest);
document.addEventListener('keydown', (e) => { if (e.key === 'Escape' && !$testOverlay.hidden) closeTest(); });
$('#btn-dl-qr').addEventListener('click', () => { const a = document.createElement('a'); a.download = 'gcues-cartridge-qr.png'; a.href = $qrCanvas.toDataURL('image/png'); a.click(); });

// ══════════════════════════════════════════════════
// PDF CARTRIDGE CARD
// ══════════════════════════════════════════════════

const PDF_SIZES = {
  tcg:    { w: 63.5, h: 88.9,  label: 'TCG' },
  tarot:  { w: 70,   h: 120,   label: 'Tarot' }
};

function getPreset() {
  const key = $('#pdf-size').value;
  if (key !== 'custom') return PDF_SIZES[key] || PDF_SIZES.tcg;
  const w = parseFloat($('#custom-w').value) || 63.5;
  const h = parseFloat($('#custom-h').value) || 88.9;
  return { w, h, label: w + '\u00D7' + h };
}

// Show/hide custom inputs, persist to localStorage
(function initCustomSize() {
  const $sel = $('#pdf-size');
  const $cust = $('#custom-size-inputs');
  const $cw = $('#custom-w');
  const $ch = $('#custom-h');

  const saved = JSON.parse(localStorage.getItem('gcues-custom-size') || 'null');
  if (saved) { $cw.value = saved.w; $ch.value = saved.h; }

  function toggle() { $cust.style.display = $sel.value === 'custom' ? '' : 'none'; }
  $sel.addEventListener('change', toggle);
  toggle();

  function saveCustom() {
    const w = parseFloat($cw.value), h = parseFloat($ch.value);
    if (w && h) localStorage.setItem('gcues-custom-size', JSON.stringify({ w, h }));
    if (lastQrDataUri) renderCardPreview();
  }
  $cw.addEventListener('change', saveCustom);
  $ch.addEventListener('change', saveCustom);

  // Safe zone persistence
  const $sz = $('#safe-zone');
  const savedSafe = localStorage.getItem('gcues-safe-zone');
  if (savedSafe !== null) $sz.value = savedSafe;
  $sz.addEventListener('change', () => {
    localStorage.setItem('gcues-safe-zone', $sz.value);
    if (lastQrDataUri) renderCardPreview();
  });
})();

// Shared layout calculator — returns positions in mm
function cardLayout(preset) {
  const { w, h } = preset;
  const margin = 4;
  const safe = parseFloat($('#safe-zone').value) || 2;
  const inset = margin + safe;

  const headerTop = inset;
  const headerH = 6;

  const footerH = 4.5;
  const footerRuleY = h - inset - footerH;
  const footerTextY = h - inset - 1;

  // QR gets priority: as large as possible, top-aligned, respecting quiet zones
  const qrPad = 3;  // ~4 modules quiet zone
  const minMetaH = 12;
  const qrAvailW = w - inset * 2;
  const qrY = headerTop + headerH + qrPad;
  const qrMaxH = footerRuleY - 1 - minMetaH - qrY - qrPad;
  const qrSize = Math.max(10, Math.min(qrAvailW, qrMaxH));
  const qrX = (w - qrSize) / 2;

  // Meta: takes remaining space, capped at 20mm
  const metaTop = qrY + qrSize + qrPad;
  const metaH = Math.min(20, footerRuleY - 1 - metaTop);

  // Identicon fills full meta height
  const artSize = metaH;
  const artGap = 2.5;
  const artX = inset;
  const artY = metaTop;

  // Text anchors top-left, aligned with identicon top + padding
  const textX = inset + artSize + artGap;
  const textY = artY + 2.5;  // first baseline near art top

  return { w, h, margin, inset, headerTop, headerH, qrSize, qrX, qrY,
           artSize, artGap, artX, artY, textX, textY,
           metaTop, metaH, footerRuleY, footerTextY };
}

function downloadPDF() {
  if (!lastQrDataUri) return;
  const preset = getPreset();
  const meta = parseMeta($source.value);
  const title = meta.title || $metaTitle.value || 'Untitled';
  const author = meta.author || $metaAuthor.value || '';
  const cardTextRaw = $cardText.value.trim() || meta.desc || '';

  const L = cardLayout(preset);

  // Hi-res QR for print
  const hiCanvas = document.createElement('canvas');
  const hiResult = renderQRToCanvas(hiCanvas, lastQrDataUri, { scale: 10, border: 0 });
  if (!hiResult.ok) return;

  const bgColor = $('#qr-bg').value;
  const fgColor = $('#qr-fg').value;
  const bgRgb = hexToRgb(bgColor);
  const fgRgb = hexToRgb(fgColor);
  const fgDimRgb = hexToRgb(mixColor(fgColor, bgColor, 0.6));
  const fgFaintRgb = hexToRgb(mixColor(fgColor, bgColor, 0.7));
  const fgFooterRgb = hexToRgb(mixColor(fgColor, bgColor, 0.75));

  const pdf = new jspdf.jsPDF({ orientation: L.w > L.h ? 'l' : 'p', unit: 'mm', format: [L.w, L.h] });

  pdf.setFillColor(bgRgb[0], bgRgb[1], bgRgb[2]);
  pdf.rect(0, 0, L.w, L.h, 'F');

  // ── Header ──
  pdf.setFont('helvetica', 'bold');
  pdf.setFontSize(7);
  pdf.setTextColor(fgRgb[0], fgRgb[1], fgRgb[2]);
  pdf.text('GCUES', L.inset, L.headerTop + 3.5);

  pdf.setDrawColor(212, 160, 23);
  pdf.setLineWidth(0.5);
  pdf.line(L.inset, L.headerTop + 5, L.w - L.inset, L.headerTop + 5);

  const dots = [[123,104,174],[192,57,43],[212,160,23],[46,134,193]];
  const dotStartX = L.w - L.inset - dots.length * 3;
  dots.forEach((c, i) => {
    pdf.setFillColor(c[0], c[1], c[2]);
    pdf.circle(dotStartX + i * 3, L.headerTop + 2.5, 0.8, 'F');
  });

  // ── QR code ──
  pdf.addImage(hiCanvas.toDataURL('image/png'), 'PNG', L.qrX, L.qrY, L.qrSize, L.qrSize);

  // ── Hash Art ──
  if (lastHash) {
    const artCanvas = generateHashArt(lastHash, 200);
    pdf.addImage(artCanvas.toDataURL('image/png'), 'PNG', L.artX, L.artY, L.artSize, L.artSize);
  }

  // ── Metadata text (flows freely from textY) ──
  const srcSize = new Blob([$source.value]).size;
  const ver = hiResult.version ? 'V' + hiResult.version : '';
  const autoTitle = $('#chk-auto-title').checked;
  const availW = L.w - L.inset - L.textX;
  let curY = L.textY;

  const pdfFonts = {
    title:    { font: 'helvetica', style: 'bold',   size: 6.5, rgb: fgRgb,      lh: 3.5 },
    subtitle: { font: 'helvetica', style: 'italic', size: 5.5, rgb: fgDimRgb,   lh: 3 },
    mono:     { font: 'courier',   style: 'normal', size: 5,   rgb: fgFaintRgb, lh: 2.5 },
    bold:     { font: 'courier',   style: 'bold',   size: 5,   rgb: fgRgb,      lh: 2.5 },
    italic:   { font: 'helvetica', style: 'italic', size: 5,   rgb: fgDimRgb,   lh: 2.5 },
  };

  function pdfSetFont(s) {
    const f = pdfFonts[s];
    pdf.setFont(f.font, f.style);
    pdf.setFontSize(f.size);
    pdf.setTextColor(f.rgb[0], f.rgb[1], f.rgb[2]);
  }

  if (autoTitle) {
    pdfSetFont('title');
    pdf.text(title, L.textX, curY);
    curY += pdfFonts.title.lh;

    if (author) {
      pdfSetFont('subtitle');
      pdf.text('by ' + author, L.textX, curY);
      curY += pdfFonts.subtitle.lh;
    }
  }

  if (cardTextRaw) {
    const parsed = parseCardMarkup(cardTextRaw);
    const wrapBelow = $('#chk-wrap-text').checked;
    const wrapY = L.artY + L.artSize + 1;  // 1mm padding below art
    const fullX = L.inset;
    const fullAvailW = L.w - L.inset * 2;

    function getX() { return (wrapBelow && curY >= wrapY) ? fullX : L.textX; }
    function getW() { return (wrapBelow && curY >= wrapY) ? fullAvailW : availW; }

    for (const line of parsed) {
      const lx = getX(), lw = getW();
      if (line.style === 'title' || line.style === 'subtitle') {
        pdfSetFont(line.style);
        pdf.text(line.segments[0].text, lx, curY);
        curY += pdfFonts[line.style].lh;
      } else {
        let curX = lx;
        for (const seg of line.segments) {
          pdfSetFont(seg.style);
          const segW = pdf.getTextWidth(seg.text);
          const cx = getX(), cw = getW();
          if (curX + segW > cx + cw && curX > cx) {
            curY += pdfFonts.mono.lh;
            curX = getX();
          }
          pdf.text(seg.text, curX, curY);
          curX += segW;
        }
        curY += pdfFonts.mono.lh;
      }
    }
  }

  // ── Footer (includes stats) ──
  pdf.setDrawColor(212, 160, 23);
  pdf.setLineWidth(0.3);
  pdf.line(L.inset, L.footerRuleY, L.w - L.inset, L.footerRuleY);
  pdf.setFont('helvetica', 'normal');
  pdf.setFontSize(4.5);
  pdf.setTextColor(fgFooterRgb[0], fgFooterRgb[1], fgFooterRgb[2]);
  const modeText = $('#stat-mode').textContent || 'Raw';
  pdf.text('GCUES CARTRIDGE \u00B7 ' + new Date().toISOString().split('T')[0]
    + ' \u00B7 ' + srcSize + ' B \u00B7 ' + modeText + ' \u00B7 ' + ver, L.inset, L.footerTextY);

  // ── Image overlay (full-card layer) ──
  if (overlayImg) {
    const DPI = 300;
    const pxW = Math.round(L.w / 25.4 * DPI), pxH = Math.round(L.h / 25.4 * DPI);
    const ovC = document.createElement('canvas');
    ovC.width = pxW; ovC.height = pxH;
    const ovCtx = ovC.getContext('2d');
    const oxPct = parseInt($('#ov-x').value) / 100;
    const oyPct = parseInt($('#ov-y').value) / 100;
    const oscale = parseInt($('#ov-scale').value) / 100;
    const oalpha = parseInt($('#ov-opacity').value) / 100;
    const orot = (parseInt($('#ov-rotation').value) || 0) * Math.PI / 180;
    const maxDim = Math.max(overlayImg.naturalWidth, overlayImg.naturalHeight);
    const target = pxW * oscale;
    const ratio = target / maxDim;
    const ow = overlayImg.naturalWidth * ratio;
    const oh = overlayImg.naturalHeight * ratio;
    ovCtx.globalAlpha = oalpha;
    ovCtx.translate(oxPct * pxW, oyPct * pxH);
    ovCtx.rotate(orot);
    ovCtx.drawImage(overlayImg, -ow / 2, -oh / 2, ow, oh);
    pdf.addImage(ovC.toDataURL('image/png'), 'PNG', 0, 0, L.w, L.h);
  }

  // ── Page 2: selectable text fallback (optional) ──
  if ($('#chk-data-page').checked) {
    pdf.addPage([L.w, L.h]);
    pdf.setFillColor(255, 255, 255);
    pdf.rect(0, 0, L.w, L.h, 'F');

    pdf.setFont('helvetica', 'normal');
    pdf.setFontSize(5.5);
    pdf.setTextColor(10, 10, 8);
    pdf.text('GCUES Cartridge Data', L.margin, L.margin + 3);

    pdf.setFontSize(4.5);
    pdf.setTextColor(120, 120, 120);
    pdf.text('Select all and paste into GCUES, or import this PDF into Press.', L.margin, L.margin + 7);

    pdf.setFont('courier', 'normal');
    pdf.setFontSize(3.5);
    pdf.setTextColor(180, 180, 180);
    const lines = pdf.splitTextToSize(lastQrDataUri, L.w - L.margin * 2);
    pdf.text(lines, L.margin, L.margin + 12);
  }

  pdf.setProperties({ title: 'GCUES: ' + title, subject: lastQrDataUri, creator: 'GCUES Press' });

  const slug = (title || 'cartridge').toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-|-$/g, '').slice(0, 40);
  pdf.save('gcues-' + slug + '.pdf');
}

$('#btn-dl-pdf').addEventListener('click', downloadPDF);

// ══════════════════════════════════════════════════
// OUTPUT TABS + CARD PREVIEW
// ══════════════════════════════════════════════════

const $cardPreview = $('#card-preview');

$('#pdf-size').addEventListener('change', () => {
  if (lastQrDataUri) renderCardPreview();
});

$('#chk-debug').addEventListener('change', () => {
  if (lastQrDataUri) renderCardPreview();
});

$('#chk-auto-title').addEventListener('change', () => {
  if (lastQrDataUri) renderCardPreview();
});

$('#chk-wrap-text').addEventListener('change', () => {
  if (lastQrDataUri) renderCardPreview();
});

// Mix a color toward a target by ratio (0 = original, 1 = target)
function mixColor(hex, target, ratio) {
  const h = hex.replace('#',''), t = target.replace('#','');
  const r = Math.round(parseInt(h.substr(0,2),16) * (1-ratio) + parseInt(t.substr(0,2),16) * ratio);
  const g = Math.round(parseInt(h.substr(2,2),16) * (1-ratio) + parseInt(t.substr(2,2),16) * ratio);
  const b = Math.round(parseInt(h.substr(4,2),16) * (1-ratio) + parseInt(t.substr(4,2),16) * ratio);
  return '#' + [r,g,b].map(v => v.toString(16).padStart(2,'0')).join('');
}

function hexToRgb(hex) {
  const h = hex.replace('#','');
  return [parseInt(h.substr(0,2),16), parseInt(h.substr(2,2),16), parseInt(h.substr(4,2),16)];
}

function renderCardPreview() {
  if (!lastQrDataUri) return;
  const preset = getPreset();
  const meta = parseMeta($source.value);
  const title = meta.title || $metaTitle.value || 'Untitled';
  const author = meta.author || $metaAuthor.value || '';
  const cardTextRaw = $cardText.value.trim() || meta.desc || '';

  const bgColor = $('#qr-bg').value;
  const fgColor = $('#qr-fg').value;
  const fgDim = mixColor(fgColor, bgColor, 0.6);     // author
  const fgFaint = mixColor(fgColor, bgColor, 0.7);    // card text
  const fgFooter = mixColor(fgColor, bgColor, 0.75);  // footer

  const S = 4;
  const px = (mm) => mm * S;
  const fs = (ptMm) => ptMm * S * 0.35;

  const L = cardLayout(preset);

  const cw = Math.round(L.w * S), ch = Math.round(L.h * S);
  $cardPreview.width = cw;
  $cardPreview.height = ch;
  const ctx = $cardPreview.getContext('2d');

  ctx.fillStyle = bgColor;
  ctx.fillRect(0, 0, cw, ch);
  const m = px(L.inset);

  const dbg = $('#chk-debug').checked;
  if (dbg) {
    ctx.strokeStyle = 'magenta'; ctx.lineWidth = 1;
    ctx.strokeRect(m, px(L.headerTop), cw - m * 2, px(L.headerH));
    ctx.strokeStyle = 'cyan'; ctx.lineWidth = 1;
    ctx.strokeRect(m, px(L.footerRuleY), cw - m * 2, px(L.footerTextY - L.footerRuleY + 1));
  }

  // ── Header ──
  ctx.font = 'bold ' + fs(7) + 'px Helvetica, Arial, sans-serif';
  ctx.fillStyle = fgColor;
  ctx.textBaseline = 'alphabetic';
  ctx.fillText('GCUES', m, px(L.headerTop + 3.5));

  ctx.strokeStyle = '#d4a017';
  ctx.lineWidth = px(0.5);
  ctx.beginPath();
  ctx.moveTo(m, px(L.headerTop + 5));
  ctx.lineTo(cw - m, px(L.headerTop + 5));
  ctx.stroke();

  const dots = ['#7b68ae','#c0392b','#d4a017','#2e86c1'];
  const dotStartX = cw - m - dots.length * px(3);
  dots.forEach((c, i) => {
    ctx.beginPath();
    ctx.arc(dotStartX + i * px(3), px(L.headerTop + 2.5), px(0.8), 0, Math.PI * 2);
    ctx.fillStyle = c;
    ctx.fill();
  });

  // ── QR code ──
  const qrOff = document.createElement('canvas');
  const qrResult = renderQRToCanvas(qrOff, lastQrDataUri, { scale: 4, border: 0 });
  if (qrResult.ok) {
    ctx.drawImage(qrOff, px(L.qrX), px(L.qrY), px(L.qrSize), px(L.qrSize));

    if (dbg) {
      const qzMm = (L.qrSize / qrResult.modules) * 4;
      ctx.strokeStyle = 'green'; ctx.lineWidth = 1;
      ctx.setLineDash([4, 3]);
      ctx.strokeRect(px(L.qrX - qzMm), px(L.qrY - qzMm), px(L.qrSize + qzMm * 2), px(L.qrSize + qzMm * 2));
      ctx.setLineDash([]);
    }
  }

  if (dbg) {
    ctx.strokeStyle = 'blue'; ctx.lineWidth = 1;
    ctx.strokeRect(m, px(L.metaTop), cw - m * 2, px(L.metaH));
    ctx.strokeStyle = 'red'; ctx.lineWidth = 1;
    ctx.strokeRect(px(L.artX), px(L.artY), px(L.artSize), px(L.artSize));
  }

  if (lastHash) {
    const artCanvas = generateHashArt(lastHash, Math.round(px(L.artSize)));
    ctx.drawImage(artCanvas, px(L.artX), px(L.artY), px(L.artSize), px(L.artSize));
  }

  // ── Metadata text (flows freely from textY) ──
  const srcSize = new Blob([$source.value]).size;
  const ver = qrResult.ok && qrResult.version ? 'V' + qrResult.version : '';
  const textX = px(L.textX);
  const titleFontPx = fs(6.5);
  const subtitleFontPx = fs(5.5);
  const monoFontPx = fs(5);
  const autoTitle = $('#chk-auto-title').checked;
  let curY = px(L.textY);

  const fonts = {
    title: 'bold ' + titleFontPx + 'px Helvetica, Arial, sans-serif',
    subtitle: 'italic ' + subtitleFontPx + 'px Helvetica, Arial, sans-serif',
    mono: monoFontPx + 'px "IBM Plex Mono", monospace',
    bold: 'bold ' + monoFontPx + 'px "IBM Plex Mono", monospace',
    italic: 'italic ' + monoFontPx + 'px Helvetica, Arial, sans-serif',
  };
  const colors = {
    title: fgColor, subtitle: fgDim,
    mono: fgFaint, bold: fgColor, italic: fgDim,
  };
  const lineH = {
    title: titleFontPx + px(0.5),
    subtitle: subtitleFontPx + px(0.5),
    mono: monoFontPx + px(0.3),
  };

  ctx.textBaseline = 'alphabetic';

  // Auto title/author (unless disabled)
  if (autoTitle) {
    ctx.font = fonts.title;
    ctx.fillStyle = colors.title;
    ctx.fillText(title, textX, curY);
    curY += lineH.title;

    if (author) {
      ctx.font = fonts.subtitle;
      ctx.fillStyle = colors.subtitle;
      ctx.fillText('by ' + author, textX, curY);
      curY += lineH.subtitle;
    }
  }

  // Card text with markup
  if (cardTextRaw) {
    const parsed = parseCardMarkup(cardTextRaw);
    const availW = cw - m - textX;
    const wrapBelow = $('#chk-wrap-text').checked;
    const float = wrapBelow ? {
      wrapY: px(L.artY + L.artSize) + px(1),  // 1mm padding below art
      fullX: m,
      fullMaxW: cw - m * 2,
    } : null;
    curY = drawCardMarkup(ctx, parsed, textX, curY, availW, fonts, colors, lineH, float);
  }

  // ── Footer (includes stats) ──
  ctx.strokeStyle = '#d4a017';
  ctx.lineWidth = px(0.3);
  ctx.beginPath();
  ctx.moveTo(m, px(L.footerRuleY));
  ctx.lineTo(cw - m, px(L.footerRuleY));
  ctx.stroke();

  const modeText = $('#stat-mode').textContent || 'Raw';
  ctx.font = fs(4.5) + 'px Helvetica, Arial, sans-serif';
  ctx.fillStyle = fgFooter;
  ctx.fillText('GCUES CARTRIDGE \u00B7 ' + new Date().toISOString().split('T')[0]
    + ' \u00B7 ' + srcSize + ' B \u00B7 ' + modeText + ' \u00B7 ' + ver, m, px(L.footerTextY));

  // ── Image overlay (composited over the full card) ──
  if (overlayImg) {
    const oxPct = parseInt($('#ov-x').value) / 100;
    const oyPct = parseInt($('#ov-y').value) / 100;
    const oscale = parseInt($('#ov-scale').value) / 100;
    const oalpha = parseInt($('#ov-opacity').value) / 100;
    const orot = (parseInt($('#ov-rotation').value) || 0) * Math.PI / 180;
    const maxDim = Math.max(overlayImg.naturalWidth, overlayImg.naturalHeight);
    const target = cw * oscale;
    const ratio = target / maxDim;
    const ow = overlayImg.naturalWidth * ratio;
    const oh = overlayImg.naturalHeight * ratio;
    ctx.save();
    ctx.globalAlpha = oalpha;
    ctx.translate(oxPct * cw, oyPct * ch);
    ctx.rotate(orot);
    ctx.drawImage(overlayImg, -ow / 2, -oh / 2, ow, oh);
    ctx.restore();
  }

  $('#card-preview-label').textContent = preset.label + ' \u2014 ' + L.w + '\u00D7' + L.h + 'mm (QR: ' + L.qrSize.toFixed(1) + 'mm)';
}

// ══════════════════════════════════════════════════
// PDF IMPORT (raw byte regex — no PDF.js needed)
// ══════════════════════════════════════════════════

function unescapePdfString(s) {
  return s
    .replace(/\\n/g, '\n')
    .replace(/\\r/g, '\r')
    .replace(/\\t/g, '\t')
    .replace(/\\\(/g, '(')
    .replace(/\\\)/g, ')')
    .replace(/\\\\/g, '\\')
    .replace(/\\([0-7]{1,3})/g, (_, oct) => String.fromCharCode(parseInt(oct, 8)));
}

async function extractFromPDF(file) {
  const buf = await file.arrayBuffer();
  const bytes = new Uint8Array(buf);
  const text = Array.from(bytes, b => String.fromCharCode(b)).join('');

  // Strategy 1: /Subject as literal string
  const subj = text.match(/\/Subject\s*\(([^)]*data:text\/html[^)]*)\)/);
  if (subj) return unescapePdfString(subj[1]);

  // Strategy 2: /Subject as hex string
  const hex = text.match(/\/Subject\s*<([0-9A-Fa-f]+)>/);
  if (hex) {
    const decoded = hex[1].replace(/../g, m => String.fromCharCode(parseInt(m, 16)));
    if (decoded.includes('data:text/html')) return decoded;
  }

  // Strategy 3: find data URI anywhere in the PDF
  const raw = text.match(/data:text\/html[,%][^\s)>]*/);
  if (raw) return unescapePdfString(raw[0]);

  return null;
}

// Init — check fragment for auto-load (#example=gradient, #load=data:text/html,...)
(function initFromFragment() {
  const hash = location.hash.slice(1);
  if (!hash) return;
  const params = new URLSearchParams(hash);
  const ex = params.get('example');
  if (ex && EXAMPLES[ex]) {
    $source.value = EXAMPLES[ex];
    updateSourceInfo();
    syncSourceToMeta();
    press();
    return;
  }
  const load = params.get('load');
  if (load) {
    const html = decodeDataURI(load);
    if (html) {
      $source.value = html;
      updateSourceInfo();
      syncSourceToMeta();
      press();
      return;
    }
  }
})();
updateSourceInfo();

})();
</script>

</body>
</html>
